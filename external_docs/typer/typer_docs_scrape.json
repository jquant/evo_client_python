[
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/terminating/#terminating)\n\n# Terminating [¶](https://typer.tiangolo.com/tutorial/terminating/\\#terminating \"Permanent link\")\n\nThere are some cases where you might want to terminate a command at some point, and stop all subsequent execution.\n\nIt could be that your code determined that the program completed successfully, or it could be an operation aborted.\n\n## `Exit` a CLI program [¶](https://typer.tiangolo.com/tutorial/terminating/\\#exit-a-cli-program \"Permanent link\")\n\nYou can normally just let the code of your CLI program finish its execution, but in some scenarios, you might want to terminate at some point in the middle of it. And prevent any subsequent code to run.\n\nThis doesn't have to mean that there's an error, just that nothing else needs to be executed.\n\nIn that case, you can raise a `typer.Exit()` exception:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nimport typer\n\nexisting_usernames = [\"rick\", \"morty\"]\n\ndef maybe_create_user(username: str):\n    if username in existing_usernames:\n        print(\"The user already exists\")\n        raise typer.Exit()\n    else:\n        print(f\"User created: {username}\")\n\ndef send_new_user_notification(username: str):\n    # Somehow send a notification here for the new user, maybe an email\n    print(f\"Notification sent for new user: {username}\")\n\ndef main(username: str):\n    maybe_create_user(username=username)\n    send_new_user_notification(username=username)\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nThere are several things to see in this example.\n\n- The CLI program is the function `main()`, not the others. This is the one that takes a _CLI argument_.\n- The function `maybe_create_user()` can terminate the program by raising `typer.Exit()`.\n- If the program is terminated by `maybe_create_user()` then `send_new_user_notification()` will never execute inside of `main()`.\n\nCheck it:\n\n```\n\nfast →python main.py Camila\nUser created: Camila\nNotification sent for new user: Camila\n\n💬 Try with an existing userpython main.py rick\nThe user already exists\n\n💬 Notice that the notification code was never run, the second message is not printed\nrestart ↻\n```\n\nTip\n\nEven though you are raising an exception, it doesn't necessarily mean there's an error.\n\nThis is done with an exception because it works as an \"error\" and stops all execution.\n\nBut then **Typer** (actually Click) catches it and just terminates the program normally.\n\n## Exit with an error [¶](https://typer.tiangolo.com/tutorial/terminating/\\#exit-with-an-error \"Permanent link\")\n\n`typer.Exit()` takes an optional `code` parameter. By default, `code` is `0`, meaning there was no error.\n\nYou can pass a `code` with a number other than `0` to tell the terminal that there was an error in the execution of the program:\n\n[Python 3.8+](#__tabbed_2_1)\n\n```md-code__content\nimport typer\n\ndef main(username: str):\n    if username == \"root\":\n        print(\"The root user is reserved\")\n        raise typer.Exit(code=1)\n    print(f\"New user created: {username}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nCheck it:\n\n```\n\nfast →python main.py Camila\nNew user created: Camila\n\n💬 Print the result code of the last program executedecho $?\n0\n\n💬 Now make it exit with an errorpython main.py root\nThe root user is reserved\n\n💬 Print the result code of the last program executedecho $?\n1\n\n💬 1 means there was an error, 0 means no errors.\nrestart ↻\n```\n\nTip\n\nThe error code might be used by other programs (for example a Bash script) that execute your CLI program.\n\n## Abort [¶](https://typer.tiangolo.com/tutorial/terminating/\\#abort \"Permanent link\")\n\nThere's a special exception that you can use to \"abort\" a program.\n\nIt works more or less the same as `typer.Exit()` but will print `\"Aborted!\"` to the screen and can be useful in certain cases later to make it explicit that the execution was aborted:\n\n[Python 3.8+](#__tabbed_3_1)\n\n```md-code__content\nimport typer\n\ndef main(username: str):\n    if username == \"root\":\n        print(\"The root user is reserved\")\n        raise typer.Abort()\n    print(f\"New user created: {username}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nCheck it:\n\n```\n\nfast →python main.py Camila\nNew user created: Camila\n\n💬 Now make it exit with an errorpython main.py root\nThe root user is reserved\nAborted!\n\nrestart ↻\n```\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/terminating/",
      "ogUrl": "https://typer.tiangolo.com/tutorial/terminating/",
      "title": "Terminating - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/terminating/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/terminating.png",
      "ogTitle": "Terminating - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/terminating.png",
      "og:title": "Terminating - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/terminating/",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/terminating.png",
      "twitter:title": "Terminating - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/multiple-values/options-with-multiple-values/#cli-options-with-multiple-values)\n\n# CLI Options with Multiple Values [¶](https://typer.tiangolo.com/tutorial/multiple-values/options-with-multiple-values/\\#cli-options-with-multiple-values \"Permanent link\")\n\nYou can also declare a _CLI option_ that takes several values of different types.\n\nYou can set the number of values and types to anything you want, but it has to be a fixed number of values.\n\nFor this, use the standard Python `typing.Tuple`:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nfrom typing import Tuple\n\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(user: Annotated[Tuple[str, int, bool], typer.Option()] = (None, None, None)):\n    username, coins, is_wizard = user\n    if not username:\n        print(\"No user provided\")\n        raise typer.Abort()\n    print(f\"The username {username} has {coins} coins\")\n    if is_wizard:\n        print(\"And this user is a wizard!\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_2_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nfrom typing import Tuple\n\nimport typer\n\ndef main(user: Tuple[str, int, bool] = typer.Option((None, None, None))):\n    username, coins, is_wizard = user\n    if not username:\n        print(\"No user provided\")\n        raise typer.Abort()\n    print(f\"The username {username} has {coins} coins\")\n    if is_wizard:\n        print(\"And this user is a wizard!\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nEach of the internal types defines the type of each value in the tuple.\n\nSo:\n\n```md-code__content\nuser: Tuple[str, int, bool]\n\n```\n\nmeans that the parameter `user` is a tuple of 3 values.\n\n- The first value is a `str`.\n- The second value is an `int`.\n- The third value is a `bool`.\n\nLater we do:\n\n```md-code__content\nusername, coins, is_wizard = user\n\n```\n\nIf you hadn't seen that, it means that `user` is a tuple with 3 values, and we are assigning each of the values to a new variable:\n\n- The first value in the tuple `user` (a `str`) goes to the variable `username`.\n- The second value in the tuple `user` (an `int`) goes to the variable `coins`.\n- The third value in the tuple `user` (a `bool`) goes to the variable `is_wizard`.\n\nSo, this:\n\n```md-code__content\nusername, coins, is_wizard = user\n\n```\n\nis equivalent to this:\n\n```md-code__content\nusername = user[0]\ncoins = user[1]\nis_wizard = user[2]\n\n```\n\nTip\n\nNotice that the default is a tuple with `(None, None, None)`.\n\nYou cannot simply use `None` here as the default because [Click doesn't support it](https://github.com/pallets/click/issues/472).\n\n## Check it [¶](https://typer.tiangolo.com/tutorial/multiple-values/options-with-multiple-values/\\#check-it \"Permanent link\")\n\nNow let's see how this works in the terminal:\n\n```\n\nfast →💬 check the helppython main.py --help\n💬 Notice the <TEXT INTEGER BOOLEAN>Usage: main.py [OPTIONS]\n\nOptions:\n  --user <TEXT INTEGER BOOLEAN>...\n  --help                          Show this message and exit.\n\n💬 Now try itpython main.py --user Camila 50 yes\nThe username Camila has 50 coins\nAnd this user is a wizard!\n\n💬 With other valuespython main.py --user Morty 3 no\nThe username Morty has 3 coins\n\n💬 Try with invalid values (not enough)python main.py --user Camila 50\nError: Option '--user' requires 3 arguments\n\nrestart ↻\n```\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/multiple-values/options-with-multiple-values/",
      "ogUrl": "https://typer.tiangolo.com/tutorial/multiple-values/options-with-multiple-values/",
      "title": "CLI Options with Multiple Values - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/multiple-values/options-with-multiple-values/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/multiple-values/options-with-multiple-values.png",
      "ogTitle": "CLI Options with Multiple Values - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/multiple-values/options-with-multiple-values.png",
      "og:title": "CLI Options with Multiple Values - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/multiple-values/options-with-multiple-values/",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/multiple-values/options-with-multiple-values.png",
      "twitter:title": "CLI Options with Multiple Values - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/arguments/#cli-arguments)\n\n# CLI Arguments [¶](https://typer.tiangolo.com/tutorial/arguments/\\#cli-arguments \"Permanent link\")\n\nIn the next few sections we'll see some ways to modify how _CLI arguments_ work.\n\nWe'll create optional _CLI arguments_, we'll add integrated help for _CLI arguments_, etc.\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/arguments/",
      "ogUrl": "https://typer.tiangolo.com/tutorial/arguments/",
      "title": "CLI Arguments - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/arguments/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/arguments/index.png",
      "ogTitle": "CLI Arguments - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/arguments/index.png",
      "og:title": "CLI Arguments - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/arguments/",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/arguments/index.png",
      "twitter:title": "CLI Arguments - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/arguments/default/#cli-arguments-with-default)\n\n# CLI Arguments with Default [¶](https://typer.tiangolo.com/tutorial/arguments/default/\\#cli-arguments-with-default \"Permanent link\")\n\nWe can also use the same `typer.Argument()` to set a default value.\n\nThat way the _CLI argument_ will be optional _and also_ have a default value.\n\n## An optional _CLI argument_ with a default [¶](https://typer.tiangolo.com/tutorial/arguments/default/\\#an-optional-cli-argument-with-a-default \"Permanent link\")\n\nWe can also use `typer.Argument()` to make a _CLI argument_ have a default value other than `None`:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(name: Annotated[str, typer.Argument()] = \"Wade Wilson\"):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_2_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(name: str = typer.Argument(\"Wade Wilson\")):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nTip\n\nBecause now the value will be a `str` passed by the user or the default value of `\"Wade Wilson\"` which is also a `str`, we know the value will never be `None`, so we don't have to (and shouldn't) use `Optional[str]`.\n\nHave in mind that the `Optional[something]` tells Python that a value \"could be `None`\". But the use of `Optional` doesn't affect Typer in any way, e.g. it doesn't tell Typer if a value is required or not.\n\nCheck it:\n\n```\n\nfast →💬 Check the helppython main.py --help\n💬 Notice the [default: Wade Wilson] ✨Usage: main.py [OPTIONS] [NAME]\n\nArguments:\n  [NAME]  [default: Wade Wilson]\n\nOptions:\n  --help                Show this message and exit.\n\n💬 With no optional CLI argumentpython main.py\nHello Wade Wilson\n\n💬 With one CLI argumentpython main.py Camila\nHello Camila\n\nrestart ↻\n```\n\n## Dynamic default value [¶](https://typer.tiangolo.com/tutorial/arguments/default/\\#dynamic-default-value \"Permanent link\")\n\nAnd we can even make the default value be dynamically generated by passing a function as the `default_factory` argument:\n\n[Python 3.8+](#__tabbed_3_1)\n\n```md-code__content\nimport random\n\nimport typer\nfrom typing_extensions import Annotated\n\ndef get_name():\n    return random.choice([\"Deadpool\", \"Rick\", \"Morty\", \"Hiro\"])\n\ndef main(name: Annotated[str, typer.Argument(default_factory=get_name)]):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_4_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport random\n\nimport typer\n\ndef get_name():\n    return random.choice([\"Deadpool\", \"Rick\", \"Morty\", \"Hiro\"])\n\ndef main(name: str = typer.Argument(default_factory=get_name)):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nIn this case, we created the function `get_name` that will just return a random `str` each time.\n\nAnd we pass it as the first function argument to `typer.Argument()`.\n\nTip\n\nThe word \"factory\" in `default_factory` is just a fancy way of saying \"function that will create the default value\".\n\nCheck it:\n\n```\n\nfast →💬 Check the helppython main.py --help\nUsage: main.py [OPTIONS] [NAME]\n\nArguments:\n  [NAME]  [default: (dynamic)]\n\nOptions:\n  --help                Show this message and exit.\n\n💬 Try it several times, it will use a random default each timepython main.py\nHello Deadpool\n\npython main.py\nHello Hiro\n\npython main.py\nHello Rick\n\n💬 Now pass a value for the CLI argumentpython main.py Camila\nHello Camila\n\nrestart ↻\n```\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/arguments/default/",
      "ogUrl": "https://typer.tiangolo.com/tutorial/arguments/default/",
      "title": "CLI Arguments with Default - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/arguments/default/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/arguments/default.png",
      "ogTitle": "CLI Arguments with Default - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/arguments/default.png",
      "og:title": "CLI Arguments with Default - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/arguments/default/",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/arguments/default.png",
      "twitter:title": "CLI Arguments with Default - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/launch/#launching-applications)\n\n# Launching Applications [¶](https://typer.tiangolo.com/tutorial/launch/\\#launching-applications \"Permanent link\")\n\nYou can launch applications from your CLI program with `typer.launch()`.\n\nIt will launch the appropriate application depending on the URL or file type you pass it:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nimport typer\n\ndef main():\n    print(\"Opening Typer's docs\")\n    typer.launch(\"https://typer.tiangolo.com\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nCheck it:\n\n```\n\nfast →python main.py\nOpening Typer docs\n\n💬 Opens browser with Typer's docs\nrestart ↻\n```\n\n## Locating a file [¶](https://typer.tiangolo.com/tutorial/launch/\\#locating-a-file \"Permanent link\")\n\nYou can also make the operating system open the file browser indicating where a file is located with `locate=True`:\n\n[Python 3.8+](#__tabbed_2_1)\n\n```md-code__content\nfrom pathlib import Path\n\nimport typer\n\nAPP_NAME = \"my-super-cli-app\"\n\ndef main():\n    app_dir = typer.get_app_dir(APP_NAME)\n    app_dir_path = Path(app_dir)\n    app_dir_path.mkdir(parents=True, exist_ok=True)\n    config_path: Path = Path(app_dir) / \"config.json\"\n    if not config_path.is_file():\n        config_path.write_text('{\"version\": \"1.0.0\"}')\n    config_file_str = str(config_path)\n    print(\"Opening config directory\")\n    typer.launch(config_file_str, locate=True)\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nTip\n\nThe rest of the code in this example is just making sure the app directory exists and creating the config file.\n\nBut the most important part is the `typer.launch(config_file_str, locate=True)` with the argument `locate=True`.\n\nCheck it:\n\n```\n\nfast →python main.py\nOpening config directory\n\n💬 Opens a file browser indicating where the config file is located\nrestart ↻\n```\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/launch/",
      "ogUrl": "https://typer.tiangolo.com/tutorial/launch/",
      "title": "Launching Applications - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/launch/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/launch.png",
      "ogTitle": "Launching Applications - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/launch.png",
      "og:title": "Launching Applications - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/launch/",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/launch.png",
      "twitter:title": "Launching Applications - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/arguments/other-uses/#other-uses)\n\n# Other uses [¶](https://typer.tiangolo.com/tutorial/arguments/other-uses/\\#other-uses \"Permanent link\")\n\n`typer.Argument()` has several other use cases. Such as for data validation, to enable other features, etc.\n\nYou will see about these use cases later in the docs.\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/arguments/other-uses/",
      "ogUrl": "https://typer.tiangolo.com/tutorial/arguments/other-uses/",
      "title": "Other uses - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/arguments/other-uses/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/arguments/other-uses.png",
      "ogTitle": "Other uses - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/arguments/other-uses.png",
      "og:title": "Other uses - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/arguments/other-uses/",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/arguments/other-uses.png",
      "twitter:title": "Other uses - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/commands/context/#using-the-context)\n\n# Using the Context [¶](https://typer.tiangolo.com/tutorial/commands/context/\\#using-the-context \"Permanent link\")\n\nWhen you create a **Typer** application it uses Click underneath. And every Click application has a special object called a [\"Context\"](https://click.palletsprojects.com/en/8.1.x/commands/#nested-handling-and-contexts) that is normally hidden.\n\nBut you can access the context by declaring a function parameter of type `typer.Context`.\n\nYou might have read it in [CLI Option Callback and Context](https://typer.tiangolo.com/tutorial/options/callback-and-context/).\n\nThe same way, in commands or in the main `Typer` callback you can access the context by declaring a function parameter of type `typer.Context`.\n\n## Getting the context [¶](https://typer.tiangolo.com/tutorial/commands/context/\\#getting-the-context \"Permanent link\")\n\nFor example, let's say that you want to execute some logic in a `Typer` callback depending on the subcommand that is being called.\n\nYou can get the name of the subcommand from the context:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\n\n@app.command()\ndef create(username: str):\n    print(f\"Creating user: {username}\")\n\n@app.command()\ndef delete(username: str):\n    print(f\"Deleting user: {username}\")\n\n@app.callback()\ndef main(ctx: typer.Context):\n    \"\"\"\n    Manage users in the awesome CLI app.\n    \"\"\"\n    print(f\"About to execute command: {ctx.invoked_subcommand}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nCheck it:\n\n```\n\nfast →python main.py create Camila\n💬 We get the message from the callbackAbout to execute command: create\nCreating user: Camila\n\npython main.py delete Camila\n💬 We get the message from the callback, this time with deleteAbout to execute command: delete\nDeleting user: Camila\n\nrestart ↻\n```\n\n## Executable callback [¶](https://typer.tiangolo.com/tutorial/commands/context/\\#executable-callback \"Permanent link\")\n\nBy default, the callback is only executed right before executing a command.\n\nAnd if no command is provided, the help message is shown.\n\nBut we could make it run even without a subcommand with `invoke_without_command=True`:\n\n[Python 3.8+](#__tabbed_2_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\n\n@app.command()\ndef create(username: str):\n    print(f\"Creating user: {username}\")\n\n@app.command()\ndef delete(username: str):\n    print(f\"Deleting user: {username}\")\n\n@app.callback(invoke_without_command=True)\ndef main():\n    \"\"\"\n    Manage users in the awesome CLI app.\n    \"\"\"\n    print(\"Initializing database\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nCheck it:\n\n```\n\nfast →python main.py\n💬 The callback is executed, we don't get the default help messageInitializing database\n\n💬 Try with a commandpython main.py create Camila\n💬 The callback is still executedInitializing database\nCreating user: Camila\n\nrestart ↻\n```\n\n## Exclusive executable callback [¶](https://typer.tiangolo.com/tutorial/commands/context/\\#exclusive-executable-callback \"Permanent link\")\n\nWe might not want the callback to be executed if there's already other command that will be executed.\n\nFor that, we can get the `typer.Context` and check if there's an invoked command in `ctx.invoked_subcommand`.\n\nIf it's `None`, it means that we are not calling a subcommand but the main program (the callback) directly:\n\n[Python 3.8+](#__tabbed_3_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\n\n@app.command()\ndef create(username: str):\n    print(f\"Creating user: {username}\")\n\n@app.command()\ndef delete(username: str):\n    print(f\"Deleting user: {username}\")\n\n@app.callback(invoke_without_command=True)\ndef main(ctx: typer.Context):\n    \"\"\"\n    Manage users in the awesome CLI app.\n    \"\"\"\n    if ctx.invoked_subcommand is None:\n        print(\"Initializing database\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nCheck it:\n\n```\n\nfast →python main.py\n💬 The callback is executedInitializing database\n\n💬 Check it with a subcommandpython main.py create Camila\n💬 This time the callback is not executedCreating user: Camila\n\nrestart ↻\n```\n\n## Configuring the context [¶](https://typer.tiangolo.com/tutorial/commands/context/\\#configuring-the-context \"Permanent link\")\n\nYou can pass configurations for the context when creating a command or callback.\n\nTo read more about the available configurations check the docs for [Click's `Context`](https://click.palletsprojects.com/en/7.x/api/#context).\n\nFor example, you could keep additional _CLI parameters_ not declared in your CLI program with `ignore_unknown_options` and `allow_extra_args`.\n\nThen you can access those extra raw _CLI parameters_ as a `list` of `str` in `ctx.args`:\n\n[Python 3.8+](#__tabbed_4_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\n\n@app.command(\n    context_settings={\"allow_extra_args\": True, \"ignore_unknown_options\": True}\n)\ndef main(ctx: typer.Context):\n    for extra_arg in ctx.args:\n        print(f\"Got extra arg: {extra_arg}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\n```\n\nfast →python main.py --name Camila --city Berlin\nGot extra arg: --name\nGot extra arg: Camila\nGot extra arg: --city\nGot extra arg: Berlin\n\nrestart ↻\n```\n\nTip\n\nNotice that it saves all the extra _CLI parameters_ as a raw `list` of `str`, including the _CLI option_ names and values, everything together.\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/commands/context/",
      "ogUrl": "https://typer.tiangolo.com/tutorial/commands/context/",
      "title": "Using the Context - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/commands/context/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/commands/context.png",
      "ogTitle": "Using the Context - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/commands/context.png",
      "og:title": "Using the Context - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/commands/context/",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/commands/context.png",
      "twitter:title": "Using the Context - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/#learn)\n\n# Learn [¶](https://typer.tiangolo.com/tutorial/\\#learn \"Permanent link\")\n\nLearn how to use **Typer** in this step-by-step **Tutorial** \\- **User Guide**.\n\nIt covers everything you need to know from the **simplest scripts** to **complex CLI applications**.\n\nYou could consider this a **book**, a **course**, the **official** and recommended way to learn **Typer**. 😎\n\n## Python Types [¶](https://typer.tiangolo.com/tutorial/\\#python-types \"Permanent link\")\n\nIf you need a refresher about how to use Python type hints, check the first part of [FastAPI's Python types intro](https://fastapi.tiangolo.com/python-types/).\n\nYou can also check the [mypy cheat sheet](https://mypy.readthedocs.io/en/latest/cheat_sheet_py3.html).\n\nIn short (very short), you can declare a function with parameters like:\n\n```md-code__content\nfrom typing import Optional\n\ndef type_example(name: str, formal: bool = False, intro: Optional[str] = None):\n    pass\n\n```\n\nAnd your editor (and **Typer**) will know that:\n\n- `name` is of type `str` and is a required parameter.\n- `formal` is a `bool` and is by default `False`.\n- `intro` is an optional `str`, by default is `None`.\n\nThese type hints are what give you autocomplete in your editor and several other features.\n\n**Typer** is based on these type hints.\n\n## About this Tutorial [¶](https://typer.tiangolo.com/tutorial/\\#about-this-tutorial \"Permanent link\")\n\nThis tutorial shows you how to use **Typer** with all its features, step by step.\n\nEach section gradually builds on the previous ones, but it's structured to separate topics, so that you can go directly to any specific one to solve your specific CLI needs.\n\nIt is also built to work as a future reference so you can come back and see exactly what you need.\n\n## Run the Code [¶](https://typer.tiangolo.com/tutorial/\\#run-the-code \"Permanent link\")\n\nAll the code blocks can be copied and used directly (they are tested Python files).\n\nTo run any of the examples, copy the code to a file `main.py`, and run it:\n\n```\n\nfast →python main.py\n✨ The magic happens here ✨\n\nrestart ↻\n```\n\nIt is **HIGHLY encouraged** that you write or copy the code, edit it and run it locally.\n\nUsing it in your editor is what really shows you the benefits of **Typer**, seeing how little code you have to write, all the **inline errors**, **autocompletion**, etc.\n\nAnd running the examples is what will really help you **understand** what is going on.\n\nYou can learn a lot more by **running some examples** and **playing around** with them than by reading all the docs here.\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/",
      "ogUrl": "https://typer.tiangolo.com/tutorial/",
      "title": "Learn - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/index.png",
      "ogTitle": "Learn - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/index.png",
      "og:title": "Learn - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/index.png",
      "twitter:title": "Learn - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/options/#cli-options)\n\n# CLI Options [¶](https://typer.tiangolo.com/tutorial/options/\\#cli-options \"Permanent link\")\n\nIn the next short sections we will see how to modify _CLI options_ using `typer.Option()`.\n\n`typer.Option()` works very similarly to `typer.Argument()`, but has some extra features that we'll see next.\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/options/",
      "ogUrl": "https://typer.tiangolo.com/tutorial/options/",
      "title": "CLI Options - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/options/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/options/index.png",
      "ogTitle": "CLI Options - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/options/index.png",
      "og:title": "CLI Options - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/options/",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/options/index.png",
      "twitter:title": "CLI Options - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/commands/arguments/#command-cli-arguments)\n\n# Command CLI Arguments [¶](https://typer.tiangolo.com/tutorial/commands/arguments/\\#command-cli-arguments \"Permanent link\")\n\nThe same way as with a CLI application with a single command, subcommands (or just \"commands\") can also have their own _CLI arguments_:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\n\n@app.command()\ndef create(username: str):\n    print(f\"Creating user: {username}\")\n\n@app.command()\ndef delete(username: str):\n    print(f\"Deleting user: {username}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\n```\n\nfast →💬 Check the help for createpython main.py create --help\nUsage: main.py create [OPTIONS] USERNAME\n\nOptions:\n  --help  Show this message and exit.\n\n💬 Call it with a CLI argumentpython main.py create Camila\nCreating user: Camila\n\n💬 The same for deletepython main.py delete Camila\nDeleting user: Camila\n\nrestart ↻\n```\n\nTip\n\nEverything to the _right_ of the _command_ are _CLI parameters_ ( _CLI arguments_ and _CLI options_) for that command.\n\nTechnical Details\n\nActually, it's everything to the right of that command, _before any subcommand_.\n\nIt's possible to have groups of _subcommands_, it's like if one _command_ also had _subcommands_. And then those _subcommands_ could have their own _CLI parameters_, taking their own _CLI parameters_.\n\nYou will see about them later in another section.\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/commands/arguments/",
      "ogUrl": "https://typer.tiangolo.com/tutorial/commands/arguments/",
      "title": "Command CLI Arguments - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/commands/arguments/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/commands/arguments.png",
      "ogTitle": "Command CLI Arguments - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/commands/arguments.png",
      "og:title": "Command CLI Arguments - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/commands/arguments/",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/commands/arguments.png",
      "twitter:title": "Command CLI Arguments - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/one-file-per-command/#one-file-per-command)\n\n# One File Per Command [¶](https://typer.tiangolo.com/tutorial/one-file-per-command/\\#one-file-per-command \"Permanent link\")\n\nWhen your CLI application grows, you can split it into multiple files and modules. This pattern helps maintain a clean and organized code structure. ✨\n\nThis tutorial will show you how to use `add_typer` to create sub commands and organize your commands in multiple files.\n\nWe will create a simple CLI with the following commands:\n\n- `version`\n- `users add NAME`\n- `users delete NAME`\n\n## CLI structure [¶](https://typer.tiangolo.com/tutorial/one-file-per-command/\\#cli-structure \"Permanent link\")\n\nHere is the structure we'll be working with:\n\n```md-code__content\nmycli/\n├── __init__.py\n├── main.py\n├── users/\n│   ├── __init__.py\n│   ├── add.py\n│   └── delete.py\n└── version.py\n\n```\n\n`mycli` will be our package, and it will contain the following modules:\n\n- `main.py`: The main module that will import the `version` and `users` modules.\n- `version.py`: A module that will contain the `version` command.\n- `users/`: A package (inside of our `mycli` package) that will contain the `add` and `delete` commands.\n\n## Implementation [¶](https://typer.tiangolo.com/tutorial/one-file-per-command/\\#implementation \"Permanent link\")\n\nLet's start implementing our CLI! 🚀\n\nWe'll create the `version` module, the `main` module, and the `users` package.\n\n### Version Module ( `version.py`) [¶](https://typer.tiangolo.com/tutorial/one-file-per-command/\\#version-module-versionpy \"Permanent link\")\n\nLet's start by creating the `version` module. This module will contain the `version` command.\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\n\n@app.command()\ndef version():\n    print(\"My CLI Version 1.0\")\n\n```\n\nIn this file we are creating a new Typer app instance for the `version` command.\n\nThis is not required in single-file applications, but in the case of multi-file applications it will allow us to include this command in the main application using `app.add_typer()`.\n\nLet's see that next!\n\n### Main Module ( `main.py`) [¶](https://typer.tiangolo.com/tutorial/one-file-per-command/\\#main-module-mainpy \"Permanent link\")\n\nThe main module will be the entry point of the application. It will import the version module and the users module.\n\nTip\n\nWe'll see how to implement the users module in the next section.\n\n[Python 3.8+](#__tabbed_2_1)\n\n```md-code__content\nimport typer\n\nfrom .users import app as users_app\nfrom .version import app as version_app\n\napp = typer.Typer()\n\napp.add_typer(version_app)\napp.add_typer(users_app, name=\"users\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nIn this module, we import the `version` and `users` modules and add them to the main app using `app.add_typer()`.\n\nFor the `users` module, we specify the name as `\"users\"` to group the commands under the `users` sub-command.\n\nNotice that we didn't add a name for the `version_app` Typer app. Because of this, Typer will add the commands (just one in this case) declared in the `version_app` directly at the top level. So, there will be a top-level `version` sub-command.\n\nBut for `users`, we add a name `\"users\"`, this way those commands will be under the sub-command `users` instead of at the top level. So, there will be a `users add` and `users delete` sub-sub-commands. 😅\n\nTip\n\nIf you want a command to group the included commands in a sub-app, add a name.\n\nIf you want to include the commands from a sub-app directly at the top level, don't add a name, or set it to `None`. 🤓\n\nLet's now create the `users` module with the `add` and `delete` commands.\n\n### Users Add Command ( `users/add.py`) [¶](https://typer.tiangolo.com/tutorial/one-file-per-command/\\#users-add-command-usersaddpy \"Permanent link\")\n\n[Python 3.8+](#__tabbed_3_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\n\n@app.command()\ndef add(name: str):\n    print(f\"Adding user: {name}\")\n\n```\n\nLike the `version` module, we create a new Typer app instance for the `users/add` command. This allows us to include the `add` command in the users app.\n\n### Users Delete Command ( `users/delete.py`) [¶](https://typer.tiangolo.com/tutorial/one-file-per-command/\\#users-delete-command-usersdeletepy \"Permanent link\")\n\n[Python 3.8+](#__tabbed_4_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\n\n@app.command()\ndef delete(name: str):\n    print(f\"Deleting user: {name}\")\n\n```\n\nAnd once again, we create a new Typer app instance for the `users/delete` command. This allows us to include the `delete` command in the users app.\n\n### Users' app ( `users/__init__.py`) [¶](https://typer.tiangolo.com/tutorial/one-file-per-command/\\#users-app-users__init__py \"Permanent link\")\n\nFinally, we need to create an `__init__.py` file in the `users` directory to define the `users` app.\n\n[Python 3.8+](#__tabbed_5_1)\n\n```md-code__content\nimport typer\n\nfrom .add import app as add_app\nfrom .delete import app as delete_app\n\napp = typer.Typer()\n\napp.add_typer(add_app)\napp.add_typer(delete_app)\n\n```\n\nSimilarly to the `version` module, we create a new `Typer` app instance for the `users` module. This allows us to include the `add` and `delete` commands in the users app.\n\n## Running the Application [¶](https://typer.tiangolo.com/tutorial/one-file-per-command/\\#running-the-application \"Permanent link\")\n\nNow we are ready to run the application! 😎\n\nTo run the application, you can execute it as a Python module:\n\n```\n\nfast →python -m mycli.main version\nMy CLI Version 1.0\n\npython -m mycli.main users add Camila\nAdding user: Camila\n\nrestart ↻\n```\n\nAnd if you built a package and installed your app, you can then use the `mycli` command:\n\n```\n\nfast →mycli version\nMy CLI Version 1.0\n\nmycli users add Camila\nAdding user: Camila\n\nrestart ↻\n```\n\n## Callbacks [¶](https://typer.tiangolo.com/tutorial/one-file-per-command/\\#callbacks \"Permanent link\")\n\nHave in mind that if you include a sub-app with `app.add_typer()` **without a name**, the commands will be added to the top level, so **only the top level callback** (if there's any) will be used, the one declared in the main app.\n\nIf you **want to use a callback** for a sub-app, you need to include the sub-app **with a name**, which creates a sub-command grouping the commands in that sub-app. 🤓\n\nIn the example above, if the `users` sub-app had a callback, it would be used. But if the `version` sub-app had a callback, it would not be used, because the `version` sub-app was included without a name.\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/one-file-per-command/",
      "ogUrl": "https://typer.tiangolo.com/tutorial/one-file-per-command/",
      "title": "One File Per Command - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/one-file-per-command/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/one-file-per-command.png",
      "ogTitle": "One File Per Command - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/one-file-per-command.png",
      "og:title": "One File Per Command - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/one-file-per-command/",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/one-file-per-command.png",
      "twitter:title": "One File Per Command - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/multiple-values/arguments-with-multiple-values/#cli-arguments-with-multiple-values)\n\n# CLI Arguments with Multiple Values [¶](https://typer.tiangolo.com/tutorial/multiple-values/arguments-with-multiple-values/\\#cli-arguments-with-multiple-values \"Permanent link\")\n\n_CLI arguments_ can also receive multiple values.\n\nYou can define the type of a _CLI argument_ using `typing.List`.\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nfrom pathlib import Path\nfrom typing import List\n\nimport typer\n\ndef main(files: List[Path], celebration: str):\n    for path in files:\n        if path.is_file():\n            print(f\"This file exists: {path.name}\")\n            print(celebration)\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nAnd then you can pass it as many _CLI arguments_ of that type as you want:\n\n```\n\nfast →python main.py ./index.md ./first-steps.md woohoo!\nThis file exists: index.md\nwoohoo!\nThis file exists: first-steps.md\nwoohoo!\n\nrestart ↻\n```\n\nTip\n\nWe also declared a final _CLI argument_ `celebration`, and it's correctly used even if we pass an arbitrary number of `files` first.\n\nInfo\n\nA `List` can only be used in the last command (if there are subcommands), as this will take anything to the right and assume it's part of the expected _CLI arguments_.\n\n## _CLI arguments_ with tuples [¶](https://typer.tiangolo.com/tutorial/multiple-values/arguments-with-multiple-values/\\#cli-arguments-with-tuples \"Permanent link\")\n\nIf you want a specific number of values and types, you can use a tuple, and it can even have default values:\n\n[Python 3.8+](#__tabbed_2_1)\n\n```md-code__content\nfrom typing import Tuple\n\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(\n    names: Annotated[\\\n        Tuple[str, str, str], typer.Argument(help=\"Select 3 characters to play with\")\\\n    ] = (\"Harry\", \"Hermione\", \"Ron\"),\n):\n    for name in names:\n        print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_3_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nfrom typing import Tuple\n\nimport typer\n\ndef main(\n    names: Tuple[str, str, str] = typer.Argument(\n        (\"Harry\", \"Hermione\", \"Ron\"), help=\"Select 3 characters to play with\"\n    ),\n):\n    for name in names:\n        print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nCheck it:\n\n```\n\nfast →💬 Check the helppython main.py --help\nUsage: main.py [OPTIONS] [NAMES]...\n\nArguments:\n  [NAMES]...  Select 3 characters to play with  [default: Harry, Hermione, Ron]\n\nOptions:\n  --help                Show this message and exit.\n\n💬 Use it with its defaultspython main.py\nHello Harry\nHello Hermione\nHello Ron\n\n💬 If you pass an invalid number of arguments you will get an errorpython main.py Draco Hagrid\nError: Argument 'names' takes 3 values\n\n💬 And if you pass the exact number of values it will work correctlypython main.py Draco Hagrid Dobby\nHello Draco\nHello Hagrid\nHello Dobby\n\nrestart ↻\n```\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/multiple-values/arguments-with-multiple-values/",
      "ogUrl": "https://typer.tiangolo.com/tutorial/multiple-values/arguments-with-multiple-values/",
      "title": "CLI Arguments with Multiple Values - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/multiple-values/arguments-with-multiple-values/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/multiple-values/arguments-with-multiple-values.png",
      "ogTitle": "CLI Arguments with Multiple Values - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/multiple-values/arguments-with-multiple-values.png",
      "og:title": "CLI Arguments with Multiple Values - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/multiple-values/arguments-with-multiple-values/",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/multiple-values/arguments-with-multiple-values.png",
      "twitter:title": "CLI Arguments with Multiple Values - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/options/password/#password-cli-option-and-confirmation-prompt)\n\n# Password CLI Option and Confirmation Prompt [¶](https://typer.tiangolo.com/tutorial/options/password/\\#password-cli-option-and-confirmation-prompt \"Permanent link\")\n\nApart from having a prompt, you can make a _CLI option_ have a `confirmation_prompt=True`:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(\n    name: str,\n    email: Annotated[str, typer.Option(prompt=True, confirmation_prompt=True)],\n):\n    print(f\"Hello {name}, your email is {email}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_2_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(\n    name: str, email: str = typer.Option(..., prompt=True, confirmation_prompt=True)\n):\n    print(f\"Hello {name}, your email is {email}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nAnd the CLI program will ask for confirmation:\n\n```\n\nfast →python main.py Camila\n💬 It prompts for the emailcamila@example.comcamila@example.com\nHello Camila, your email is camila@example.com\n\nrestart ↻\n```\n\n## A Password prompt [¶](https://typer.tiangolo.com/tutorial/options/password/\\#a-password-prompt \"Permanent link\")\n\nWhen receiving a password, it is very common (in most shells) to not show anything on the screen while typing the password.\n\nThe program will still receive the password, but nothing will be shown on screen, not even `****`.\n\nYou can achieve the same using `hide_input=True`.\n\nAnd if you combine it with `confirmation_prompt=True` you can easily receive a password with double confirmation:\n\n[Python 3.8+](#__tabbed_3_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(\n    name: str,\n    password: Annotated[\\\n        str, typer.Option(prompt=True, confirmation_prompt=True, hide_input=True)\\\n    ],\n):\n    print(f\"Hello {name}. Doing something very secure with password.\")\n    print(f\"...just kidding, here it is, very insecure: {password}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_4_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(\n    name: str,\n    password: str = typer.Option(\n        ..., prompt=True, confirmation_prompt=True, hide_input=True\n    ),\n):\n    print(f\"Hello {name}. Doing something very secure with password.\")\n    print(f\"...just kidding, here it is, very insecure: {password}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nCheck it:\n\n```\n\nfast →python main.py Camila\n💬 It prompts for the password, but doesn't show anything when you type Password: $ Repeat for confirmation: $\n💬 Let's imagine the password typed was \"typerrocks\"Hello Camila. Doing something very secure with password.\n...just kidding, here it is, very insecure: typerrocks\n\nrestart ↻\n```\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/options/password/",
      "ogUrl": "https://typer.tiangolo.com/tutorial/options/password/",
      "title": "Password CLI Option and Confirmation Prompt - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/options/password/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/options/password.png",
      "ogTitle": "Password CLI Option and Confirmation Prompt - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/options/password.png",
      "og:title": "Password CLI Option and Confirmation Prompt - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/options/password/",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/options/password.png",
      "twitter:title": "Password CLI Option and Confirmation Prompt - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/parameter-types/path/#path)\n\n# Path [¶](https://typer.tiangolo.com/tutorial/parameter-types/path/\\#path \"Permanent link\")\n\nYou can declare a _CLI parameter_ to be a standard Python [`pathlib.Path`](https://docs.python.org/3/library/pathlib.html#basic-use).\n\nThis is what you would do for directory paths, file paths, etc:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nfrom pathlib import Path\nfrom typing import Optional\n\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(config: Annotated[Optional[Path], typer.Option()] = None):\n    if config is None:\n        print(\"No config file\")\n        raise typer.Abort()\n    if config.is_file():\n        text = config.read_text()\n        print(f\"Config file contents: {text}\")\n    elif config.is_dir():\n        print(\"Config is a directory, will use all its config files\")\n    elif not config.exists():\n        print(\"The config doesn't exist\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_2_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nfrom pathlib import Path\nfrom typing import Optional\n\nimport typer\n\ndef main(config: Optional[Path] = typer.Option(None)):\n    if config is None:\n        print(\"No config file\")\n        raise typer.Abort()\n    if config.is_file():\n        text = config.read_text()\n        print(f\"Config file contents: {text}\")\n    elif config.is_dir():\n        print(\"Config is a directory, will use all its config files\")\n    elif not config.exists():\n        print(\"The config doesn't exist\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nAnd again, as you receive a standard Python `Path` object the same as the type annotation, your editor will give you autocompletion for all its attributes and methods.\n\nCheck it:\n\n```\n\nfast →💬 No configpython main.py\nNo config file\nAborted!\n\n💬 Pass a config that doesn't existpython main.py --config config.txt\nThe config doesn't exist\n\n💬 Now create a quick configecho \"some settings\" > config.txt\n💬 And try againpython main.py --config config.txt\nConfig file contents: some settings\n\n💬 And with a directorypython main.py --config ./\nConfig is a directory, will use all its config files\n\nrestart ↻\n```\n\n## Path validations [¶](https://typer.tiangolo.com/tutorial/parameter-types/path/\\#path-validations \"Permanent link\")\n\nYou can perform several validations for `Path` _CLI parameters_:\n\n- `exists`: if set to true, the file or directory needs to exist for this value to be valid. If this is not required and a file does indeed not exist, then all further checks are silently skipped.\n- `file_okay`: controls if a file is a possible value.\n- `dir_okay`: controls if a directory is a possible value.\n- `writable`: if true, a writable check is performed.\n- `readable`: if true, a readable check is performed.\n- `resolve_path`: if this is true, then the path is fully resolved before the value is passed onwards. This means that it’s absolute and symlinks are resolved.\n\nTechnical Details\n\nIt will not expand a tilde-prefix (something with `~`, like `~/Documents/`), as this is supposed to be done by the shell only.\n\nTip\n\nAll these parameters come directly from [Click](https://click.palletsprojects.com/en/7.x/parameters/#parameter-types).\n\nFor example:\n\n[Python 3.8+](#__tabbed_3_1)\n\n```md-code__content\nfrom pathlib import Path\n\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(\n    config: Annotated[\\\n        Path,\\\n        typer.Option(\\\n            exists=True,\\\n            file_okay=True,\\\n            dir_okay=False,\\\n            writable=False,\\\n            readable=True,\\\n            resolve_path=True,\\\n        ),\\\n    ],\n):\n    text = config.read_text()\n    print(f\"Config file contents: {text}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_4_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nfrom pathlib import Path\n\nimport typer\n\ndef main(\n    config: Path = typer.Option(\n        ...,\n        exists=True,\n        file_okay=True,\n        dir_okay=False,\n        writable=False,\n        readable=True,\n        resolve_path=True,\n    ),\n):\n    text = config.read_text()\n    print(f\"Config file contents: {text}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nCheck it:\n\n```\n\nfast →python main.py --config config.txt\nUsage: main.py [OPTIONS]\nTry \"main.py --help\" for help.\n\nError: Invalid value for '--config': File 'config.txt' does not exist.\n\n💬 Now create a quick configecho \"some settings\" > config.txt\n💬 And try againpython main.py --config config.txt\nConfig file contents: some settings\n\n💬 And with a directorypython main.py --config ./\nUsage: main.py [OPTIONS]\nTry \"main.py --help\" for help.\n\nError: Invalid value for '--config': File './' is a directory.\n\nrestart ↻\n```\n\n### Advanced `Path` configurations [¶](https://typer.tiangolo.com/tutorial/parameter-types/path/\\#advanced-path-configurations \"Permanent link\")\n\nAdvanced Details\n\nYou probably won't need these configurations at first, you may want to skip it.\n\nThey are used for more advanced use cases.\n\n- `allow_dash`: If this is set to True, a single dash to indicate standard streams is permitted.\n- `path_type`: optionally a string type that should be used to represent the path. The default is None which means the return value will be either bytes or unicode depending on what makes most sense given the input data Click deals with.\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/parameter-types/path/",
      "ogUrl": "https://typer.tiangolo.com/tutorial/parameter-types/path/",
      "title": "Path - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/parameter-types/path/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/parameter-types/path.png",
      "ogTitle": "Path - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/parameter-types/path.png",
      "og:title": "Path - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/parameter-types/path/",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/parameter-types/path.png",
      "twitter:title": "Path - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/parameter-types/#cli-parameter-types)\n\n# CLI Parameter Types [¶](https://typer.tiangolo.com/tutorial/parameter-types/\\#cli-parameter-types \"Permanent link\")\n\nYou can use several data types for the _CLI options_ and _CLI arguments_, and you can add data validation requirements too.\n\n## Data conversion [¶](https://typer.tiangolo.com/tutorial/parameter-types/\\#data-conversion \"Permanent link\")\n\nWhen you declare a _CLI parameter_ with some type **Typer** will convert the data received in the command line to that data type.\n\nFor example:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nimport typer\n\ndef main(name: str, age: int = 20, height_meters: float = 1.89, female: bool = True):\n    print(f\"NAME is {name}, of type: {type(name)}\")\n    print(f\"--age is {age}, of type: {type(age)}\")\n    print(f\"--height-meters is {height_meters}, of type: {type(height_meters)}\")\n    print(f\"--female is {female}, of type: {type(female)}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nIn this example, the value received for the _CLI argument_ `NAME` will be treated as `str`.\n\nThe value for the _CLI option_ `--age` will be converted to an `int` and `--height-meters` will be converted to a `float`.\n\nAnd as `female` is a `bool` _CLI option_, **Typer** will convert it to a \"flag\" `--female` and the counterpart `--no-female`.\n\nAnd here's how it looks like:\n\n```\n\nfast →python main.py --help\n💬 Notice how --age is an INTEGER and --height-meters is a FLOATUsage: main.py [OPTIONS] NAME\n\nArguments:\n  NAME  [required]\n\nOptions:\n  --age INTEGER           [default: 20]\n  --height-meters FLOAT   [default: 1.89]\n  --female / --no-female  [default: True]\n  --help                  Show this message and exit.\n\n💬 Call it with CLI parameterspython main.py Camila --age 15 --height-meters 1.70 --female\n💬 All the data has the correct Python typeNAME is Camila, of type: class 'str'\n--age is 15, of type: class 'int'\n--height-meters is 1.7, of type: class 'float'\n--female is True, of type: class 'bool'\n\n💬 And if you pass an incorrect typepython main.py Camila --age 15.3\nUsage: main.py [OPTIONS] NAME\nTry \"main.py --help\" for help.\n\nError: Invalid value for '--age': '15.3' is not a valid integer\n\n💬 Because 15.3 is not an INTEGER (it's a float)\nrestart ↻\n```\n\n## Watch next [¶](https://typer.tiangolo.com/tutorial/parameter-types/\\#watch-next \"Permanent link\")\n\nSee more about specific types and validations in the next sections...\n\nTechnical Details\n\nAll the types you will see in the next sections are handled underneath by [Click's Parameter Types](https://click.palletsprojects.com/en/7.x/parameters/#parameter-types).\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/parameter-types/",
      "ogUrl": "https://typer.tiangolo.com/tutorial/parameter-types/",
      "title": "CLI Parameter Types - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/parameter-types/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/parameter-types/index.png",
      "ogTitle": "CLI Parameter Types - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/parameter-types/index.png",
      "og:title": "CLI Parameter Types - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/parameter-types/",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/parameter-types/index.png",
      "twitter:title": "CLI Parameter Types - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/commands/one-or-multiple/#one-or-multiple-commands)\n\n# One or Multiple Commands [¶](https://typer.tiangolo.com/tutorial/commands/one-or-multiple/\\#one-or-multiple-commands \"Permanent link\")\n\nYou might have noticed that if you create a single command, as in the first example:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\n\n@app.command()\ndef main(name: str):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\n**Typer** is smart enough to create a CLI application with that single function as the main CLI application, not as a command/subcommand:\n\n```\n\nfast →💬 Without a CLI argumentpython main.py\nUsage: main.py [OPTIONS] NAME\nTry \"main.py --help\" for help.\n\nError: Missing argument 'NAME'.\n\n💬 With the NAME CLI argumentpython main.py Camila\nHello Camila\n\n💬 Asking for helppython main.py\nUsage: main.py [OPTIONS] NAME\n\nOptions:\n  --install-completion  Install completion for the current shell.\n  --show-completion     Show completion for the current shell, to copy it or customize the installation.\n  --help                Show this message and exit.\n\nrestart ↻\n```\n\nTip\n\nNotice that it doesn't show a command `main`, even though the function name is `main`.\n\nBut if you add multiple commands, **Typer** will create one _CLI command_ for each one of them:\n\n[Python 3.8+](#__tabbed_2_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\n\n@app.command()\ndef create():\n    print(\"Creating user: Hiro Hamada\")\n\n@app.command()\ndef delete():\n    print(\"Deleting user: Hiro Hamada\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nHere we have 2 commands `create` and `delete`:\n\n```\n\nfast →💬 Check the helppython main.py --help\nUsage: main.py [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  --install-completion  Install completion for the current shell.\n  --show-completion     Show completion for the current shell, to copy it or customize the installation.\n  --help                Show this message and exit.\n\nCommands:\n  create\n  delete\n\n💬 Test the commandspython main.py create\nCreating user: Hiro Hamada\n\npython main.py delete\nDeleting user: Hiro Hamada\n\nrestart ↻\n```\n\n## One command and one callback [¶](https://typer.tiangolo.com/tutorial/commands/one-or-multiple/\\#one-command-and-one-callback \"Permanent link\")\n\nIf you want to create a CLI app with one single command but you still want it to be a command/subcommand you can just add a callback:\n\n[Python 3.8+](#__tabbed_3_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\n\n@app.command()\ndef create():\n    print(\"Creating user: Hiro Hamada\")\n\n@app.callback()\ndef callback():\n    pass\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nAnd now your CLI program will have a single command.\n\nCheck it:\n\n```\n\nfast →💬 Check the helppython main.py --help\n💬 Notice the single command createUsage: main.py [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  --install-completion  Install completion for the current shell.\n  --show-completion     Show completion for the current shell, to copy it or customize the installation.\n  --help                Show this message and exit.\n\nCommands:\n  create\n\n💬 Try itpython main.py create\nCreating user: Hiro Hamada\n\nrestart ↻\n```\n\n## Using the callback to document [¶](https://typer.tiangolo.com/tutorial/commands/one-or-multiple/\\#using-the-callback-to-document \"Permanent link\")\n\nNow that you are using a callback just to have a single command, you might as well use it to add documentation for your app:\n\n[Python 3.8+](#__tabbed_4_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\n\n@app.command()\ndef create():\n    print(\"Creating user: Hiro Hamada\")\n\n@app.callback()\ndef callback():\n    \"\"\"\n    Creates a single user Hiro Hamada.\n\n    In the next version it will create 5 more users.\n    \"\"\"\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nAnd now the docstring from the callback will be used as the help text:\n\n```\n\nfast →python main.py --help\n💬 Notice the help text from the docstringUsage: main.py [OPTIONS] COMMAND [ARGS]...\n\n  Creates a single user Hiro Hamada.\n\n  In the next version it will create 5 more users.\n\nOptions:\n  --install-completion  Install completion for the current shell.\n  --show-completion     Show completion for the current shell, to copy it or customize the installation.\n  --help                Show this message and exit.\n\nCommands:\n  create\n\n💬 And it still works the same, the callback does nothingpython main.py create\nCreating user: Hiro Hamada\n\nrestart ↻\n```\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/commands/one-or-multiple/",
      "ogUrl": "https://typer.tiangolo.com/tutorial/commands/one-or-multiple/",
      "title": "One or Multiple Commands - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/commands/one-or-multiple/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/commands/one-or-multiple.png",
      "ogTitle": "One or Multiple Commands - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/commands/one-or-multiple.png",
      "og:title": "One or Multiple Commands - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/commands/one-or-multiple/",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/commands/one-or-multiple.png",
      "twitter:title": "One or Multiple Commands - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/commands/callback/#typer-callback)\n\n# Typer Callback [¶](https://typer.tiangolo.com/tutorial/commands/callback/\\#typer-callback \"Permanent link\")\n\nWhen you create an `app = typer.Typer()` it works as a group of commands.\n\nAnd you can create multiple commands with it.\n\nEach of those commands can have their own _CLI parameters_.\n\nBut as those _CLI parameters_ are handled by each of those commands, they don't allow us to create _CLI parameters_ for the main CLI application itself.\n\nBut we can use `@app.callback()` for that.\n\nIt's very similar to `@app.command()`, but it declares the _CLI parameters_ for the main CLI application (before the commands):\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\nstate = {\"verbose\": False}\n\n@app.command()\ndef create(username: str):\n    if state[\"verbose\"]:\n        print(\"About to create a user\")\n    print(f\"Creating user: {username}\")\n    if state[\"verbose\"]:\n        print(\"Just created a user\")\n\n@app.command()\ndef delete(username: str):\n    if state[\"verbose\"]:\n        print(\"About to delete a user\")\n    print(f\"Deleting user: {username}\")\n    if state[\"verbose\"]:\n        print(\"Just deleted a user\")\n\n@app.callback()\ndef main(verbose: bool = False):\n    \"\"\"\n    Manage users in the awesome CLI app.\n    \"\"\"\n    if verbose:\n        print(\"Will write verbose output\")\n        state[\"verbose\"] = True\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nHere we create a `callback` with a `--verbose` _CLI option_.\n\nTip\n\nAfter getting the `--verbose` flag, we modify a global `state`, and we use it in the other commands.\n\nThere are other ways to achieve the same, but this will suffice for this example.\n\nAnd as we added a docstring to the callback function, by default it will be extracted and used as the help text.\n\nCheck it:\n\n```\n\nfast →💬 Check the helppython main.py --help\n💬 Notice the main help text, extracted from the callback function: \"Manage users in the awesome CLI app.\"Usage: main.py [OPTIONS] COMMAND [ARGS]...\n\n  Manage users in the awesome CLI app.\n\nOptions:\n  --verbose / --no-verbose  [default: False]\n  --install-completion      Install completion for the current shell.\n  --show-completion         Show completion for the current shell, to copy it or customize the installation.\n  --help                    Show this message and exit.\n\nCommands:\n  create\n  delete\n\n💬 Check the new top level CLI option --verbose\n💬 Try it normallypython main.py create Camila\nCreating user: Camila\n\n💬 And now with --verbosepython main.py --verbose create Camila\nWill write verbose output\nAbout to create a user\nCreating user: Camila\nJust created a user\n\n💬 Notice that --verbose belongs to the callback, it has to go before create or delete ⛔️python main.py create --verbose Camila\nUsage: main.py create [OPTIONS] USERNAME\nTry \"main.py create --help\" for help.\n\nError: No such option: --verbose\n\nrestart ↻\n```\n\n## Adding a callback on creation [¶](https://typer.tiangolo.com/tutorial/commands/callback/\\#adding-a-callback-on-creation \"Permanent link\")\n\nIt's also possible to add a callback when creating the `typer.Typer()` app:\n\n[Python 3.8+](#__tabbed_2_1)\n\n```md-code__content\nimport typer\n\ndef callback():\n    print(\"Running a command\")\n\napp = typer.Typer(callback=callback)\n\n@app.command()\ndef create(name: str):\n    print(f\"Creating user: {name}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nThat achieves the same as with `@app.callback()`.\n\nCheck it:\n\n```\n\nfast →python main.py create Camila\nRunning a command\nCreating user: Camila\n\nrestart ↻\n```\n\n## Overriding a callback [¶](https://typer.tiangolo.com/tutorial/commands/callback/\\#overriding-a-callback \"Permanent link\")\n\nIf you added a callback when creating the `typer.Typer()` app, it's possible to override it with `@app.callback()`:\n\n[Python 3.8+](#__tabbed_3_1)\n\n```md-code__content\nimport typer\n\ndef callback():\n    print(\"Running a command\")\n\napp = typer.Typer(callback=callback)\n\n@app.callback()\ndef new_callback():\n    print(\"Override callback, running a command\")\n\n@app.command()\ndef create(name: str):\n    print(f\"Creating user: {name}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nNow `new_callback()` will be the one used.\n\nCheck it:\n\n```\n\nfast →python main.py create Camila\n💬 Notice that the message is the one from new_callback()Override callback, running a command\nCreating user: Camila\n\nrestart ↻\n```\n\n## Adding a callback only for documentation [¶](https://typer.tiangolo.com/tutorial/commands/callback/\\#adding-a-callback-only-for-documentation \"Permanent link\")\n\nYou can also add a callback just to add the documentation in the docstring.\n\nIt can be convenient especially if you have several lines of text, as the indentation will be automatically handled for you:\n\n[Python 3.8+](#__tabbed_4_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\n\n@app.callback()\ndef callback():\n    \"\"\"\n    Manage users CLI app.\n\n    Use it with the create command.\n\n    A new user with the given NAME will be created.\n    \"\"\"\n\n@app.command()\ndef create(name: str):\n    print(f\"Creating user: {name}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nNow the callback will be used mainly to extract the docstring for the help text.\n\nCheck it:\n\n```\n\nfast →python main.py --help\n💬 Notice all the help text extracted from the callback docstringUsage: main.py [OPTIONS] COMMAND [ARGS]...\n\n  Manage users CLI app.\n\n  Use it with the create command.\n\n  A new user with the given NAME will be created.\n\nOptions:\n  --install-completion  Install completion for the current shell.\n  --show-completion     Show completion for the current shell, to copy it or customize the installation.\n  --help                Show this message and exit.\n\nCommands:\n  create\n\n💬 And it just works as normallypython main.py create Camila\nCreating user: Camila\n\nrestart ↻\n```\n\n## Click Group [¶](https://typer.tiangolo.com/tutorial/commands/callback/\\#click-group \"Permanent link\")\n\nIf you come from Click, this **Typer** callback is the equivalent of the function in a [Click Group](https://click.palletsprojects.com/en/7.x/quickstart/#nesting-commands).\n\nFor example:\n\n```md-code__content\nimport click\n\n@click.group()\ndef cli():\n    pass\n\n```\n\nThe original function `cli` would be the equivalent of a Typer callback.\n\nTechnical Details\n\nWhen using Click, it converts that `cli` variable to a Click `Group` object. And then the original function no longer exists in that variable.\n\n**Typer** doesn't do that, the callback function is not modified, only registered in the `typer.Typer` app. This is intentional, it's part of **Typer**'s design, to allow having editor auto completion and type checks.\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/commands/callback/",
      "ogUrl": "https://typer.tiangolo.com/tutorial/commands/callback/",
      "title": "Typer Callback - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/commands/callback/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/commands/callback.png",
      "ogTitle": "Typer Callback - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/commands/callback.png",
      "og:title": "Typer Callback - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/commands/callback/",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/commands/callback.png",
      "twitter:title": "Typer Callback - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/commands/options/#command-cli-options)\n\n# Command CLI Options [¶](https://typer.tiangolo.com/tutorial/commands/options/\\#command-cli-options \"Permanent link\")\n\nCommands can also have their own _CLI options_.\n\nIn fact, each command can have different _CLI arguments_ and _CLI options_:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\napp = typer.Typer()\n\n@app.command()\ndef create(username: str):\n    print(f\"Creating user: {username}\")\n\n@app.command()\ndef delete(\n    username: str,\n    force: Annotated[\\\n        bool, typer.Option(prompt=\"Are you sure you want to delete the user?\")\\\n    ],\n):\n    if force:\n        print(f\"Deleting user: {username}\")\n    else:\n        print(\"Operation cancelled\")\n\n@app.command()\ndef delete_all(\n    force: Annotated[\\\n        bool, typer.Option(prompt=\"Are you sure you want to delete ALL users?\")\\\n    ],\n):\n    if force:\n        print(\"Deleting all users\")\n    else:\n        print(\"Operation cancelled\")\n\n@app.command()\ndef init():\n    print(\"Initializing user database\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_2_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\n\n@app.command()\ndef create(username: str):\n    print(f\"Creating user: {username}\")\n\n@app.command()\ndef delete(\n    username: str,\n    force: bool = typer.Option(..., prompt=\"Are you sure you want to delete the user?\"),\n):\n    if force:\n        print(f\"Deleting user: {username}\")\n    else:\n        print(\"Operation cancelled\")\n\n@app.command()\ndef delete_all(\n    force: bool = typer.Option(\n        ..., prompt=\"Are you sure you want to delete ALL users?\"\n    ),\n):\n    if force:\n        print(\"Deleting all users\")\n    else:\n        print(\"Operation cancelled\")\n\n@app.command()\ndef init():\n    print(\"Initializing user database\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nHere we have multiple commands, with different _CLI parameters_:\n\n- `create`:\n  - `username`: a _CLI argument_.\n- `delete`:\n  - `username`: a _CLI argument_.\n  - `--force`: a _CLI option_, if not provided, it's prompted.\n- `delete-all`:\n  - `--force`: a _CLI option_, if not provided, it's prompted.\n- `init`:\n  - Doesn't take any _CLI parameters_.\n\n```\n\nfast →💬 Check the helppython main.py --help\n\nUsage: main.py [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  --install-completion  Install completion for the current shell.\n  --show-completion     Show completion for the current shell, to copy it or customize the installation.\n  --help                Show this message and exit.\n\nCommands:\n  create\n  delete\n  delete-all\n  init\n\nrestart ↻\n```\n\nTip\n\nCheck the command `delete-all`, by default command names are generated from the function name, replacing `_` with `-`.\n\nTest it:\n\n```\n\nfast →💬 Check the command createpython main.py create Camila\nCreating user: Camila\n\n💬 Now test the command deletepython main.py delete Camila\ny\nDeleting user: Camila\n\npython main.py delete Wade\nn\nOperation cancelled\n\n💬 And finally, the command delete-all💬 Notice it doesn't have CLI arguments, only a CLI option\npython main.py delete-all\ny\nDeleting all users\n\npython main.py delete-all\nn\nOperation cancelled\n\n💬 And if you pass the --force CLI option, it doesn't need to confirm\npython main.py delete-all --force\nDeleting all users\n\n💬 And init that doesn't take any CLI parameterpython main.py init\nInitializing user database\n\nrestart ↻\n```\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/commands/options/",
      "ogUrl": "https://typer.tiangolo.com/tutorial/commands/options/",
      "title": "Command CLI Options - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/commands/options/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/commands/options.png",
      "ogTitle": "Command CLI Options - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/commands/options.png",
      "og:title": "Command CLI Options - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/commands/options/",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/commands/options.png",
      "twitter:title": "Command CLI Options - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/first-steps/#first-steps)\n\n# First Steps [¶](https://typer.tiangolo.com/tutorial/first-steps/\\#first-steps \"Permanent link\")\n\n## The simplest example [¶](https://typer.tiangolo.com/tutorial/first-steps/\\#the-simplest-example \"Permanent link\")\n\nThe simplest **Typer** file could look like this:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nimport typer\n\ndef main():\n    print(\"Hello World\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nCopy that to a file `main.py`.\n\nTest it:\n\n```\n\nfast →python main.py\nHello World\n\n💬 It just prints \"Hello World\".\n💬 Now check the --helppython main.py --help\n Usage: main.py [OPTIONS]\n\n╭─ Options ─────────────────────────────────────────╮\n│ --help                        Show this message   │\n│                               and exit.           │\n╰───────────────────────────────────────────────────╯\n\nrestart ↻\n```\n\n...but this program is still not very useful. Let's extend it.\n\n## What is a **CLI argument** [¶](https://typer.tiangolo.com/tutorial/first-steps/\\#what-is-a-cli-argument \"Permanent link\")\n\nHere we will use the word **CLI argument** to refer to **CLI parameters** passed in some specific order to the CLI application. By default, they are _required_.\n\nIf you go to your terminal and type:\n\n```\n\nfast →ls ./myproject\nfirst-steps.md  intro.md\n\nrestart ↻\n```\n\n`ls` will show the contents of the directory `./myproject`.\n\n- `ls` is the _program_ (or \"command\", \"CLI app\").\n- `./myproject` is a _CLI argument_, in this case it refers to the path of a directory.\n\nThey are a bit different from **CLI options** that you will see later below.\n\n## Add a CLI argument [¶](https://typer.tiangolo.com/tutorial/first-steps/\\#add-a-cli-argument \"Permanent link\")\n\nUpdate the previous example with an argument `name`:\n\n[Python 3.8+](#__tabbed_2_1)\n\n```md-code__content\nimport typer\n\ndef main(name: str):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n```\n\nfast →python main.py\n💬 If you run it without the argument, it shows a nice errorUsage: main.py [OPTIONS] NAME\nTry 'main.py --help' for help.\n╭─ Error ───────────────────────────────────────────╮\n│ Missing argument 'NAME'.                          │\n╰───────────────────────────────────────────────────╯\n\n💬 Now pass that NAME CLI argumentpython main.py Camila\nHello Camila\n\n💬 Here \"Camila\" is the CLI argument\n💬 To pass a name with spaces for the same CLI argument, use quotespython main.py \"Camila Gutiérrez\"\nHello Camila Gutiérrez\n\nrestart ↻\n```\n\nTip\n\nIf you need to pass a single value that contains spaces to a _CLI argument_, use quotes ( `\"`) around it.\n\n## Two CLI arguments [¶](https://typer.tiangolo.com/tutorial/first-steps/\\#two-cli-arguments \"Permanent link\")\n\nNow let's say we want to have the name and last name separated.\n\nSo, extend that to have 2 arguments, `name` and `lastname`:\n\n[Python 3.8+](#__tabbed_3_1)\n\n```md-code__content\nimport typer\n\ndef main(name: str, lastname: str):\n    print(f\"Hello {name} {lastname}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n```\n\nfast →💬 Check the main --helppython main.py --help\nUsage: main.py [OPTIONS] NAME\nTry 'main.py --help' for help.\n╭─ Error ───────────────────────────────────────────╮\n│ Missing argument 'NAME'.                          │\n╰───────────────────────────────────────────────────╯\n\ntyper on  richify [»!?] via 🐍 v3.7.5 (env3.7)\n❯ python main.py\nUsage: main.py [OPTIONS] NAME LASTNAME\nTry 'main.py --help' for help.\n╭─ Error ───────────────────────────────────────────╮\n│ Missing argument 'NAME'.                          │\n╰───────────────────────────────────────────────────╯\n\n💬 There are now 2 CLI arguments, name and lastname\n💬 Now pass a single name argumentpython main.py Camila\nUsage: main.py [OPTIONS] NAME LASTNAME\nTry 'main.py --help' for help.\n╭─ Error ───────────────────────────────────────────╮\n│ Missing argument 'LASTNAME'.                      │\n╰───────────────────────────────────────────────────╯\n\n💬 These 2 arguments are required, so, pass both:python main.py Camila Gutiérrez\nHello Camila Gutiérrez\n\nrestart ↻\n```\n\nTip\n\nNotice that the order is important. The last name has to go after the first name.\n\nIf you called it with:\n\n```md-code__content\n$ python main.py Gutiérrez Camila\n\n```\n\nyour app wouldn't have a way to know which is the `name` and which the `lastname`. It expects the first _CLI argument_ to be the `name` and the second _CLI argument_ to be the `lastname`.\n\n## What is a **CLI option** [¶](https://typer.tiangolo.com/tutorial/first-steps/\\#what-is-a-cli-option \"Permanent link\")\n\nHere we will use the word **CLI option** to refer to _CLI parameters_ passed to the CLI application with a specific name. For example, if you go to your terminal and type:\n\n```\n\nfast →ls ./myproject --size\n12 first-steps.md   4 intro.md\n\nrestart ↻\n```\n\n`ls` will show the contents of the directory `./myproject` with their `size`.\n\n- `ls` is the _program_ (or \"command\", \"CLI app\").\n- `./myproject` is a _CLI argument_.\n- `--size` is an optional _CLI option_.\n\nThe program knows it has to show the size because it sees `--size`, not because of the order.\n\nA _CLI option_ like `--size` doesn't depend on the order like a _CLI argument_.\n\nSo, if you put the `--size` _before_ the _CLI argument_, it still works (in fact, that's the most common way of doing it):\n\n```\n\nfast →ls --size ./myproject\n12 first-steps.md   4 intro.md\n\nrestart ↻\n```\n\nThe main visual difference between a _CLI option_ and a _CLI argument_ is that the _CLI option_ has `--` prepended to the name, like in \" `--size`\".\n\nA _CLI option_ doesn't depend on the order because it has a predefined name (here it's `--size`). This is because the CLI app is looking specifically for a literal `--size` parameter (also known as \"flag\" or \"switch\"), with that specific \"name\" (here the specific name is \" `--size`\"). The CLI app will check if you typed it or not, it will be actively looking for `--size` even if you didn't type it (to check if it's there or not).\n\nIn contrast, the CLI app is not actively looking for the _CLI argument_ with a text \" `./myproject`\", it has no way to know if you would type `./myproject` or `./my-super-awesome-project` or anything else. It's just waiting to get whatever you give it. The only way to know that you refer to a specific _CLI argument_ is because of the order. The same way that it knows that the first _CLI argument_ was the `name` and the second was the `lastname`, but if you mixed the order, it wouldn't be able to handle it.\n\nInstead, with a _CLI option_, the order doesn't matter.\n\nAlso, by default, a _CLI option_ is _optional_ (not _required_).\n\nSo, by default:\n\n- A _CLI argument_ is **required**\n- A _CLI option_ is **optional**\n\nBut the _required_ and _optional_ defaults can be changed.\n\nSo, the main and **most important** difference is that:\n\n- _CLI options_ **start with `--`** and don't depend on the order\n- _CLI arguments_ depend on the **sequence order**\n\nTip\n\nIn this example above the _CLI option_ `--size` is just a \"flag\" or \"switch\" that will contain a boolean value, `True` or `False`, depending on if it was added to the command or not.\n\nThis one doesn't receive any values. But _CLI options_ can also receive values like _CLI arguments_. You'll see how later.\n\n## Add one _CLI option_ [¶](https://typer.tiangolo.com/tutorial/first-steps/\\#add-one-cli-option \"Permanent link\")\n\nNow add a `--formal` _CLI option_:\n\n[Python 3.8+](#__tabbed_4_1)\n\n```md-code__content\nimport typer\n\ndef main(name: str, lastname: str, formal: bool = False):\n    if formal:\n        print(f\"Good day Ms. {name} {lastname}.\")\n    else:\n        print(f\"Hello {name} {lastname}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nHere `formal` is a `bool` that is `False` by default.\n\n```\n\nfast →💬 Get the helppython main.py --help\n Usage: main.py [OPTIONS] NAME LASTNAME\n\n╭─ Arguments ─────────────────────────────────────────────────────╮\n│ *    name          TEXT  [default: None] [required]             │\n│ *    lastname      TEXT  [default: None] [required]             │\n╰─────────────────────────────────────────────────────────────────╯\n╭─ Options ───────────────────────────────────────────────────────╮\n│ --formal                --no-formal      [default: no-formal]   │\n│ --help                                   Show this message and  │\n│                                          exit.                  │\n╰─────────────────────────────────────────────────────────────────╯\n\nrestart ↻\n```\n\nTip\n\nNotice that it automatically creates a `--formal` and a `--no-formal` because it detected that `formal` is a `bool`.\n\nNow call it normally:\n\n```\n\nfast →python main.py Camila Gutiérrez\nHello Camila Gutiérrez\n\n💬 But if you pass --formalpython main.py Camila Gutiérrez --formal\nGood day Ms. Camila Gutiérrez.\n\n💬 And as --formal is a CLI option you can put it anywhere in this commandpython main.py Camila --formal Gutiérrez\nGood day Ms. Camila Gutiérrez.\n\npython main.py --formal Camila Gutiérrez\nGood day Ms. Camila Gutiérrez.\n\nrestart ↻\n```\n\n## A _CLI option_ with a value [¶](https://typer.tiangolo.com/tutorial/first-steps/\\#a-cli-option-with-a-value \"Permanent link\")\n\nTo convert the `lastname` from a _CLI argument_ to a _CLI option_, give it a default value of `\"\"`:\n\n[Python 3.8+](#__tabbed_5_1)\n\n```md-code__content\nimport typer\n\ndef main(name: str, lastname: str = \"\", formal: bool = False):\n    if formal:\n        print(f\"Good day Ms. {name} {lastname}.\")\n    else:\n        print(f\"Hello {name} {lastname}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nAs `lastname` now has a default value of `\"\"` (an empty string) it is no longer required in the function, and **Typer** will now by default make it an optional _CLI option_.\n\n```\n\nfast →python main.py --help\n Usage: main.py [OPTIONS] NAME\n\n╭─ Arguments ───────────────────────────────────────────────────────╮\n│ *    name      TEXT  [default: None] [required]                   │\n╰───────────────────────────────────────────────────────────────────╯\n╭─ Options ─────────────────────────────────────────────────────────╮\n│ --lastname                             TEXT                       │\n│ --formal                --no-formal          [default: no-formal] │\n│ --help                                       Show this message    │\n│                                              and exit.            │\n╰───────────────────────────────────────────────────────────────────╯\n\nrestart ↻\n```\n\nTip\n\nNotice the `--lastname`, and notice that it takes a textual value.\n\nA _CLI option_ with a value like `--lastname` (contrary to a _CLI option_ without a value, a `bool` flag, like `--formal` or `--size`) takes as its value whatever is at the _right side_ of the _CLI option_.\n\n```\n\nfast →💬 Call it without a --lastnamepython main.py Camila\nHello Camila\n\n💬 Pass the --lastnamepython main.py Camila --lastname Gutiérrez\nHello Camila Gutiérrez\n\nrestart ↻\n```\n\nTip\n\nNotice that \" `Gutiérrez`\" is at the right side of `--lastname`. A _CLI option_ with a value takes as its value whatever is at the _right side_.\n\nAnd as `--lastname` is now a _CLI option_ that doesn't depend on the order, you can pass it before the name:\n\n```\n\nfast →python main.py --lastname Gutiérrez Camila\n💬 and it will still work normallyHello Camila Gutiérrez\n\nrestart ↻\n```\n\n## Document your CLI app [¶](https://typer.tiangolo.com/tutorial/first-steps/\\#document-your-cli-app \"Permanent link\")\n\nIf you add a docstring to your function it will be used in the help text:\n\n[Python 3.8+](#__tabbed_6_1)\n\n```md-code__content\nimport typer\n\ndef main(name: str, lastname: str = \"\", formal: bool = False):\n    \"\"\"\n    Say hi to NAME, optionally with a --lastname.\n\n    If --formal is used, say hi very formally.\n    \"\"\"\n    if formal:\n        print(f\"Good day Ms. {name} {lastname}.\")\n    else:\n        print(f\"Hello {name} {lastname}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nNow see it with the `--help` option:\n\n```\n\nfast →python main.py --help\n Usage: main.py [OPTIONS] NAME\n\n Say hi to NAME, optionally with a --lastname.\n If --formal is used, say hi very formally.\n\n╭─ Arguments ───────────────────────────────────────────────────────╮\n│ *    name      TEXT  [default: None] [required]                   │\n╰───────────────────────────────────────────────────────────────────╯\n╭─ Options ─────────────────────────────────────────────────────────╮\n│ --lastname                             TEXT                       │\n│ --formal                --no-formal          [default: no-formal] │\n│ --help                                       Show this message    │\n│                                              and exit.            │\n╰───────────────────────────────────────────────────────────────────╯\n\nrestart ↻\n```\n\nTip\n\nThere is another place to document the specific _CLI options_ and _CLI arguments_ that will show up next to them in the help text as with `--install-completion` or `--help`, you will learn that later in the tutorial.\n\n## Arguments, options, parameters, optional, required [¶](https://typer.tiangolo.com/tutorial/first-steps/\\#arguments-options-parameters-optional-required \"Permanent link\")\n\nBe aware that these terms refer to multiple things depending on the context, and sadly, those \"contexts\" mix frequently, so it's easy to get confused.\n\n### In Python [¶](https://typer.tiangolo.com/tutorial/first-steps/\\#in-python \"Permanent link\")\n\nIn Python, the names of the variables in a function, like `name` and `lastname`:\n\n```md-code__content\ndef main(name: str, lastname: str = \"\"):\n    pass\n\n```\n\nare called \"Python function parameters\" or \"Python function arguments\".\n\nTechnical Details\n\nThere's actually a very small distinction in Python between \"parameter\" and \"argument\".\n\nIt's quite technical... and somewhat pedantic.\n\n_Parameter_ refers to the variable name in a function _declaration_. Like:\n\n```md-code__content\ndef bring_person(name: str, lastname: str = \"\"):\n    pass\n\n```\n\n_Argument_ refers to the value passed when _calling_ a function. Like:\n\n```md-code__content\nperson = bring_person(\"Camila\", lastname=\"Gutiérrez\")\n\n```\n\n...but you will probably see them used interchangeably in most of the places (including here).\n\n#### Python default values [¶](https://typer.tiangolo.com/tutorial/first-steps/\\#python-default-values \"Permanent link\")\n\nIn Python, in a function, a parameter with a _default value_ like `lastname` in:\n\n```md-code__content\ndef main(name: str, lastname: str = \"\"):\n    pass\n\n```\n\nis considered an \"optional parameter\" (or \"optional argument\").\n\nThe default value can be anything, like `\"\"` or `None`.\n\nAnd a parameter like `name`, that doesn't have a default value, is considered _required_.\n\n### In CLIs [¶](https://typer.tiangolo.com/tutorial/first-steps/\\#in-clis \"Permanent link\")\n\nWhen talking about command line interface applications, the words **\"argument\"** and **\"parameter\"** are commonly used to refer to that data passed to a CLI app, those parameters.\n\nBut those words **don't imply** anything about the data being required, needing to be passed in a certain order, nor having a flag like `--lastname`.\n\nThe parameters that come with a name like `--lastname` (and optionally a value) are commonly optional, not required. So, when talking about CLIs it's common to call them **optional arguments** or **optional parameters**. Sometimes these _optional parameters_ that start with `--` are also called a **flag** or a **switch**.\n\nIn reality, the parameters that require an order can be made _optional_ too. And the ones that come with a flag (like `--lastname`) can be _required_ too.\n\n### In **Typer** [¶](https://typer.tiangolo.com/tutorial/first-steps/\\#in-typer \"Permanent link\")\n\nTo try and make it a bit easier, we'll normally use the words \"parameter\" or \"argument\" to refer to \"Python functions parameters\" or \"Python functions arguments\".\n\nWe'll use **_CLI argument_** to refer to those _CLI parameters_ that depend on the specific order. That are **required** by default.\n\nAnd we'll use **_CLI option_** to refer to those _CLI parameters_ that depend on a name that starts with `--` (like `--lastname`). That are **optional** by default.\n\nWe will use **_CLI parameter_** to refer to both, _CLI arguments_ and _CLI options_.\n\n## The `typer` Command [¶](https://typer.tiangolo.com/tutorial/first-steps/\\#the-typer-command \"Permanent link\")\n\nWhen you install `typer`, by default it adds a `typer` command to your shell.\n\nThis `typer` command allows you to run your scripts with ✨ auto completion ✨ in your terminal.\n\nAs an alternative to running with Python:\n\n```\n\nfast →python main.py\nHello World\n\nrestart ↻\n```\n\nYou can run with the `typer` command:\n\n```\n\nfast →typer main.py run\nHello World\n\nrestart ↻\n```\n\n...and it will give you auto completion in your terminal when you hit `TAB` for all your code.\n\nSo you can use it to have auto completion for your own scripts as you continue with the tutorial.\n\nTip\n\nYour CLI application built with **Typer** won't need the `typer` command to have auto completion once you create a Python package.\n\nBut for short scripts and for learning, before creating a Python package, it might be useful.\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/first-steps/",
      "ogUrl": "https://typer.tiangolo.com/tutorial/first-steps/",
      "title": "First Steps - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/first-steps/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/first-steps.png",
      "ogTitle": "First Steps - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/first-steps.png",
      "og:title": "First Steps - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/first-steps/",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/first-steps.png",
      "twitter:title": "First Steps - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/multiple-values/#multiple-values)\n\n# Multiple Values [¶](https://typer.tiangolo.com/tutorial/multiple-values/\\#multiple-values \"Permanent link\")\n\nThere are several ways to declare multiple values for _CLI options_ and _CLI arguments_.\n\nWe'll see them in the next short sections.\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/multiple-values/",
      "ogUrl": "https://typer.tiangolo.com/tutorial/multiple-values/",
      "title": "Multiple Values - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/multiple-values/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/multiple-values/index.png",
      "ogTitle": "Multiple Values - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/multiple-values/index.png",
      "og:title": "Multiple Values - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/multiple-values/",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/multiple-values/index.png",
      "twitter:title": "Multiple Values - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/parameter-types/datetime/#datetime)\n\n# DateTime [¶](https://typer.tiangolo.com/tutorial/parameter-types/datetime/\\#datetime \"Permanent link\")\n\nYou can specify a _CLI parameter_ as a Python [`datetime`](https://docs.python.org/3/library/datetime.html).\n\nYour function will receive a standard Python `datetime` object, and again, your editor will give you completion, etc.\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nfrom datetime import datetime\n\nimport typer\n\ndef main(birth: datetime):\n    print(f\"Interesting day to be born: {birth}\")\n    print(f\"Birth hour: {birth.hour}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nTyper will accept any string from the following formats:\n\n- `%Y-%m-%d`\n- `%Y-%m-%dT%H:%M:%S`\n- `%Y-%m-%d %H:%M:%S`\n\nCheck it:\n\n```\n\nfast →python main.py --help\nUsage: main.py [OPTIONS] BIRTH:[%Y-%m-%d|%Y-%m-%dT%H:%M:%S|%Y-%m-%d %H:%M:%S]\n\nArguments:\n  BIRTH:[%Y-%m-%d|%Y-%m-%dT%H:%M:%S|%Y-%m-%d %H:%M:%S][required]\n\nOptions:\n  --help                Show this message and exit.\n\n💬 Pass a datetimepython main.py 1956-01-31T10:00:00\nInteresting day to be born: 1956-01-31 10:00:00\nBirth hour: 10\n\n💬 An invalid datepython main.py july-19-1989\nUsage: main.py [OPTIONS] [%Y-%m-%d|%Y-%m-%dT%H:%M:%S|%Y-%m-%d%H:%M:%S]\n\nError: Invalid value for 'BIRTH:[%Y-%m-%d|%Y-%m-%dT%H:%M:%S|%Y-%m-%d %H:%M:%S]': 'july-19-1989' does not match the formats '%Y-%m-%d', '%Y-%m-%dT%H:%M:%S', '%Y-%m-%d %H:%M:%S'.\n\nrestart ↻\n```\n\n## Custom date format [¶](https://typer.tiangolo.com/tutorial/parameter-types/datetime/\\#custom-date-format \"Permanent link\")\n\nYou can also customize the formats received for the `datetime` with the `formats` parameter.\n\n`formats` receives a list of strings with the date formats that would be passed to [datetime.strptime()](https://docs.python.org/3/library/datetime.html#datetime.datetime.strptime).\n\nFor example, let's imagine that you want to accept an ISO formatted datetime, but for some strange reason, you also want to accept a format with:\n\n- first the month\n- then the day\n- then the year\n- separated with \" `/`\"\n\n...It's a crazy example, but let's say you also needed that strange format:\n\n[Python 3.8+](#__tabbed_2_1)\n\n```md-code__content\nfrom datetime import datetime\n\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(\n    launch_date: Annotated[\\\n        datetime,\\\n        typer.Argument(\\\n            formats=[\"%Y-%m-%d\", \"%Y-%m-%dT%H:%M:%S\", \"%Y-%m-%d %H:%M:%S\", \"%m/%d/%Y\"]\\\n        ),\\\n    ],\n):\n    print(f\"Launch will be at: {launch_date}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_3_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nfrom datetime import datetime\n\nimport typer\n\ndef main(\n    launch_date: datetime = typer.Argument(\n        ..., formats=[\"%Y-%m-%d\", \"%Y-%m-%dT%H:%M:%S\", \"%Y-%m-%d %H:%M:%S\", \"%m/%d/%Y\"]\n    ),\n):\n    print(f\"Launch will be at: {launch_date}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nTip\n\nNotice the last string in `formats`: `\"%m/%d/%Y\"`.\n\nCheck it:\n\n```\n\nfast →💬 ISO dates workpython main.py 1969-10-29\nLaunch will be at: 1969-10-29 00:00:00\n\n💬 But the strange custom format also workspython main.py 10/29/1969\nLaunch will be at: 1969-10-29 00:00:00\n\nrestart ↻\n```\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/parameter-types/datetime/",
      "ogUrl": "https://typer.tiangolo.com/tutorial/parameter-types/datetime/",
      "title": "DateTime - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/parameter-types/datetime/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/parameter-types/datetime.png",
      "ogTitle": "DateTime - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/parameter-types/datetime.png",
      "og:title": "DateTime - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/parameter-types/datetime/",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/parameter-types/datetime.png",
      "twitter:title": "DateTime - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/testing/#testing)\n\n# Testing [¶](https://typer.tiangolo.com/tutorial/testing/\\#testing \"Permanent link\")\n\nTesting **Typer** applications is very easy with [pytest](https://docs.pytest.org/en/latest/).\n\nLet's say you have an application `app/main.py` with:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nfrom typing import Optional\n\nimport typer\n\napp = typer.Typer()\n\n@app.command()\ndef main(name: str, city: Optional[str] = None):\n    print(f\"Hello {name}\")\n    if city:\n        print(f\"Let's have a coffee in {city}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nSo, you would use it like:\n\n```\n\nfast →python main.py Camila --city Berlin\nHello Camila\nLet's have a coffee in Berlin\n\nrestart ↻\n```\n\nAnd the directory also has an empty `app/__init__.py` file.\n\nSo, the `app` is a \"Python package\".\n\n## Test the app [¶](https://typer.tiangolo.com/tutorial/testing/\\#test-the-app \"Permanent link\")\n\n### Import and create a `CliRunner` [¶](https://typer.tiangolo.com/tutorial/testing/\\#import-and-create-a-clirunner \"Permanent link\")\n\nCreate another file/module `app/test_main.py`.\n\nImport `CliRunner` and create a `runner` object.\n\nThis runner is what will \"invoke\" or \"call\" your command line application.\n\n[Python 3.8+](#__tabbed_2_1)\n\n```md-code__content\nfrom typer.testing import CliRunner\n\nfrom .main import app\n\nrunner = CliRunner()\n\ndef test_app():\n    result = runner.invoke(app, [\"Camila\", \"--city\", \"Berlin\"])\n    assert result.exit_code == 0\n    assert \"Hello Camila\" in result.stdout\n    assert \"Let's have a coffee in Berlin\" in result.stdout\n\n```\n\nTip\n\nIt's important that the name of the file starts with `test_`, that way pytest will be able to detect it and use it automatically.\n\n### Call the app [¶](https://typer.tiangolo.com/tutorial/testing/\\#call-the-app \"Permanent link\")\n\nThen create a function `test_app()`.\n\nAnd inside of the function, use the `runner` to `invoke` the application.\n\nThe first parameter to `runner.invoke()` is a `Typer` app.\n\nThe second parameter is a `list` of `str`, with all the text you would pass in the command line, right as you would pass it:\n\n[Python 3.8+](#__tabbed_3_1)\n\n```md-code__content\nfrom typer.testing import CliRunner\n\nfrom .main import app\n\nrunner = CliRunner()\n\ndef test_app():\n    result = runner.invoke(app, [\"Camila\", \"--city\", \"Berlin\"])\n    assert result.exit_code == 0\n    assert \"Hello Camila\" in result.stdout\n    assert \"Let's have a coffee in Berlin\" in result.stdout\n\n```\n\nTip\n\nThe name of the function has to start with `test_`, that way pytest can detect it and use it automatically.\n\n### Check the result [¶](https://typer.tiangolo.com/tutorial/testing/\\#check-the-result \"Permanent link\")\n\nThen, inside of the test function, add `assert` statements to ensure that everything in the result of the call is as it should be.\n\n[Python 3.8+](#__tabbed_4_1)\n\n```md-code__content\nfrom typer.testing import CliRunner\n\nfrom .main import app\n\nrunner = CliRunner()\n\ndef test_app():\n    result = runner.invoke(app, [\"Camila\", \"--city\", \"Berlin\"])\n    assert result.exit_code == 0\n    assert \"Hello Camila\" in result.stdout\n    assert \"Let's have a coffee in Berlin\" in result.stdout\n\n```\n\nHere we are checking that the exit code is 0, as it is for programs that exit without errors.\n\nThen we check that the text printed to \"standard output\" contains the text that our CLI program prints.\n\nTip\n\nYou could also check `result.stderr` for \"standard error\" independently from \"standard output\" if your `CliRunner` instance is created with the `mix_stderr=False` argument.\n\nInfo\n\nIf you need a refresher about what is \"standard output\" and \"standard error\" check the section in [Printing and Colors: \"Standard Output\" and \"Standard Error\"](https://typer.tiangolo.com/tutorial/printing/#standard-output-and-standard-error).\n\n### Call `pytest` [¶](https://typer.tiangolo.com/tutorial/testing/\\#call-pytest \"Permanent link\")\n\nThen you can call `pytest` in your directory and it will run your tests:\n\n```\n\nfast →pytest\n================ test session starts ================\nplatform linux -- Python 3.10, pytest-5.3.5, py-1.8.1, pluggy-0.13.1\nrootdir: /home/user/code/superawesome-cli/app\nplugins: forked-1.1.3, xdist-1.31.0, cov-2.8.1\ncollected 1 item\n\ntest_main.py .                                 [100%]\n\n================= 1 passed in 0.03s =================\n\nrestart ↻\n```\n\n## Testing input [¶](https://typer.tiangolo.com/tutorial/testing/\\#testing-input \"Permanent link\")\n\nIf you have a CLI with prompts, like:\n\n[Python 3.8+](#__tabbed_5_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\napp = typer.Typer()\n\n@app.command()\ndef main(name: str, email: Annotated[str, typer.Option(prompt=True)]):\n    print(f\"Hello {name}, your email is: {email}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nThat you would use like:\n\n```\n\nfast →python main.py Camila\ncamila@example.com\nHello Camila, your email is: camila@example.com\n\nrestart ↻\n```\n\nYou can test the input typed in the terminal using `input=\"camila@example.com\\n\"`.\n\nThis is because what you type in the terminal goes to \" **standard input**\" and is handled by the operating system as if it was a \"virtual file\".\n\nInfo\n\nIf you need a refresher about what is \"standard output\", \"standard error\", and \"standard input\" check the section in [Printing and Colors: \"Standard Output\" and \"Standard Error\"](https://typer.tiangolo.com/tutorial/printing/#standard-output-and-standard-error).\n\nWhen you hit the `ENTER` key after typing the email, that is just a \"new line character\". And in Python that is represented with `\"\\n\"`.\n\nSo, if you use `input=\"camila@example.com\\n\"` it means: \"type `camila@example.com` in the terminal, then hit the `ENTER` key\":\n\n[Python 3.8+](#__tabbed_6_1)\n\n```md-code__content\nfrom typer.testing import CliRunner\n\nfrom .main import app\n\nrunner = CliRunner()\n\ndef test_app():\n    result = runner.invoke(app, [\"Camila\"], input=\"camila@example.com\\n\")\n    assert result.exit_code == 0\n    assert \"Hello Camila, your email is: camila@example.com\" in result.stdout\n\n```\n\n## Test a function [¶](https://typer.tiangolo.com/tutorial/testing/\\#test-a-function \"Permanent link\")\n\nIf you have a script and you never created an explicit `typer.Typer` app, like:\n\n[Python 3.8+](#__tabbed_7_1)\n\n```md-code__content\nimport typer\n\ndef main(name: str = \"World\"):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n...you can still test it, by creating an app during testing:\n\n[Python 3.8+](#__tabbed_8_1)\n\n```md-code__content\nimport typer\nfrom typer.testing import CliRunner\n\nfrom .main import main\n\napp = typer.Typer()\napp.command()(main)\n\nrunner = CliRunner()\n\ndef test_app():\n    result = runner.invoke(app, [\"--name\", \"Camila\"])\n    assert result.exit_code == 0\n    assert \"Hello Camila\" in result.stdout\n\n```\n\nOf course, if you are testing that script, it's probably easier/cleaner to just create the explicit `typer.Typer` app in `main.py` instead of creating it just during the test.\n\nBut if you want to keep it that way, e.g. because it's a simple example in documentation, then you can use that trick.\n\n### About the `app.command` decorator [¶](https://typer.tiangolo.com/tutorial/testing/\\#about-the-appcommand-decorator \"Permanent link\")\n\nNotice the `app.command()(main)`.\n\nIf it's not obvious what it's doing, continue reading...\n\nYou would normally write something like:\n\n```md-code__content\n@app.command()\ndef main(name: str = \"World\"):\n    # Some code here\n\n```\n\nBut `@app.command()` is just a decorator.\n\nThat's equivalent to:\n\n```md-code__content\ndef main(name: str = \"World\"):\n    # Some code here\n\ndecorator = app.command()\n\nnew_main = decorator(main)\nmain = new_main\n\n```\n\n`app.command()` returns a function ( `decorator`) that takes another function as it's only parameter ( `main`).\n\nAnd by using the `@something` you normally tell Python to replace the thing below (the function `main`) with the return of the `decorator` function ( `new_main`).\n\nNow, in the specific case of **Typer**, the decorator doesn't change the original function. It registers it internally and returns it unmodified.\n\nSo, `new_main` is actually the same original `main`.\n\nSo, in the case of **Typer**, as it doesn't really modify the decorated function, that would be equivalent to:\n\n```md-code__content\ndef main(name: str = \"World\"):\n    # Some code here\n\ndecorator = app.command()\n\ndecorator(main)\n\n```\n\nBut then we don't need to create the variable `decorator` to use it below, we can just use it directly:\n\n```md-code__content\ndef main(name: str = \"World\"):\n    # Some code here\n\napp.command()(main)\n\n```\n\n...that's it. It's still probably simpler to just create the explicit `typer.Typer` in the `main.py` file 😅.\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/testing/",
      "ogUrl": "https://typer.tiangolo.com/tutorial/testing/",
      "title": "Testing - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/testing/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/testing.png",
      "ogTitle": "Testing - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/testing.png",
      "og:title": "Testing - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/testing/",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/testing.png",
      "twitter:title": "Testing - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/prompt/#ask-with-prompt)\n\n# Ask with Prompt [¶](https://typer.tiangolo.com/tutorial/prompt/\\#ask-with-prompt \"Permanent link\")\n\nWhen you need to ask the user for info interactively you should normally use [\\*CLI Option\\*s with Prompt](https://typer.tiangolo.com/tutorial/options/prompt/), because they allow using the CLI program in a non-interactive way (for example, a Bash script could use it).\n\nBut if you absolutely need to ask for interactive information without using a _CLI option_, you can use `typer.prompt()`:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nimport typer\n\ndef main():\n    person_name = typer.prompt(\"What's your name?\")\n    print(f\"Hello {person_name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nCheck it:\n\n```\n\nfast →python main.py\nCamila\nHello Camila\n\nrestart ↻\n```\n\n## Confirm [¶](https://typer.tiangolo.com/tutorial/prompt/\\#confirm \"Permanent link\")\n\nThere's also an alternative to ask for confirmation. Again, if possible, you should use a [_CLI Option_ with a confirmation prompt](https://typer.tiangolo.com/tutorial/options/prompt/):\n\n[Python 3.8+](#__tabbed_2_1)\n\n```md-code__content\nimport typer\n\ndef main():\n    delete = typer.confirm(\"Are you sure you want to delete it?\")\n    if not delete:\n        print(\"Not deleting\")\n        raise typer.Abort()\n    print(\"Deleting it!\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nCheck it:\n\n```\n\nfast →python main.py\ny\nDeleting it!\n\n💬 This time cancel itpython main.py\nn\nNot deleting\nAborted!\n\nrestart ↻\n```\n\n## Confirm or abort [¶](https://typer.tiangolo.com/tutorial/prompt/\\#confirm-or-abort \"Permanent link\")\n\nAs it's very common to abort if the user doesn't confirm, there's an integrated parameter `abort` that does it automatically:\n\n[Python 3.8+](#__tabbed_3_1)\n\n```md-code__content\nimport typer\n\ndef main():\n    delete = typer.confirm(\"Are you sure you want to delete it?\", abort=True)\n    print(\"Deleting it!\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n```\n\nfast →python main.py\ny\nDeleting it!\n\n💬 This time cancel itpython main.py\nn\nAborted!\n\nrestart ↻\n```\n\n## Prompt with Rich [¶](https://typer.tiangolo.com/tutorial/prompt/\\#prompt-with-rich \"Permanent link\")\n\nIf you installed Rich as described in [Printing and Colors](https://typer.tiangolo.com/tutorial/printing/), you can use Rich to prompt the user for input:\n\n[Python 3.8+](#__tabbed_4_1)\n\n```md-code__content\nimport typer\nfrom rich.prompt import Prompt\n\ndef main():\n    name = Prompt.ask(\"Enter your name :sunglasses:\")\n    print(f\"Hey there {name}!\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nAnd when you run it, it will look like:\n\n```\n\nfast →python main.py\nMorty\nHello Morty\n\nrestart ↻\n```\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/prompt/",
      "ogUrl": "https://typer.tiangolo.com/tutorial/prompt/",
      "title": "Ask with Prompt - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/prompt/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/prompt.png",
      "ogTitle": "Ask with Prompt - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/prompt.png",
      "og:title": "Ask with Prompt - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/prompt/",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/prompt.png",
      "twitter:title": "Ask with Prompt - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/install/#install-typer)\n\n# Install **Typer** [¶](https://typer.tiangolo.com/tutorial/install/\\#install-typer \"Permanent link\")\n\nThe first step is to install **Typer**.\n\nFirst, make sure you create your [virtual environment](https://typer.tiangolo.com/virtual-environments/), activate it, and then install it, for example with:\n\n```\n\nfast →pip install typerSuccessfully installed typer click shellingham rich\n\nrestart ↻\n```\n\nBy default, `typer` comes with `rich` and `shellingham`.\n\nNote\n\nIf you are an advanced user and want to opt out of these default extra dependencies, you can instead install `typer-slim`.\n\n```md-code__content\npip install typer\n\n```\n\n...includes the same optional dependencies as:\n\n```md-code__content\npip install \"typer-slim[standard]\"\n\n```\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/install/",
      "ogUrl": "https://typer.tiangolo.com/tutorial/install/",
      "title": "Install Typer - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/install/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/install.png",
      "ogTitle": "Install Typer - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/install.png",
      "og:title": "Install Typer - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/install/",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/install.png",
      "twitter:title": "Install Typer - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/arguments/optional/#optional-cli-arguments)\n\n# Optional CLI Arguments [¶](https://typer.tiangolo.com/tutorial/arguments/optional/\\#optional-cli-arguments \"Permanent link\")\n\nWe said before that _by default_:\n\n- _CLI options_ are **optional**\n- _CLI arguments_ are **required**\n\nAgain, that's how they work _by default_, and that's the convention in many CLI programs and systems.\n\nBut you can change that.\n\nIn fact, it's very common to have **optional** _CLI arguments_, it's way more common than having **required** _CLI options_.\n\nAs an example of how it could be useful, let's see how the `ls` CLI program works.\n\n```\n\nfast →💬 If you just typels\n💬 ls will \"list\" the files and directories in the current directorytyper  tests  README.md  LICENSE\n\n💬 But it also receives an optional CLI argumentls ./tests/\n💬 And then ls will list the files and directories inside of that directory from the CLI argument__init__.py  test_tutorial\n\nrestart ↻\n```\n\n## An alternative _CLI argument_ declaration [¶](https://typer.tiangolo.com/tutorial/arguments/optional/\\#an-alternative-cli-argument-declaration \"Permanent link\")\n\nIn the [First Steps](https://typer.tiangolo.com/tutorial/first-steps/#add-a-cli-argument) you saw how to add a _CLI argument_:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nimport typer\n\ndef main(name: str):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nNow let's see an alternative way to create the same _CLI argument_:\n\n[Python 3.8+](#__tabbed_2_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(name: Annotated[str, typer.Argument()]):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_3_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(name: str = typer.Argument()):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nInfo\n\nTyper added support for `Annotated` (and started recommending it) in version 0.9.0.\n\nIf you have an older version, you would get errors when trying to use `Annotated`.\n\nMake sure you upgrade the Typer version to at least 0.9.0 before using `Annotated`.\n\nBefore, you had this function parameter:\n\n```md-code__content\nname: str\n\n```\n\nAnd now we wrap it with `Annotated`:\n\n```md-code__content\nname: Annotated[str]\n\n```\n\nBoth of these versions mean the same thing, `Annotated` is part of standard Python and is there for this.\n\nBut the second version using `Annotated` allows us to pass additional metadata that can be used by **Typer**:\n\n```md-code__content\nname: Annotated[str, typer.Argument()]\n\n```\n\nNow we are being explicit that `name` is a _CLI argument_. It's still a `str` and it's still required (it doesn't have a default value).\n\nAll we did there achieves the same thing as before, a **required** _CLI argument_:\n\n```\n\nfast →python main.py\nUsage: main.py [OPTIONS] NAME\nTry \"main.py --help\" for help.\n\nError: Missing argument 'NAME'.\n\nrestart ↻\n```\n\nIt's still not very useful, but it works correctly.\n\nAnd being able to declare a **required** _CLI argument_ using\n\n```md-code__content\nname: Annotated[str, typer.Argument()]\n\n```\n\n...that works exactly the same as\n\n```md-code__content\nname: str\n\n```\n\n...will come handy later.\n\n## Make an optional _CLI argument_ [¶](https://typer.tiangolo.com/tutorial/arguments/optional/\\#make-an-optional-cli-argument \"Permanent link\")\n\nNow, finally what we came for, an optional _CLI argument_.\n\nTo make a _CLI argument_ optional, use `typer.Argument()` and pass a different \"default\" as the first parameter to `typer.Argument()`, for example `None`:\n\n[Python 3.8+](#__tabbed_4_1)\n\n```md-code__content\nfrom typing import Optional\n\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(name: Annotated[Optional[str], typer.Argument()] = None):\n    if name is None:\n        print(\"Hello World!\")\n    else:\n        print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_5_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nfrom typing import Optional\n\nimport typer\n\ndef main(name: Optional[str] = typer.Argument(default=None)):\n    if name is None:\n        print(\"Hello World!\")\n    else:\n        print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nNow we have:\n\n```md-code__content\nname: Annotated[Optional[str], typer.Argument()] = None\n\n```\n\nBecause we are using `typer.Argument()` **Typer** will know that this is a _CLI argument_ (no matter if _required_ or _optional_).\n\nTip\n\nBy using `Optional` your editor will be able to know that the value _could_ be `None`, and will be able to warn you if you do something assuming it is a `str` that would break if it was `None`.\n\nCheck the help:\n\n```\n\nfast →💬 First check the helppython main.py --help\nUsage: main.py [OPTIONS] [NAME]\n\nArguments:\n  [NAME]\n\nOptions:\n  --help                Show this message and exit.\n\nrestart ↻\n```\n\nTip\n\nNotice that `NAME` is still a _CLI argument_, it's shown up there in the \" `Usage: main.py` ...\".\n\nAlso notice that now `[NAME]` has brackets (\" `[`\" and \" `]`\") around (before it was just `NAME`) to denote that it's **optional**, not **required**.\n\nNow run it and test it:\n\n```\n\nfast →💬 With no CLI argumentpython main.py\nHello World!\n\n💬 With one optional CLI argumentpython main.py Camila\nHello Camila\n\nrestart ↻\n```\n\nTip\n\nNotice that \" `Camila`\" here is an optional _CLI argument_, not a _CLI option_, because we didn't use something like \" `--name Camila`\", we just passed \" `Camila`\" directly to the program.\n\n## Alternative (old) `typer.Argument()` as the default value [¶](https://typer.tiangolo.com/tutorial/arguments/optional/\\#alternative-old-typerargument-as-the-default-value \"Permanent link\")\n\n**Typer** also supports another older alternative syntax for declaring _CLI arguments_ with additional metadata.\n\nInstead of using `Annotated`, you can use `typer.Argument()` as the default value:\n\n[Python 3.8+ - non-Annotated](#__tabbed_6_1)\n\n```md-code__content\nimport typer\n\ndef main(name: str = typer.Argument()):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+](#__tabbed_7_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(name: Annotated[str, typer.Argument()]):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\nBefore, because `name` didn't have any default value it would be a **required parameter** for the Python function, in Python terms.\n\nWhen using `typer.Argument()` as the default value **Typer** does the same and makes it a **required** _CLI argument_.\n\nWe changed it to:\n\n```md-code__content\nname: str = typer.Argument()\n\n```\n\nBut now as `typer.Argument()` is the \"default value\" of the function's parameter, it would mean that \"it is no longer required\" (in Python terms).\n\nAs we no longer have the Python function default value (or its absence) to tell if something is required or not and what is the default value, `typer.Argument()` receives a first parameter `default` that serves the same purpose of defining that default value, or making it required.\n\nNot passing any value to the `default` argument is the same as marking it as required. But you can also explicitly mark it as _required_ by passing `...` as the `default` argument, passed to `typer.Argument(default=...)`.\n\n```md-code__content\nname: str = typer.Argument(default=...)\n\n```\n\nInfo\n\nIf you hadn't seen that `...` before: it is a special single value, it is [part of Python and is called \"Ellipsis\"](https://docs.python.org/3/library/constants.html#Ellipsis).\n\n[Python 3.8+](#__tabbed_8_1)\n\n```md-code__content\nimport typer\n\ndef main(name: str = typer.Argument(default=...)):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nAnd the same way, you can make it optional by passing a different `default` value, for example `None`:\n\n[Python 3.8+ - non-Annotated](#__tabbed_9_1)\n\n```md-code__content\nfrom typing import Optional\n\nimport typer\n\ndef main(name: Optional[str] = typer.Argument(default=None)):\n    if name is None:\n        print(\"Hello World!\")\n    else:\n        print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+](#__tabbed_10_1)\n\n```md-code__content\nfrom typing import Optional\n\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(name: Annotated[Optional[str], typer.Argument()] = None):\n    if name is None:\n        print(\"Hello World!\")\n    else:\n        print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nBecause the first parameter passed to `typer.Argument(default=None)` (the new \"default\" value) is `None`, **Typer** knows that this is an **optional** _CLI argument_, if no value is provided when calling it in the command line, it will have that default value of `None`.\n\nThe `default` argument is the first one, so it's possible that you see code that passes the value without explicitly using `default=`, like:\n\n```md-code__content\nname: str = typer.Argument(...)\n\n```\n\n...or like:\n\n```md-code__content\nname: str = typer.Argument(None)\n\n```\n\n...but again, try to use `Annotated` if possible, that way your code in terms of Python will mean the same thing as with **Typer** and you won't have to remember any of these details.\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/arguments/optional/",
      "ogUrl": "https://typer.tiangolo.com/tutorial/arguments/optional/",
      "title": "Optional CLI Arguments - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/arguments/optional/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/arguments/optional.png",
      "ogTitle": "Optional CLI Arguments - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/arguments/optional.png",
      "og:title": "Optional CLI Arguments - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/arguments/optional/",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/arguments/optional.png",
      "twitter:title": "Optional CLI Arguments - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/subcommands/add-typer/#add-typer)\n\n# Add Typer [¶](https://typer.tiangolo.com/tutorial/subcommands/add-typer/\\#add-typer \"Permanent link\")\n\nWe'll start with the core idea.\n\nTo add a `typer.Typer()` app inside of another.\n\n## Manage items [¶](https://typer.tiangolo.com/tutorial/subcommands/add-typer/\\#manage-items \"Permanent link\")\n\nLet's imagine that you are creating a _CLI program_ to manage items in some distant land.\n\nIt could be in an `items.py` file with this:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\n\n@app.command()\ndef create(item: str):\n    print(f\"Creating item: {item}\")\n\n@app.command()\ndef delete(item: str):\n    print(f\"Deleting item: {item}\")\n\n@app.command()\ndef sell(item: str):\n    print(f\"Selling item: {item}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nAnd you would use it like:\n\n```\n\nfast →python items.py create Wand\nCreating item: Wand\n\nrestart ↻\n```\n\n## Manage users [¶](https://typer.tiangolo.com/tutorial/subcommands/add-typer/\\#manage-users \"Permanent link\")\n\nBut then you realize that you also have to manage users from your _CLI app_.\n\nIt could be a file `users.py` with something like:\n\n[Python 3.8+](#__tabbed_2_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\n\n@app.command()\ndef create(user_name: str):\n    print(f\"Creating user: {user_name}\")\n\n@app.command()\ndef delete(user_name: str):\n    print(f\"Deleting user: {user_name}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nAnd you would use it like:\n\n```\n\nfast →python users.py create Camila\nCreating user: Camila\n\nrestart ↻\n```\n\n## Put them together [¶](https://typer.tiangolo.com/tutorial/subcommands/add-typer/\\#put-them-together \"Permanent link\")\n\nBoth parts are similar. In fact, `items.py` and `users.py` both have commands `create` and `delete`.\n\nBut we need them to be part of the same _CLI program_.\n\nIn this case, as with `git remote`, we can put them together as subcommands in another `typer.Typer()` _CLI program_.\n\nNow create a `main.py` with:\n\n[Python 3.8+](#__tabbed_3_1)\n\n```md-code__content\nimport typer\n\nimport items\nimport users\n\napp = typer.Typer()\napp.add_typer(users.app, name=\"users\")\napp.add_typer(items.app, name=\"items\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nHere's what we do in `main.py`:\n\n- Import the other Python modules (the files `users.py` and `items.py`).\n- Create the main `typer.Typer()` application.\n- Use `app.add_typer()` to include the `app` from `items.py` and `users.py`, each of those 2 was also created with `typer.Typer()`.\n- Define a `name` with the command that will be used for each of these \"sub-Typers\" to group their own commands.\n\nAnd now your _CLI program_ has 2 commands:\n\n- `users`: with all of the commands (subcommands) in the `app` from `users.py`.\n- `items` with all the commands (subcommands) in the `app` from `items.py`.\n\nCheck it:\n\n```\n\nfast →💬 Check the helppython main.py --help\nUsage: main.py [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  --install-completion  Install completion for the current shell.\n  --show-completion     Show completion for the current shell, to copy it or customize the installation.\n  --help                Show this message and exit.\n\nCommands:\n  items\n  users\n\nrestart ↻\n```\n\nNow you have a _CLI program_ with commands `items` and `users`, and they in turn have their own commands (subcommands).\n\nLet's check the `items` command:\n\n```\n\nfast →💬 Check the help for itemspython main.py items --help\n💬 It shows its own commands (subcommands): create, delete, sellUsage: main.py items [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  create\n  delete\n  sell\n\n💬 Try itpython main.py items create Wand\nCreating item: Wand\n\npython main.py items sell Vase\nSelling item: Vase\n\nrestart ↻\n```\n\nTip\n\nNotice that we are still calling `$ python main.py` but now we are using the command `items`.\n\nAnd now check the command `users`, with all its subcommands:\n\n```\n\nfast →python main.py users --help\nUsage: main.py users [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  create\n  delete\n\n💬 Try itpython main.py users create Camila\nCreating user: Camila\n\nrestart ↻\n```\n\n## Recap [¶](https://typer.tiangolo.com/tutorial/subcommands/add-typer/\\#recap \"Permanent link\")\n\nThat's the core idea.\n\nYou can just create `typer.Typer()` apps and add them inside one another.\n\nAnd you can do that with any levels of commands that you want.\n\nDo you need sub-sub-sub-subcommands? Go ahead, create all the `typer.Typer()` s you need and put them together with `app.add_typer()`.\n\nIn the next sections we'll update this with more features, but you already have the core idea.\n\nThis way, in the same spirit of Click, **Typer** applications are composable, each `typer.Typer()` can be a _CLI app_ by itself, but it can also be added as a command group to another Typer app.\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/subcommands/add-typer/",
      "ogUrl": "https://typer.tiangolo.com/tutorial/subcommands/add-typer/",
      "title": "Add Typer - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/subcommands/add-typer/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/subcommands/add-typer.png",
      "ogTitle": "Add Typer - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/subcommands/add-typer.png",
      "og:title": "Add Typer - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/subcommands/add-typer/",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/subcommands/add-typer.png",
      "twitter:title": "Add Typer - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/options/prompt/#cli-option-prompt)\n\n# CLI Option Prompt [¶](https://typer.tiangolo.com/tutorial/options/prompt/\\#cli-option-prompt \"Permanent link\")\n\nIt's also possible to, instead of just showing an error, ask for the missing value with `prompt=True`:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(name: str, lastname: Annotated[str, typer.Option(prompt=True)]):\n    print(f\"Hello {name} {lastname}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_2_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(name: str, lastname: str = typer.Option(..., prompt=True)):\n    print(f\"Hello {name} {lastname}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nAnd then your program will ask the user for it in the terminal:\n\n```\n\nfast →💬 Call it with the NAME CLI argumentpython main.py Camila\n💬 It asks for the missing CLI option --lastnameGutiérrez\nHello Camila Gutiérrez\n\nrestart ↻\n```\n\n## Customize the prompt [¶](https://typer.tiangolo.com/tutorial/options/prompt/\\#customize-the-prompt \"Permanent link\")\n\nYou can also set a custom prompt, passing the string that you want to use instead of just `True`:\n\n[Python 3.8+](#__tabbed_3_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(\n    name: str,\n    lastname: Annotated[str, typer.Option(prompt=\"Please tell me your last name\")],\n):\n    print(f\"Hello {name} {lastname}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_4_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(\n    name: str, lastname: str = typer.Option(..., prompt=\"Please tell me your last name\")\n):\n    print(f\"Hello {name} {lastname}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nAnd then your program will ask for it using with your custom prompt:\n\n```\n\nfast →💬 Call it with the NAME CLI argumentpython main.py Camila\n💬 It uses the custom promptGutiérrez\nHello Camila Gutiérrez\n\nrestart ↻\n```\n\n## Confirmation prompt [¶](https://typer.tiangolo.com/tutorial/options/prompt/\\#confirmation-prompt \"Permanent link\")\n\nIn some cases you could want to prompt for something and then ask the user to confirm it by typing it twice.\n\nYou can do it passing the parameter `confirmation_prompt=True`.\n\nLet's say it's a CLI app to delete a project:\n\n[Python 3.8+](#__tabbed_5_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(\n    project_name: Annotated[str, typer.Option(prompt=True, confirmation_prompt=True)],\n):\n    print(f\"Deleting project {project_name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_6_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(project_name: str = typer.Option(..., prompt=True, confirmation_prompt=True)):\n    print(f\"Deleting project {project_name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nAnd it will prompt the user for a value and then for the confirmation:\n\n```\n\nfast →python main.py\n💬 Your app will first prompt for the project name, and then for the confirmationOld ProjectOld Project\nDeleting project Old Project\n\n💬 If the user doesn't type the same, receives an error and a new promptpython main.py\nOld ProjectNew Spice\nError: The two entered values do not match\n\nOld ProjectOld Project\nDeleting project Old Project\n\n💬 Now it works 🎉\nrestart ↻\n```\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/options/prompt/",
      "ogUrl": "https://typer.tiangolo.com/tutorial/options/prompt/",
      "title": "CLI Option Prompt - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/options/prompt/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/options/prompt.png",
      "ogTitle": "CLI Option Prompt - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/options/prompt.png",
      "og:title": "CLI Option Prompt - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/options/prompt/",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/options/prompt.png",
      "twitter:title": "CLI Option Prompt - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/parameter-types/custom-types/#custom-types)\n\n# Custom Types [¶](https://typer.tiangolo.com/tutorial/parameter-types/custom-types/\\#custom-types \"Permanent link\")\n\nYou can easily use your own custom types in your **Typer** applications.\n\nThe way to do it is by providing a way to parse input into your own types.\n\nThere are two ways to achieve this:\n\n- Adding a type `parser`\n- Expanding Click's custom types\n\n## Type Parser [¶](https://typer.tiangolo.com/tutorial/parameter-types/custom-types/\\#type-parser \"Permanent link\")\n\n`typer.Argument` and `typer.Option` can create custom parameter types with a `parser` callable.\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\nclass CustomClass:\n    def __init__(self, value: str):\n        self.value = value\n\n    def __str__(self):\n        return f\"<CustomClass: value={self.value}>\"\n\ndef parse_custom_class(value: str):\n    return CustomClass(value * 2)\n\ndef main(\n    custom_arg: Annotated[CustomClass, typer.Argument(parser=parse_custom_class)],\n    custom_opt: Annotated[CustomClass, typer.Option(parser=parse_custom_class)] = \"Foo\",\n):\n    print(f\"custom_arg is {custom_arg}\")\n    print(f\"--custom-opt is {custom_opt}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_2_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\nclass CustomClass:\n    def __init__(self, value: str):\n        self.value = value\n\n    def __str__(self):\n        return f\"<CustomClass: value={self.value}>\"\n\ndef parse_custom_class(value: str):\n    return CustomClass(value * 2)\n\ndef main(\n    custom_arg: CustomClass = typer.Argument(parser=parse_custom_class),\n    custom_opt: CustomClass = typer.Option(\"Foo\", parser=parse_custom_class),\n):\n    print(f\"custom_arg is {custom_arg}\")\n    print(f\"--custom-opt is {custom_opt}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nThe function (or callable) that you pass to the parameter `parser` will receive the input value as a string and should return the parsed value with your own custom type.\n\n## Click Custom Type [¶](https://typer.tiangolo.com/tutorial/parameter-types/custom-types/\\#click-custom-type \"Permanent link\")\n\nIf you already have a [Click Custom Type](https://click.palletsprojects.com/en/8.1.x/parameters/#implementing-custom-types), you can use it in `typer.Argument()` and `typer.Option()` with the `click_type` parameter.\n\n[Python 3.8+](#__tabbed_3_1)\n\n```md-code__content\nimport click\nimport typer\nfrom typing_extensions import Annotated\n\nclass CustomClass:\n    def __init__(self, value: str):\n        self.value = value\n\n    def __repr__(self):\n        return f\"<CustomClass: value={self.value}>\"\n\nclass CustomClassParser(click.ParamType):\n    name = \"CustomClass\"\n\n    def convert(self, value, param, ctx):\n        return CustomClass(value * 3)\n\ndef main(\n    custom_arg: Annotated[CustomClass, typer.Argument(click_type=CustomClassParser())],\n    custom_opt: Annotated[\\\n        CustomClass, typer.Option(click_type=CustomClassParser())\\\n    ] = \"Foo\",\n):\n    print(f\"custom_arg is {custom_arg}\")\n    print(f\"--custom-opt is {custom_opt}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_4_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport click\nimport typer\n\nclass CustomClass:\n    def __init__(self, value: str):\n        self.value = value\n\n    def __repr__(self):\n        return f\"<CustomClass: value={self.value}>\"\n\nclass CustomClassParser(click.ParamType):\n    name = \"CustomClass\"\n\n    def convert(self, value, param, ctx):\n        return CustomClass(value * 3)\n\ndef main(\n    custom_arg: CustomClass = typer.Argument(click_type=CustomClassParser()),\n    custom_opt: CustomClass = typer.Option(\"Foo\", click_type=CustomClassParser()),\n):\n    print(f\"custom_arg is {custom_arg}\")\n    print(f\"--custom-opt is {custom_opt}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/parameter-types/custom-types/",
      "ogUrl": "https://typer.tiangolo.com/tutorial/parameter-types/custom-types/",
      "title": "Custom Types - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/parameter-types/custom-types/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/parameter-types/custom-types.png",
      "ogTitle": "Custom Types - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/parameter-types/custom-types.png",
      "og:title": "Custom Types - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/parameter-types/custom-types/",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/parameter-types/custom-types.png",
      "twitter:title": "Custom Types - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/commands/name/#custom-command-name)\n\n# Custom Command Name [¶](https://typer.tiangolo.com/tutorial/commands/name/\\#custom-command-name \"Permanent link\")\n\nBy default, the command names are generated from the function name.\n\nSo, if your function is something like:\n\n```md-code__content\ndef create(username: str):\n    ...\n\n```\n\nThen the command name will be `create`.\n\nBut if you already had a function called `create()` somewhere in your code, you would have to name your CLI function differently.\n\nAnd what if you wanted the command to still be named `create`?\n\nFor this, you can set the name of the command in the first parameter for the `@app.command()` decorator:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\n\n@app.command(\"create\")\ndef cli_create_user(username: str):\n    print(f\"Creating user: {username}\")\n\n@app.command(\"delete\")\ndef cli_delete_user(username: str):\n    print(f\"Deleting user: {username}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nNow, even though the functions are named `cli_create_user()` and `cli_delete_user()`, the commands will still be named `create` and `delete`:\n\n```\n\nfast →python main.py --help\nUsage: main.py [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  --install-completion  Install completion for the current shell.\n  --show-completion     Show completion for the current shell, to copy it or customize the installation.\n  --help                Show this message and exit.\n\nCommands:\n  create\n  delete\n\n💬 Test itpython main.py create Camila\nCreating user: Camila\n\nrestart ↻\n```\n\nNote that any underscores in the function name will be replaced with dashes.\n\nSo if your function is something like:\n\n```md-code__content\ndef create_user(username: str):\n    ...\n\n```\n\nThen the command name will be `create-user`.\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/commands/name/",
      "ogUrl": "https://typer.tiangolo.com/tutorial/commands/name/",
      "title": "Custom Command Name - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/commands/name/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/commands/name.png",
      "ogTitle": "Custom Command Name - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/commands/name.png",
      "og:title": "Custom Command Name - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/commands/name/",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/commands/name.png",
      "twitter:title": "Custom Command Name - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/commands/#commands)\n\n# Commands [¶](https://typer.tiangolo.com/tutorial/commands/\\#commands \"Permanent link\")\n\nWe have seen how to create a CLI program with possibly several _CLI options_ and _CLI arguments_.\n\nBut **Typer** allows you to create CLI programs with several commands (also known as subcommands).\n\nFor example, the program `git` has several commands.\n\nOne command of `git` is `git push`. And `git push` in turn takes its own _CLI arguments_ and _CLI options_.\n\nFor example:\n\n```\n\nfast →💬 The push command with no parametersgit push\n\n💬 The push command with one CLI option --set-upstream and 2 CLI argumentsgit push --set-upstream origin master\n\nrestart ↻\n```\n\nAnother command of `git` is `git pull`, it also has some _CLI parameters_.\n\nIt's like if the same big program `git` had several small programs inside.\n\nTip\n\nA command looks the same as a _CLI argument_, it's just some name without a preceding `--`. But commands have a predefined name, and are used to group different sets of functionalities into the same CLI application.\n\n## Command or subcommand [¶](https://typer.tiangolo.com/tutorial/commands/\\#command-or-subcommand \"Permanent link\")\n\nIt's common to call a CLI program a \"command\".\n\nBut when one of these programs have subcommands, those subcommands are also frequently called just \"commands\".\n\nHave that in mind so you don't get confused.\n\nHere I'll use **CLI application** or **program** to refer to the program you are building in Python with Typer, and **command** to refer to one of these \"subcommands\" of your program.\n\n## Explicit application [¶](https://typer.tiangolo.com/tutorial/commands/\\#explicit-application \"Permanent link\")\n\nBefore creating CLI applications with multiple commands/subcommands we need to understand how to create an explicit `typer.Typer()` application.\n\nIn the _CLI options_ and _CLI argument_ tutorials you have seen how to create a single function and then pass that function to `typer.run()`.\n\nFor example:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nimport typer\n\ndef main(name: str):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nBut that is actually a shortcut. Under the hood, **Typer** converts that to a CLI application with `typer.Typer()` and executes it. All that inside of `typer.run()`.\n\nThere's also a more explicit way to achieve the same:\n\n[Python 3.8+](#__tabbed_2_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\n\n@app.command()\ndef main(name: str):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nWhen you use `typer.run()`, **Typer** is doing more or less the same as above, it will:\n\n- Create a new `typer.Typer()` \"application\".\n- Create a new \" `command`\" with your function.\n- Call the same \"application\" as if it was a function with \" `app()`\".\n\n`@decorator` Info\n\nThat `@something` syntax in Python is called a \"decorator\".\n\nYou put it on top of a function. Like a pretty decorative hat (I guess that's where the term came from).\n\nA \"decorator\" takes the function below and does something with it.\n\nIn our case, this decorator tells **Typer** that the function below is a \" `command`\".\n\nBoth ways, with `typer.run()` and creating the explicit application, achieve almost the same.\n\nTip\n\nIf your use case is solved with just `typer.run()`, that's fine, you don't have to create the explicit `app` and use `@app.command()`, etc.\n\nYou might want to do that later when your app needs the extra features, but if it doesn't need them yet, that's fine.\n\nIf you run the second example, with the explicit `app`, it works exactly the same:\n\n```\n\nfast →💬 Without a CLI argumentpython main.py\nUsage: main.py [OPTIONS] NAME\nTry \"main.py --help\" for help.\n\nError: Missing argument 'NAME'.\n\n💬 With the NAME CLI argumentpython main.py Camila\nHello Camila\n\n💬 Asking for helppython main.py  --help\nUsage: main.py [OPTIONS] NAME\n\nOptions:\n  --install-completion  Install completion for the current shell.\n  --show-completion     Show completion for the current shell, to copy it or customize the installation.\n  --help                Show this message and exit.\n\nrestart ↻\n```\n\n## CLI application completion [¶](https://typer.tiangolo.com/tutorial/commands/\\#cli-application-completion \"Permanent link\")\n\nThere's a little detail that is worth noting here.\n\nNow the help shows two new _CLI options_:\n\n- `--install-completion`\n- `--show-completion`\n\nTo get shell/tab completion, it's necessary to build a package that you and your users can install and **call directly**.\n\nSo instead of running a Python script like:\n\n```\n\nfast →python main.py\n✨ Some magic here ✨\n\nrestart ↻\n```\n\n...It would be called like:\n\n```\n\nfast →magic-app\n✨ Some magic here ✨\n\nrestart ↻\n```\n\nHaving a standalone program like that allows setting up shell/tab completion.\n\nThe first step to be able to create an installable package like that is to use an explicit `typer.Typer()` app.\n\nLater you can learn all the process to create a standalone CLI application and [Build a Package](https://typer.tiangolo.com/tutorial/package/).\n\nBut for now, it's just good to know that you are on that path. 😎\n\n## A CLI application with multiple commands [¶](https://typer.tiangolo.com/tutorial/commands/\\#a-cli-application-with-multiple-commands \"Permanent link\")\n\nComing back to the CLI applications with multiple commands/subcommands, **Typer** allows creating CLI applications with multiple of them.\n\nNow that you know how to create an explicit `typer.Typer()` application and add one command, let's see how to add multiple commands.\n\nLet's say that we have a CLI application to manage users.\n\nWe'll have a command to `create` users and another command to `delete` them.\n\nTo begin, let's say it can only create and delete one single predefined user:\n\n[Python 3.8+](#__tabbed_3_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\n\n@app.command()\ndef create():\n    print(\"Creating user: Hiro Hamada\")\n\n@app.command()\ndef delete():\n    print(\"Deleting user: Hiro Hamada\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nNow we have a CLI application with 2 commands, `create` and `delete`:\n\n```\n\nfast →💬 Check the helppython main.py --help\nUsage: main.py [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  --install-completion  Install completion for the current shell.\n  --show-completion     Show completion for the current shell, to copy it or customize the installation.\n  --help                Show this message and exit.\n\nCommands:\n  create\n  delete\n\n💬 Test thempython main.py create\nCreating user: Hiro Hamada\n\npython main.py delete\nDeleting user: Hiro Hamada\n\n💬 Now we have 2 commands! 🎉\nrestart ↻\n```\n\nNotice that the help text now shows the 2 commands: `create` and `delete`.\n\nTip\n\nBy default, the names of the commands are generated from the function name.\n\n## Show the help message if no command is given [¶](https://typer.tiangolo.com/tutorial/commands/\\#show-the-help-message-if-no-command-is-given \"Permanent link\")\n\nBy default, we need to specify `--help` to get the command's help page.\n\nHowever, by setting `no_args_is_help=True` when defining the `typer.Typer()` application, the help function will be shown whenever no argument is given:\n\n[Python 3.8+](#__tabbed_4_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer(no_args_is_help=True)\n\n@app.command()\ndef create():\n    print(\"Creating user: Hiro Hamada\")\n\n@app.command()\ndef delete():\n    print(\"Deleting user: Hiro Hamada\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nNow we can run this:\n\n```\n\nfast →💬 Check the help without having to type --helppython main.py\nUsage: main.py [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  --install-completion  Install completion for the current shell.\n  --show-completion     Show completion for the current shell, to copy it or customize the installation.\n  --help                Show this message and exit.\n\nCommands:\n  create\n  delete\n\nrestart ↻\n```\n\n## Sorting of the commands [¶](https://typer.tiangolo.com/tutorial/commands/\\#sorting-of-the-commands \"Permanent link\")\n\nNote that by design, **Typer** shows the commands in the order they've been declared.\n\nSo, if we take our original example, with `create` and `delete` commands, and reverse the order in the Python file:\n\n[Python 3.8+](#__tabbed_5_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\n\n@app.command()\ndef delete():\n    print(\"Deleting user: Hiro Hamada\")\n\n@app.command()\ndef create():\n    print(\"Creating user: Hiro Hamada\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nThen we will see the `delete` command first in the help output:\n\n```\n\nfast →💬 Check the helppython main.py --help\nUsage: main.py [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  --install-completion  Install completion for the current shell.\n  --show-completion     Show completion for the current shell, to copy it or customize the installation.\n  --help                Show this message and exit.\n\nCommands:\n  delete\n  create\n\nrestart ↻\n```\n\n## Click Group [¶](https://typer.tiangolo.com/tutorial/commands/\\#click-group \"Permanent link\")\n\nIf you come from Click, a `typer.Typer` app with subcommands is more or less the equivalent of a [Click Group](https://click.palletsprojects.com/en/7.x/quickstart/#nesting-commands).\n\nTechnical Details\n\nA `typer.Typer` app is _not_ a Click Group, but it provides the equivalent functionality. And it creates a Click Group when calling it.\n\nIt is not directly a Group because **Typer** doesn't modify the functions in your code to convert them to another type of object, it only registers them.\n\n## Decorator Technical Details [¶](https://typer.tiangolo.com/tutorial/commands/\\#decorator-technical-details \"Permanent link\")\n\nWhen you use `@app.command()` the function under the decorator is registered in the **Typer** application and is then used later by the application.\n\nBut Typer doesn't modify that function itself, the function is left as is.\n\nThat means that if your function is simple enough that you could create it without using `typer.Option()` or `typer.Argument()`, you could use the same function for a **Typer** application and a **FastAPI** application putting both decorators on top, or similar tricks.\n\nClick Technical Details\n\nThis behavior is a design difference with Click.\n\nIn Click, when you add a `@click.command()` decorator it actually modifies the function underneath and replaces it with an object.\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/commands/",
      "ogUrl": "https://typer.tiangolo.com/tutorial/commands/",
      "title": "Commands - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/commands/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/commands/index.png",
      "ogTitle": "Commands - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/commands/index.png",
      "og:title": "Commands - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/commands/",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/commands/index.png",
      "twitter:title": "Commands - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/subcommands/name-and-help/#subcommand-name-and-help)\n\n# SubCommand Name and Help [¶](https://typer.tiangolo.com/tutorial/subcommands/name-and-help/\\#subcommand-name-and-help \"Permanent link\")\n\nWhen adding a Typer app to another we have seen how to set the `name` to use for the command.\n\nFor example to set the command to `users`:\n\n```md-code__content\napp.add_typer(users.app, name=\"users\")\n\n```\n\n## Add a help text [¶](https://typer.tiangolo.com/tutorial/subcommands/name-and-help/\\#add-a-help-text \"Permanent link\")\n\nWe can also set the `help` text while adding a Typer:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\n\nusers_app = typer.Typer()\napp.add_typer(users_app, name=\"users\", help=\"Manage users in the app.\")\n\n@users_app.command()\ndef create(name: str):\n    print(f\"Creating user: {name}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nAnd then we get that help text for that command in the _CLI program_:\n\n```\n\nfast →💬 Check the main helppython main.py --help\nUsage: main.py [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  --install-completion  Install completion for the current shell.\n  --show-completion     Show completion for the current shell, to copy it or customize the installation.\n  --help                Show this message and exit.\n\nCommands:\n  users  Manage users in the app.\n\n💬 Check the help for the users commandpython main.py users --help\nUsage: main.py users [OPTIONS] COMMAND [ARGS]...\n\n  Manage users in the app.\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  create\n\nrestart ↻\n```\n\nWe can set the `help` in several places, each one taking precedence over the other, overriding the previous value.\n\nLet's see those locations.\n\nTip\n\nThere are other attributes that can be set in that same way in the same places we'll see next.\n\nBut those are documented later in another section.\n\n## Inferring help text from callback [¶](https://typer.tiangolo.com/tutorial/subcommands/name-and-help/\\#inferring-help-text-from-callback \"Permanent link\")\n\n### Inferring a command's help text [¶](https://typer.tiangolo.com/tutorial/subcommands/name-and-help/\\#inferring-a-commands-help-text \"Permanent link\")\n\nWhen you create a command with `@app.command()`, by default, it generates the name from the function name.\n\nAnd by default, the help text is extracted from the function's docstring.\n\nFor example:\n\n```md-code__content\n@app.command()\ndef create(item: str):\n    \"\"\"\n    Create an item.\n    \"\"\"\n    typer.echo(f\"Creating item: {item}\")\n\n```\n\n...will create a command `create` with a help text of `Create an item`.\n\n### Inferring the help text from `@app.callback()` [¶](https://typer.tiangolo.com/tutorial/subcommands/name-and-help/\\#inferring-the-help-text-from-appcallback \"Permanent link\")\n\nThe same way, if you define a callback in a `typer.Typer()`, the help text is extracted from the callback function's docstring.\n\nHere's an example:\n\n[Python 3.8+](#__tabbed_2_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\n\nusers_app = typer.Typer()\napp.add_typer(users_app, name=\"users\")\n\n@users_app.callback()\ndef users():\n    \"\"\"\n    Manage users in the app.\n    \"\"\"\n\n@users_app.command()\ndef create(name: str):\n    print(f\"Creating user: {name}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nThe help text for that command will be the callback function's docstring: `Manage users in the app.`.\n\nCheck it:\n\n```\n\nfast →💬 Check the main helppython main.py --help\n💬 Notice the help text \"Manage users in the app.\"Usage: main.py [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  --install-completion  Install completion for the current shell.\n  --show-completion     Show completion for the current shell, to copy it or customize the installation.\n  --help                Show this message and exit.\n\nCommands:\n  users  Manage users in the app.\n\n💬 Check the help for the users commandpython main.py users --help\n💬 Notice the main description: \"Manage users in the app.\"Usage: main.py users [OPTIONS] COMMAND [ARGS]...\n\n  Manage users in the app.\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  create\n\nrestart ↻\n```\n\nNote\n\nBefore Typer 0.14.0, in addition to the help text, the command name was also inferred from the callback function name, this is no longer the case.\n\n### Help from callback parameter in `typer.Typer()` [¶](https://typer.tiangolo.com/tutorial/subcommands/name-and-help/\\#help-from-callback-parameter-in-typertyper \"Permanent link\")\n\nIf you pass a `callback` parameter while creating a `typer.Typer(callback=some_function)` it will be used to infer the help text.\n\nThis has the lowest priority, we'll see later what has a higher priority and can override it.\n\nCheck the code:\n\n[Python 3.8+](#__tabbed_3_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\n\ndef users():\n    \"\"\"\n    Manage users in the app.\n    \"\"\"\n\nusers_app = typer.Typer(callback=users, name=\"users\")\napp.add_typer(users_app)\n\n@users_app.command()\ndef create(name: str):\n    print(f\"Creating user: {name}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nThis achieves exactly the same as the previous example.\n\nCheck it:\n\n```\n\nfast →💬 Check the main helppython main.py --help\n💬 Notice the help text \"Manage users in the app.\"Usage: main.py [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  --install-completion  Install completion for the current shell.\n  --show-completion     Show completion for the current shell, to copy it or customize the installation.\n  --help                Show this message and exit.\n\nCommands:\n  users  Manage users in the app.\n\n💬 Check the help for the users commandpython main.py users --help\n💬 Notice the main description: \"Manage users in the app.\"Usage: main.py users [OPTIONS] COMMAND [ARGS]...\n\n  Manage users in the app.\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  create\n\nrestart ↻\n```\n\n### Override a callback set in `typer.Typer()` with `@app.callback()` [¶](https://typer.tiangolo.com/tutorial/subcommands/name-and-help/\\#override-a-callback-set-in-typertyper-with-appcallback \"Permanent link\")\n\nThe same as with normal **Typer** apps, if you pass a `callback` to `typer.Typer(callback=some_function)` and then override it with `@app.callback()`, the help text will be inferred from the new callback:\n\n[Python 3.8+](#__tabbed_4_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\n\ndef old_callback():\n    \"\"\"\n    Old callback help.\n    \"\"\"\n\nusers_app = typer.Typer(callback=old_callback)\napp.add_typer(users_app, name=\"users\")\n\n@users_app.callback()\ndef users():\n    \"\"\"\n    Manage users in the app.\n    \"\"\"\n\n@users_app.command()\ndef create(name: str):\n    print(f\"Creating user: {name}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nNow the help text will be `Manage users in the app.` instead of `Old callback help.`.\n\nCheck it:\n\n```\n\nfast →💬 Check the main helppython main.py --help\n💬 Notice the help text \"Manage users in the app.\"Usage: main.py [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  --install-completion  Install completion for the current shell.\n  --show-completion     Show completion for the current shell, to copy it or customize the installation.\n  --help                Show this message and exit.\n\nCommands:\n  users  Manage users in the app.\n\n💬 Check the help for the users commandpython main.py users --help\n💬 Notice the main description: \"Manage users in the app.\"Usage: main.py users [OPTIONS] COMMAND [ARGS]...\n\n  Manage users in the app.\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  create\n\nrestart ↻\n```\n\n### Help from callback in `app.add_typer()` [¶](https://typer.tiangolo.com/tutorial/subcommands/name-and-help/\\#help-from-callback-in-appadd_typer \"Permanent link\")\n\nIf you override the callback in `app.add_typer()` when including a sub-app, the help will be inferred from this callback function.\n\nThis takes precedence over inferring the help from a callback set in `@sub_app.callback()` and `typer.Typer(callback=sub_app_callback)`.\n\nCheck the code:\n\n[Python 3.8+](#__tabbed_5_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\n\ndef old_callback():\n    \"\"\"\n    Old callback help.\n    \"\"\"\n\nusers_app = typer.Typer(callback=old_callback, name=\"users\")\n\ndef new_users():\n    \"\"\"\n    I have the highland! Create some users.\n    \"\"\"\n\napp.add_typer(users_app, callback=new_users, name=\"new-users\")\n\n@users_app.callback()\ndef users():\n    \"\"\"\n    Manage users in the app.\n    \"\"\"\n\n@users_app.command()\ndef create(name: str):\n    print(f\"Creating user: {name}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nThe help text will be `I have the highland! Create some users.` instead of the previous ones.\n\nCheck it:\n\n```\n\nfast →💬 Check the main helppython main.py --help\n💬 Check the command new-users and its help textUsage: main.py [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  --install-completion  Install completion for the current shell.\n  --show-completion     Show completion for the current shell, to copy it or customize the installation.\n  --help                Show this message and exit.\n\nCommands:\n  new-users  I have the highland! Create some users.\n\n💬 Now check the help for the new-users commandpython main.py new-users --help\n💬 Notice the help textUsage: main.py new-users [OPTIONS] COMMAND [ARGS]...\n\n  I have the highland! Create some users.\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  create\n\nrestart ↻\n```\n\n### Enough inferring [¶](https://typer.tiangolo.com/tutorial/subcommands/name-and-help/\\#enough-inferring \"Permanent link\")\n\nSo, when inferring help text, the precedence order from lowest priority to highest is:\n\n- `sub_app = typer.Typer(callback=some_function)`\n- `@sub_app.callback()`\n- `app.add_typer(sub_app, callback=new_function)`\n\nThat's for inferring the help text from functions.\n\nBut if you set the help text explicitly, that has a higher priority than these.\n\n## Set the name and help [¶](https://typer.tiangolo.com/tutorial/subcommands/name-and-help/\\#set-the-name-and-help \"Permanent link\")\n\nLet's now see the places where you can set the command name and help text, from lowest priority to highest.\n\nTip\n\nSetting the help text explicitly always has a higher precedence than inferring from a callback function.\n\n### Name and help in `typer.Typer()` [¶](https://typer.tiangolo.com/tutorial/subcommands/name-and-help/\\#name-and-help-in-typertyper \"Permanent link\")\n\nYou could have all the callbacks and overrides we defined before, but the help text was inferred from the function docstring.\n\nIf you set it explicitly, that takes precedence over inferring.\n\nYou can set it when creating a new `typer.Typer()`:\n\n[Python 3.8+](#__tabbed_6_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\n\ndef old_callback():\n    \"\"\"\n    Old callback help.\n    \"\"\"\n\nusers_app = typer.Typer(callback=old_callback, name=\"exp-users\", help=\"Explicit help.\")\n\ndef new_users():\n    \"\"\"\n    I have the highland! Create some users.\n    \"\"\"\n\napp.add_typer(users_app, callback=new_users)\n\n@users_app.callback()\ndef users():\n    \"\"\"\n    Manage users in the app.\n    \"\"\"\n\n@users_app.command()\ndef create(name: str):\n    print(f\"Creating user: {name}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nInfo\n\nThe rest of the callbacks and overrides are there only to show you that they don't affect the name and help text when you set it explicitly.\n\nWe set an explicit help `Explicit help.`.\n\nSo that will take precedence now.\n\nCheck it:\n\n```\n\nfast →💬 Check the main helppython main.py --help\n💬 Notice the command name is exp-users and the help text is \"Explicit help.\"Usage: main.py [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  --install-completion  Install completion for the current shell.\n  --show-completion     Show completion for the current shell, to copy it or customize the installation.\n  --help                Show this message and exit.\n\nCommands:\n  exp-users  Explicit help.\n\n💬 Check the help for the exp-users commandpython main.py exp-users --help\n💬 Notice the main help textUsage: main.py exp-users [OPTIONS] COMMAND [ARGS]...\n\n  Explicit help.\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  create\n\nrestart ↻\n```\n\n### Help text in `@app.callback()` [¶](https://typer.tiangolo.com/tutorial/subcommands/name-and-help/\\#help-text-in-appcallback \"Permanent link\")\n\nMany parameters that you use when creating a `typer.Typer()` app can be overridden in the parameters of `@app.callback()`.\n\nContinuing with the previous example, we now override the `help` in `@user_app.callback()`:\n\n[Python 3.8+](#__tabbed_7_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\n\ndef old_callback():\n    \"\"\"\n    Old callback help.\n    \"\"\"\n\nusers_app = typer.Typer(callback=old_callback, name=\"users\", help=\"Explicit help.\")\n\ndef new_users():\n    \"\"\"\n    I have the highland! Create some users.\n    \"\"\"\n\napp.add_typer(users_app, callback=new_users)\n\n@users_app.callback(help=\"Help from callback for users.\")\ndef users():\n    \"\"\"\n    Manage users in the app.\n    \"\"\"\n\n@users_app.command()\ndef create(name: str):\n    print(f\"Creating user: {name}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nAnd now the help text will be `Help from callback for users.`.\n\nCheck it:\n\n```\n\nfast →💬 Check the helppython main.py --help\n💬 The help text is now \"Help from callback for users.\".Usage: main.py [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  --install-completion  Install completion for the current shell.\n  --show-completion     Show completion for the current shell, to copy it or customize the installation.\n  --help                Show this message and exit.\n\nCommands:\n  users  Help from callback for users.\n\n💬 Check the users command helppython main.py users --help\n💬 Notice the main help textUsage: main.py users [OPTIONS] COMMAND [ARGS]...\n\n  Help from callback for users.\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  create\n\nrestart ↻\n```\n\n### Name and help in `app.add_typer()` [¶](https://typer.tiangolo.com/tutorial/subcommands/name-and-help/\\#name-and-help-in-appadd_typer \"Permanent link\")\n\nAnd finally, with the highest priority, you can override all that by explicitly setting the `name` and `help` in `app.add_typer()`, just like we did on the first example above:\n\n[Python 3.8+](#__tabbed_8_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\n\ndef old_callback():\n    \"\"\"\n    Old callback help.\n    \"\"\"\n\nusers_app = typer.Typer(callback=old_callback, name=\"exp-users\", help=\"Explicit help.\")\n\ndef new_users():\n    \"\"\"\n    I have the highland! Create some users.\n    \"\"\"\n\napp.add_typer(\n    users_app,\n    callback=new_users,\n    name=\"cake-sith-users\",\n    help=\"Unlimited powder! Eh, users.\",\n)\n\n@users_app.callback(help=\"Help from callback for users.\")\ndef users():\n    \"\"\"\n    Manage users in the app.\n    \"\"\"\n\n@users_app.command()\ndef create(name: str):\n    print(f\"Creating user: {name}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nAnd now, with the highest priorities of them all, the command name will now be `cake-sith-users` and the help text will be `Unlimited powder! Eh, users.`.\n\nCheck it:\n\n```\n\nfast →💬 Check the helppython main.py --help\n💬 Notice the command name cake-sith-users and the new help text \"Unlimited powder! Eh, users.\"Usage: main.py [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  --install-completion  Install completion for the current shell.\n  --show-completion     Show completion for the current shell, to copy it or customize the installation.\n  --help                Show this message and exit.\n\nCommands:\n  cake-sith-users  Unlimited powder! Eh, users.\n\n💬 And check the help for the command cake-sith-userspython main.py cake-sith-users --help\n💬 Notice the main help textUsage: main.py cake-sith-users [OPTIONS] COMMAND [ARGS]...\n\n  Unlimited powder! Eh, users.\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  create\n\nrestart ↻\n```\n\n## Recap [¶](https://typer.tiangolo.com/tutorial/subcommands/name-and-help/\\#recap \"Permanent link\")\n\nThe precedence to generate a command's **help**, from lowest priority to highest, is:\n\n- Implicitly inferred from `sub_app = typer.Typer(callback=some_function)`\n- Implicitly inferred from the callback function under `@sub_app.callback()`\n- Implicitly inferred from `app.add_typer(sub_app, callback=some_function)`\n- Explicitly set on `sub_app = typer.Typer(help=\"Some help.\")`\n- Explicitly set on `app.add_typer(sub_app, help=\"Some help.\")`\n\nAnd the priority to set the command's **name**, from lowest priority to highest, is:\n\n- Explicitly set on `sub_app = typer.Typer(name=\"some-name\")`\n- Explicitly set on `app.add_typer(sub_app, name=\"some-name\")`\n\nSo, `app.add_typer(sub_app, name=\"some-name\", help=\"Some help.\")` always wins.\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/subcommands/name-and-help/",
      "ogUrl": "https://typer.tiangolo.com/tutorial/subcommands/name-and-help/",
      "title": "SubCommand Name and Help - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/subcommands/name-and-help/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/subcommands/name-and-help.png",
      "ogTitle": "SubCommand Name and Help - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/subcommands/name-and-help.png",
      "og:title": "SubCommand Name and Help - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/subcommands/name-and-help/",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/subcommands/name-and-help.png",
      "twitter:title": "SubCommand Name and Help - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/options/name/#cli-option-name)\n\n# CLI Option Name [¶](https://typer.tiangolo.com/tutorial/options/name/\\#cli-option-name \"Permanent link\")\n\nBy default **Typer** will create a _CLI option_ name from the function parameter.\n\nSo, if you have a function with:\n\n```md-code__content\ndef main(user_name: Optional[str] = None):\n    pass\n\n```\n\nor\n\n```md-code__content\ndef main(user_name: Annotated[Optional[str], typer.Option()] = None):\n    pass\n\n```\n\n**Typer** will create a _CLI option_:\n\n```md-code__content\n--user-name\n\n```\n\nBut you can customize it if you want to.\n\nLet's say the function parameter name is `user_name` as above, but you want the _CLI option_ to be just `--name`.\n\nYou can pass the _CLI option_ name that you want to have in the following positional argument passed to `typer.Option()`:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(user_name: Annotated[str, typer.Option(\"--name\")]):\n    print(f\"Hello {user_name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_2_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(user_name: str = typer.Option(..., \"--name\")):\n    print(f\"Hello {user_name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nInfo\n\n\" [Positional](https://docs.python.org/3.8/glossary.html#term-argument)\" means that it's not a function argument with a keyword name.\n\nFor example `show_default=True` is a keyword argument. \" `show_default`\" is the keyword.\n\nBut in `\"--name\"` there's no `option_name=\"--name\"` or something similar, it's just the string value `\"--name\"` that goes in `typer.Option()`.\n\nThat's a \"positional argument\" in a function.\n\nCheck it:\n\n```\n\nfast →python main.py --help\n💬 Notice the --name instead of --user-nameUsage: main.py [OPTIONS]\n\nOptions:\n  --name TEXT           [required]\n  --help                Show this message and exit.\n\n💬 Try itpython main.py --name Camila\nHello Camila\n\nrestart ↻\n```\n\n## _CLI option_ short names [¶](https://typer.tiangolo.com/tutorial/options/name/\\#cli-option-short-names \"Permanent link\")\n\nA short name is a _CLI option_ name with a single dash ( `-`) instead of 2 ( `--`) and a single letter, like `-n` instead of `--name`.\n\nFor example, the `ls` program has a _CLI option_ named `--size`, and the same _CLI option_ also has a short name `-s`:\n\n```\n\nfast →💬 With the long name --sizels ./myproject --size\n12 first-steps.md   4 intro.md\n\n💬 With the short name -sls ./myproject -s\n12 first-steps.md   4 intro.md\n\n💬 Both CLI option names do the same\nrestart ↻\n```\n\n### _CLI option_ short names together [¶](https://typer.tiangolo.com/tutorial/options/name/\\#cli-option-short-names-together \"Permanent link\")\n\nShort names have another feature, when they have a single letter, as in `-s`, you can put several of these _CLI options_ together, with a single dash.\n\nFor example, the `ls` program has these 2 _CLI options_ (among others):\n\n- `--size`: show the sizes of the listed files.\n- `--human`: show a human-readable format, like `1MB` instead of just `1024`.\n\nAnd these 2 _CLI options_ have short versions too:\n\n- `--size`: short version `-s`.\n- `--human`: short version `-h`.\n\nSo, you can put them together with `-sh` or `-hs`:\n\n```\n\nfast →💬 Call ls with long CLI optionsls --size --human\n12K first-steps.md   4.0K intro.md\n\n💬 Now with short versionsls -s -h\n12K first-steps.md   4.0K intro.md\n\n💬 And with short versions togetherls -sh\n12K first-steps.md   4.0K intro.md\n\n💬 Order in short versions doesn't matterls -hs\n12K first-steps.md   4.0K intro.md\n\n💬 They all work the same 🎉\nrestart ↻\n```\n\n### _CLI option_ short names with values [¶](https://typer.tiangolo.com/tutorial/options/name/\\#cli-option-short-names-with-values \"Permanent link\")\n\nWhen you use _CLI options_ with short names, you can put them together if they are just boolean flags, like `--size` or `--human`.\n\nBut if you have a _CLI option_ `--file` with a short name `-f` that takes a value, if you put it with other short names for _CLI options_, you have to put it as the last letter, so that it can receive the value that comes right after.\n\nFor example, let's say you are decompressing/extracting a file `myproject.tar.gz` with the program `tar`.\n\nYou can pass these _CLI option_ short names to `tar`:\n\n- `-x`: means \"e `X` tract\", to decompress and extract the contents.\n- `-v`: means \" `V` erbose\", to print on the screen what it is doing, so you can know that it's decompressing each file and can entertain yourself while you wait.\n- `-f`: means \" `F` ile\", this one requires a value, the compressed file to extract (in our example, this is `myproject.tar.gz`).\n  - So if you use all the short names together, this `-f` has to come last, to receive the value that comes next to it.\n\nFor example:\n\n```\n\nfast →tar -xvf myproject.tar.gz\nmyproject/\nmyproject/first-steps.md\nmyproject/intro.md\n\n💬 But if you put the -f beforetar -fxv myproject.tar.gz\n💬 You get an ugly errortar: You must specify one of the blah, blah, error, error\n\nrestart ↻\n```\n\n### Defining _CLI option_ short names [¶](https://typer.tiangolo.com/tutorial/options/name/\\#defining-cli-option-short-names \"Permanent link\")\n\nIn **Typer** you can also define _CLI option_ short names the same way you can customize the long names.\n\nYou can pass _positional_ arguments to `typer.Option()` to define the _CLI option_ name(s).\n\nTip\n\nRemember the _positional_ function arguments are those that don't have a keyword.\n\nAll the other function arguments/parameters you pass to `typer.Option()` like `prompt=True` and `help=\"This option blah, blah\"` require the keyword.\n\nYou can overwrite the _CLI option_ name to use as in the previous example, but you can also declare extra alternatives, including short names.\n\nFor example, extending the previous example, let's add a _CLI option_ short name `-n`:\n\n[Python 3.8+](#__tabbed_3_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(user_name: Annotated[str, typer.Option(\"--name\", \"-n\")]):\n    print(f\"Hello {user_name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_4_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(user_name: str = typer.Option(..., \"--name\", \"-n\")):\n    print(f\"Hello {user_name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nHere we are overwriting the _CLI option_ name that by default would be `--user-name`, and we are defining it to be `--name`. And we are also declaring a _CLI option_ short name of `-n`.\n\nCheck it:\n\n```\n\nfast →💬 Check the helppython main.py --help\n💬 Notice the two CLI option names -n and --nameUsage: main.py [OPTIONS]\n\nOptions:\n  -n, --name TEXT       [required]\n  --help                Show this message and exit.\n\n💬 Try the short versionpython main.py -n Camila\nHello Camila\n\nrestart ↻\n```\n\n### _CLI option_ only short name [¶](https://typer.tiangolo.com/tutorial/options/name/\\#cli-option-only-short-name \"Permanent link\")\n\nIf you only declare a short name like `-n` then that will be the only _CLI option_ name. And neither `--name` nor `--user-name` will be available.\n\n[Python 3.8+](#__tabbed_5_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(user_name: Annotated[str, typer.Option(\"-n\")]):\n    print(f\"Hello {user_name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_6_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(user_name: str = typer.Option(..., \"-n\")):\n    print(f\"Hello {user_name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nCheck it:\n\n```\n\nfast →python main.py --help\n💬 Notice there's no --name nor --user-name, only -nUsage: main.py [OPTIONS]\n\nOptions:\n  -n TEXT               [required]\n  --help                Show this message and exit.\n\n💬 Try itpython main.py -n Camila\nHello Camila\n\nrestart ↻\n```\n\n### _CLI option_ short name and default [¶](https://typer.tiangolo.com/tutorial/options/name/\\#cli-option-short-name-and-default \"Permanent link\")\n\nContinuing with the example above, as **Typer** allows you to declare a _CLI option_ as having only a short name, if you want to have the default long name plus a short name, you have to declare both explicitly:\n\n[Python 3.8+](#__tabbed_7_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(user_name: Annotated[str, typer.Option(\"--user-name\", \"-n\")]):\n    print(f\"Hello {user_name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_8_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(user_name: str = typer.Option(..., \"--user-name\", \"-n\")):\n    print(f\"Hello {user_name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nCheck it:\n\n```\n\nfast →python main.py --help\n💬 Notice that we have the long version --user-name back💬 and we also have the short version -nUsage: main.py [OPTIONS]\n\nOptions:\n  -n, --user-name TEXT  [required]\n  --help                Show this message and exit.\n\n💬 Try itpython main.py --user-name Camila\nHello Camila\n\n💬 And try the short versionpython main.py -n Camila\nrestart ↻\n```\n\n### _CLI option_ short names together [¶](https://typer.tiangolo.com/tutorial/options/name/\\#cli-option-short-names-together_1 \"Permanent link\")\n\nYou can create multiple short names and use them together.\n\nYou don't have to do anything special for it to work (apart from declaring those short versions):\n\n[Python 3.8+](#__tabbed_9_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(\n    name: Annotated[str, typer.Option(\"--name\", \"-n\")],\n    formal: Annotated[bool, typer.Option(\"--formal\", \"-f\")] = False,\n):\n    if formal:\n        print(f\"Good day Ms. {name}.\")\n    else:\n        print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_10_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(\n    name: str = typer.Option(..., \"--name\", \"-n\"),\n    formal: bool = typer.Option(False, \"--formal\", \"-f\"),\n):\n    if formal:\n        print(f\"Good day Ms. {name}.\")\n    else:\n        print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nTip\n\nNotice that, again, we are declaring the long and short version of the _CLI option_ names.\n\nCheck it:\n\n```\n\nfast →python main.py --help\n💬 We now have short versions -n and -f💬 And also long versions --name and --formalUsage: main.py [OPTIONS]\n\nOptions:\n  -n, --name TEXT       [required]\n  -f, --formal\n  --help                Show this message and exit.\n\n💬 Try the short versionspython main.py -n Camila -f\nGood day Ms. Camila.\n\n💬 And try the 2 short versions together💬 See how -n has to go last, to be able to get the valuepython main.py -fn Camila\nGood day Ms. Camila.\n\nrestart ↻\n```\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/options/name/",
      "ogUrl": "https://typer.tiangolo.com/tutorial/options/name/",
      "title": "CLI Option Name - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/options/name/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/options/name.png",
      "ogTitle": "CLI Option Name - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/options/name.png",
      "og:title": "CLI Option Name - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/options/name/",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/options/name.png",
      "twitter:title": "CLI Option Name - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/parameter-types/number/#number)\n\n# Number [¶](https://typer.tiangolo.com/tutorial/parameter-types/number/\\#number \"Permanent link\")\n\nYou can define numeric validations with `max` and `min` values for `int` and `float` _CLI parameters_:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(\n    id: Annotated[int, typer.Argument(min=0, max=1000)],\n    age: Annotated[int, typer.Option(min=18)] = 20,\n    score: Annotated[float, typer.Option(max=100)] = 0,\n):\n    print(f\"ID is {id}\")\n    print(f\"--age is {age}\")\n    print(f\"--score is {score}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_2_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(\n    id: int = typer.Argument(..., min=0, max=1000),\n    age: int = typer.Option(20, min=18),\n    score: float = typer.Option(0, max=100),\n):\n    print(f\"ID is {id}\")\n    print(f\"--age is {age}\")\n    print(f\"--score is {score}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n_CLI arguments_ and _CLI options_ can both use these validations.\n\nYou can specify `min`, `max` or both.\n\nCheck it:\n\n```\n\nfast →python main.py --help\n💬 Notice the extra RANGE in the help text for --age and --scoreUsage: main.py [OPTIONS] ID\n\nArguments:\n  ID  [required]\n\nOptions:\n  --age INTEGER RANGE   [default: 20]\n  --score FLOAT RANGE   [default: 0]\n  --help                Show this message and exit.\n\n💬 Pass all the CLI parameterspython main.py 5 --age 20 --score 90\nID is 5\n--age is 20\n--score is 90.0\n\n💬 Pass an invalid IDpython main.py 1002\nUsage: main.py [OPTIONS] ID\nTry \"main.py --help\" for help.\n\nError: Invalid value for 'ID': 1002 is not in the range 0<=x<=1000.\n\n💬 Pass an invalid agepython main.py 5 --age 15\nUsage: main.py [OPTIONS] ID\nTry \"main.py --help\" for help.\n\nError: Invalid value for '--age': 15 is not in the range x>=18.\n\n💬 Pass an invalid scorepython main.py 5 --age 20 --score 100.5\nUsage: main.py [OPTIONS] ID\nTry \"main.py --help\" for help.\n\nError: Invalid value for '--score': 100.5 is not in the range x<=100.\n\n💬 But as we didn't specify a minimum score, this is acceptedpython main.py 5 --age 20 --score -5\nID is 5\n--age is 20\n--score is -5.0\n\nrestart ↻\n```\n\n## Clamping numbers [¶](https://typer.tiangolo.com/tutorial/parameter-types/number/\\#clamping-numbers \"Permanent link\")\n\nYou might want to, instead of showing an error, use the closest minimum or maximum valid values.\n\nYou can do it with the `clamp` parameter:\n\n[Python 3.8+](#__tabbed_3_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(\n    id: Annotated[int, typer.Argument(min=0, max=1000)],\n    rank: Annotated[int, typer.Option(max=10, clamp=True)] = 0,\n    score: Annotated[float, typer.Option(min=0, max=100, clamp=True)] = 0,\n):\n    print(f\"ID is {id}\")\n    print(f\"--rank is {rank}\")\n    print(f\"--score is {score}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_4_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(\n    id: int = typer.Argument(..., min=0, max=1000),\n    rank: int = typer.Option(0, max=10, clamp=True),\n    score: float = typer.Option(0, min=0, max=100, clamp=True),\n):\n    print(f\"ID is {id}\")\n    print(f\"--rank is {rank}\")\n    print(f\"--score is {score}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nAnd then, when you pass data that is out of the valid range, it will be \"clamped\", the closest valid value will be used:\n\n```\n\nfast →💬 ID doesn't have clamp, so it shows an errorpython main.py 1002\nUsage: main.py [OPTIONS] ID\nTry \"main.py --help\" for help.\n\nError: Invalid value for 'ID': 1002 is not in the range 0<=x<=1000.\n\n💬 But --rank and --score use clamppython main.py 5 --rank 11 --score -5\nID is 5\n--rank is 10\n--score is 0\n\nrestart ↻\n```\n\n## Counter _CLI options_ [¶](https://typer.tiangolo.com/tutorial/parameter-types/number/\\#counter-cli-options \"Permanent link\")\n\nYou can make a _CLI option_ work as a counter with the `counter` parameter:\n\n[Python 3.8+](#__tabbed_5_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(verbose: Annotated[int, typer.Option(\"--verbose\", \"-v\", count=True)] = 0):\n    print(f\"Verbose level is {verbose}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_6_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(verbose: int = typer.Option(0, \"--verbose\", \"-v\", count=True)):\n    print(f\"Verbose level is {verbose}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nIt means that the _CLI option_ will be like a boolean flag, e.g. `--verbose`.\n\nAnd the value you receive in the function will be the amount of times that `--verbose` was added:\n\n```\n\nfast →💬 Check itpython main.py\nVerbose level is 0\n\n💬 Now use one --verbosepython main.py --verbose\nVerbose level is 1\n\n💬 Now 3 --verbosepython main.py --verbose --verbose --verbose\nVerbose level is 3\n\n💬 And with the short namepython main.py -v\nVerbose level is 1\n\n💬 And with the short name 3 timespython main.py -v -v -v\nVerbose level is 3\n\n💬 As short names can be put together, this also workspython main.py -vvv\nVerbose level is 3\n\nrestart ↻\n```\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/parameter-types/number/",
      "ogUrl": "https://typer.tiangolo.com/tutorial/parameter-types/number/",
      "title": "Number - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/parameter-types/number/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/parameter-types/number.png",
      "ogTitle": "Number - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/parameter-types/number.png",
      "og:title": "Number - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/parameter-types/number/",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/parameter-types/number.png",
      "twitter:title": "Number - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/options/version/#version-cli-option-is_eager)\n\n# Version CLI Option, `is_eager` [¶](https://typer.tiangolo.com/tutorial/options/version/\\#version-cli-option-is_eager \"Permanent link\")\n\nYou could use a callback to implement a `--version` _CLI option_.\n\nIt would show the version of your CLI program and then it would terminate it. Even before any other _CLI parameter_ is processed.\n\n## First version of `--version` [¶](https://typer.tiangolo.com/tutorial/options/version/\\#first-version-of-version \"Permanent link\")\n\nLet's see a first version of how it could look like:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nfrom typing import Optional\n\nimport typer\nfrom typing_extensions import Annotated\n\n__version__ = \"0.1.0\"\n\ndef version_callback(value: bool):\n    if value:\n        print(f\"Awesome CLI Version: {__version__}\")\n        raise typer.Exit()\n\ndef main(\n    name: Annotated[str, typer.Option()] = \"World\",\n    version: Annotated[\\\n        Optional[bool], typer.Option(\"--version\", callback=version_callback)\\\n    ] = None,\n):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_2_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nfrom typing import Optional\n\nimport typer\n\n__version__ = \"0.1.0\"\n\ndef version_callback(value: bool):\n    if value:\n        print(f\"Awesome CLI Version: {__version__}\")\n        raise typer.Exit()\n\ndef main(\n    name: str = typer.Option(\"World\"),\n    version: Optional[bool] = typer.Option(\n        None, \"--version\", callback=version_callback\n    ),\n):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nTip\n\nNotice that we don't have to get the `typer.Context` and check for `ctx.resilient_parsing` for completion to work, because we only print and modify the program when `--version` is passed, otherwise, nothing is printed or changed from the callback.\n\nIf the `--version` _CLI option_ is passed, we get a value `True` in the callback.\n\nThen we can print the version and raise `typer.Exit()` to make sure the program is terminated before anything else is executed.\n\nWe also declare the explicit _CLI option_ name `--version`, because we don't want an automatic `--no-version`, it would look awkward.\n\nCheck it:\n\n```\n\nfast →python main.py --help\n💬 We get a --version, and don't get an awkward --no-version 🎉Usage: main.py [OPTIONS]\n\nOptions:\n  --version\n  --name TEXT\n  --help                Show this message and exit.\n\n💬 We can call it normallypython main.py --name Camila\nHello Camila\n\n💬 And we can get the versionpython main.py --version\nAwesome CLI Version: 0.1.0\n\n💬 Because we exit in the callback, we don't get a \"Hello World\" message after the version 🚀\nrestart ↻\n```\n\n## Previous parameters and `is_eager` [¶](https://typer.tiangolo.com/tutorial/options/version/\\#previous-parameters-and-is_eager \"Permanent link\")\n\nBut now let's say that the `--name` _CLI option_ that we declared before `--version` is required, and it has a callback that could exit the program:\n\n[Python 3.8+](#__tabbed_3_1)\n\n```md-code__content\nfrom typing import Optional\n\nimport typer\nfrom typing_extensions import Annotated\n\n__version__ = \"0.1.0\"\n\ndef version_callback(value: bool):\n    if value:\n        print(f\"Awesome CLI Version: {__version__}\")\n        raise typer.Exit()\n\ndef name_callback(name: str):\n    if name != \"Camila\":\n        raise typer.BadParameter(\"Only Camila is allowed\")\n\ndef main(\n    name: Annotated[str, typer.Option(callback=name_callback)],\n    version: Annotated[\\\n        Optional[bool], typer.Option(\"--version\", callback=version_callback)\\\n    ] = None,\n):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_4_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nfrom typing import Optional\n\nimport typer\n\n__version__ = \"0.1.0\"\n\ndef version_callback(value: bool):\n    if value:\n        print(f\"Awesome CLI Version: {__version__}\")\n        raise typer.Exit()\n\ndef name_callback(name: str):\n    if name != \"Camila\":\n        raise typer.BadParameter(\"Only Camila is allowed\")\n\ndef main(\n    name: str = typer.Option(..., callback=name_callback),\n    version: Optional[bool] = typer.Option(\n        None, \"--version\", callback=version_callback\n    ),\n):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nThen our CLI program could not work as expected in some cases as it is _right now_, because if we use `--version` after `--name` then the callback for `--name` will be processed before and we can get its error:\n\n```\n\nfast →python main.py --name Rick --version\nOnly Camila is allowed\nAborted!\n\nrestart ↻\n```\n\nTip\n\nWe don't have to check for `ctx.resilient_parsing` in the `name_callback()` for completion to work, because we are not using `typer.echo()`, instead we are raising a `typer.BadParameter`.\n\nTechnical Details\n\n`typer.BadParameter` prints the error to \"standard error\", not to \"standard output\", and because the completion system only reads from \"standard output\", it won't break completion.\n\nInfo\n\nIf you need a refresher about what is \"standard output\" and \"standard error\" check the section in [Printing and Colors: \"Standard Output\" and \"Standard Error\"](https://typer.tiangolo.com/tutorial/printing/#standard-output-and-standard-error).\n\n### Fix with `is_eager` [¶](https://typer.tiangolo.com/tutorial/options/version/\\#fix-with-is_eager \"Permanent link\")\n\nFor those cases, we can mark a _CLI parameter_ (a _CLI option_ or _CLI argument_) with `is_eager=True`.\n\nThat will tell **Typer** (actually Click) that it should process this _CLI parameter_ before the others:\n\n[Python 3.8+](#__tabbed_5_1)\n\n```md-code__content\nfrom typing import Optional\n\nimport typer\nfrom typing_extensions import Annotated\n\n__version__ = \"0.1.0\"\n\ndef version_callback(value: bool):\n    if value:\n        print(f\"Awesome CLI Version: {__version__}\")\n        raise typer.Exit()\n\ndef name_callback(name: str):\n    if name != \"Camila\":\n        raise typer.BadParameter(\"Only Camila is allowed\")\n    return name\n\ndef main(\n    name: Annotated[str, typer.Option(callback=name_callback)],\n    version: Annotated[\\\n        Optional[bool],\\\n        typer.Option(\"--version\", callback=version_callback, is_eager=True),\\\n    ] = None,\n):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_6_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nfrom typing import Optional\n\nimport typer\n\n__version__ = \"0.1.0\"\n\ndef version_callback(value: bool):\n    if value:\n        print(f\"Awesome CLI Version: {__version__}\")\n        raise typer.Exit()\n\ndef name_callback(name: str):\n    if name != \"Camila\":\n        raise typer.BadParameter(\"Only Camila is allowed\")\n    return name\n\ndef main(\n    name: str = typer.Option(..., callback=name_callback),\n    version: Optional[bool] = typer.Option(\n        None, \"--version\", callback=version_callback, is_eager=True\n    ),\n):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nCheck it:\n\n```\n\nfast →python main.py --name Rick --version\n💬 Now we only get the version, and the name is not usedAwesome CLI Version: 0.1.0\n\nrestart ↻\n```\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/options/version/",
      "ogUrl": "https://typer.tiangolo.com/tutorial/options/version/",
      "title": "Version CLI Option, is_eager - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/options/version/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/options/version.png",
      "ogTitle": "Version CLI Option, is_eager - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/options/version.png",
      "og:title": "Version CLI Option, is_eager - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/options/version/",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/options/version.png",
      "twitter:title": "Version CLI Option, is_eager - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/typer-command/#typer-command)\n\n# `typer` command [¶](https://typer.tiangolo.com/tutorial/typer-command/\\#typer-command \"Permanent link\")\n\nThe `typer` command provides ✨ completion ✨ in the Terminal for your own small scripts. Even if they don't use Typer internally. Of course, it works better if you use **Typer** in your script.\n\nIt's probably most useful if you have a small custom Python script using **Typer** (maybe as part of some project), for some small tasks, and it's not complex/important enough to create a whole installable Python package for it (something to be installed with `pip`).\n\nIn that case, you can run your program with the `typer` command in your Terminal, and it will provide completion for your script.\n\nThe `typer` command also has functionality to generate Markdown documentation for your own **Typer** programs 📝.\n\n## Install [¶](https://typer.tiangolo.com/tutorial/typer-command/\\#install \"Permanent link\")\n\nWhen you install **Typer** with:\n\n```md-code__content\npip install typer\n\n```\n\n...it includes the `typer` command.\n\nIf you don't want to have the `typer` command, you can install instead:\n\n```md-code__content\npip install typer-slim\n\n```\n\nYou can still use it by calling the Typer library as a module with:\n\n```md-code__content\npython -m typer\n\n```\n\n## Install completion [¶](https://typer.tiangolo.com/tutorial/typer-command/\\#install-completion \"Permanent link\")\n\nYou can then install completion for the `typer` command with:\n\n```\n\nfast →typer --install-completion\nbash completion installed in /home/user/.bashrc.\nCompletion will take effect once you restart the terminal.\n\nrestart ↻\n```\n\n### Sample script [¶](https://typer.tiangolo.com/tutorial/typer-command/\\#sample-script \"Permanent link\")\n\nLet's say you have a script that uses **Typer** in `my_custom_script.py`:\n\n```md-code__content\nfrom typing import Optional\n\nimport typer\n\napp = typer.Typer()\n\n@app.command()\ndef hello(name: Optional[str] = None):\n    if name:\n        typer.echo(f\"Hello {name}\")\n    else:\n        typer.echo(\"Hello World!\")\n\n@app.command()\ndef bye(name: Optional[str] = None):\n    if name:\n        typer.echo(f\"Bye {name}\")\n    else:\n        typer.echo(\"Goodbye!\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nFor it to work, you would also install **Typer**:\n\n```\n\nfast →python -m pip install typerSuccessfully installed typer\n\nrestart ↻\n```\n\n### Run with Python [¶](https://typer.tiangolo.com/tutorial/typer-command/\\#run-with-python \"Permanent link\")\n\nThen you could run your script with normal Python:\n\n```\n\nfast →python my_custom_script.py hello\nHello World!\n\npython my_custom_script.py hello --name Camila\nHello Camila!\n\npython my_custom_script.py bye --name Camila\nBye Camila\n\nrestart ↻\n```\n\nThere's nothing wrong with using Python directly to run it. And, in fact, if some other code or program uses your script, that would probably be the best way to do it.\n\n⛔️ But in your terminal, you won't get completion when hitting `TAB` for any of the subcommands or options, like `hello`, `bye`, and `--name`.\n\n### Run with the `typer` command. [¶](https://typer.tiangolo.com/tutorial/typer-command/\\#run-with-the-typer-command \"Permanent link\")\n\nYou can also run the same script with the `typer` command:\n\n```\n\nfast →typer my_custom_script.py run hello\nHello World!\n\ntyper my_custom_script.py run hello --name Camila\nHello Camila!\n\ntyper my_custom_script.py run bye --name Camila\nBye Camila\n\nrestart ↻\n```\n\n- Instead of using `python` directly you use the `typer` command.\n- After the name of the file, add the subcommand `run`.\n\n✔️ If you installed completion for the `typer` command as described above, when you hit `TAB` you will have ✨ completion for everything ✨, including all the subcommands and options of your script, like `hello`, `bye`, and `--name` 🚀.\n\n## If main [¶](https://typer.tiangolo.com/tutorial/typer-command/\\#if-main \"Permanent link\")\n\nBecause the `typer` command won't use the block with:\n\n```md-code__content\nif __name__ == \"__main__\":\n    app()\n\n```\n\n...you can also remove it if you are calling that script only with the `typer` command.\n\n## Run other files [¶](https://typer.tiangolo.com/tutorial/typer-command/\\#run-other-files \"Permanent link\")\n\nThe `typer` command can run any script with **Typer**, but the script doesn't even have to use **Typer** at all.\n\nYou could even run a file with a function that could be used with `typer.run()`, even if the script doesn't use `typer.run()` or anything else.\n\nFor example, a file `main.py` like this will still work:\n\n```md-code__content\ndef main(name: str = \"World\"):\n    \"\"\"\n    Say hi to someone, by default to the World.\n    \"\"\"\n    print(f\"Hello {name}\")\n\n```\n\nThen you can call it with:\n\n```\n\nfast →typer main.py run --helpUsage: typer run [OPTIONS]\n\n  Say hi to someone, by default to the World.\n\nOptions:\n  --name TEXT\n  --help       Show this message and exit.\n\ntyper main.py run --name Camila\nHello Camila\n\nrestart ↻\n```\n\nAnd it will also have completion for things like the `--name` _CLI Option_.\n\n## Run a package or module [¶](https://typer.tiangolo.com/tutorial/typer-command/\\#run-a-package-or-module \"Permanent link\")\n\nInstead of a file path you can pass a module (possibly in a package) to import.\n\nFor example:\n\n```\n\nfast →typer my_package.main run --helpUsage: typer run [OPTIONS]\n\nOptions:\n  --name TEXT\n  --help       Show this message and exit.\n\ntyper my_package.main run --name Camila\nHello Camila\n\nrestart ↻\n```\n\n## Options [¶](https://typer.tiangolo.com/tutorial/typer-command/\\#options \"Permanent link\")\n\nYou can specify one of the following **CLI options**:\n\n- `--app`: the name of the variable with a `Typer()` object to run as the main app.\n- `--func`: the name of the variable with a function that would be used with `typer.run()`.\n\n### Defaults [¶](https://typer.tiangolo.com/tutorial/typer-command/\\#defaults \"Permanent link\")\n\nWhen your run a script with the `typer` command it will use the app from the following priority:\n\n- An app object from the `--app` _CLI Option_.\n- A function to convert to a **Typer** app from `--func` _CLI Option_ (like when using `typer.run()`).\n- A **Typer** app in a variable with a name of `app`, `cli`, or `main`.\n- The first **Typer** app available in the file, with any name.\n- A function in a variable with a name of `main`, `cli`, or `app`.\n- The first function in the file, with any name.\n\n## Generate docs [¶](https://typer.tiangolo.com/tutorial/typer-command/\\#generate-docs \"Permanent link\")\n\nYou can also use the `typer` command to generate Markdown documentation for your **Typer** application.\n\n### Sample script with docs [¶](https://typer.tiangolo.com/tutorial/typer-command/\\#sample-script-with-docs \"Permanent link\")\n\nFor example, you could have a script like:\n\n[Python 3.8+ - non-Annotated](#__tabbed_1_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer(help=\"Awesome CLI user manager.\")\n\n@app.command()\ndef create(username: str):\n    \"\"\"\n    Create a new user with USERNAME.\n    \"\"\"\n    print(f\"Creating user: {username}\")\n\n@app.command()\ndef delete(\n    username: str,\n    force: bool = typer.Option(\n        ...,\n        prompt=\"Are you sure you want to delete the user?\",\n        help=\"Force deletion without confirmation.\",\n    ),\n):\n    \"\"\"\n    Delete a user with USERNAME.\n\n    If --force is not used, will ask for confirmation.\n    \"\"\"\n    if force:\n        print(f\"Deleting user: {username}\")\n    else:\n        print(\"Operation cancelled\")\n\n@app.command()\ndef delete_all(\n    force: bool = typer.Option(\n        ...,\n        prompt=\"Are you sure you want to delete ALL users?\",\n        help=\"Force deletion without confirmation.\",\n    ),\n):\n    \"\"\"\n    Delete ALL users in the database.\n\n    If --force is not used, will ask for confirmation.\n    \"\"\"\n    if force:\n        print(\"Deleting all users\")\n    else:\n        print(\"Operation cancelled\")\n\n@app.command()\ndef init():\n    \"\"\"\n    Initialize the users database.\n    \"\"\"\n    print(\"Initializing user database\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+](#__tabbed_2_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\napp = typer.Typer(help=\"Awesome CLI user manager.\")\n\n@app.command()\ndef create(username: str):\n    \"\"\"\n    Create a new user with USERNAME.\n    \"\"\"\n    print(f\"Creating user: {username}\")\n\n@app.command()\ndef delete(\n    username: str,\n    force: Annotated[\\\n        bool,\\\n        typer.Option(\\\n            prompt=\"Are you sure you want to delete the user?\",\\\n            help=\"Force deletion without confirmation.\",\\\n        ),\\\n    ],\n):\n    \"\"\"\n    Delete a user with USERNAME.\n\n    If --force is not used, will ask for confirmation.\n    \"\"\"\n    if force:\n        print(f\"Deleting user: {username}\")\n    else:\n        print(\"Operation cancelled\")\n\n@app.command()\ndef delete_all(\n    force: Annotated[\\\n        bool,\\\n        typer.Option(\\\n            prompt=\"Are you sure you want to delete ALL users?\",\\\n            help=\"Force deletion without confirmation.\",\\\n        ),\\\n    ],\n):\n    \"\"\"\n    Delete ALL users in the database.\n\n    If --force is not used, will ask for confirmation.\n    \"\"\"\n    if force:\n        print(\"Deleting all users\")\n    else:\n        print(\"Operation cancelled\")\n\n@app.command()\ndef init():\n    \"\"\"\n    Initialize the users database.\n    \"\"\"\n    print(\"Initializing user database\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\n### Generate docs with the `typer` command [¶](https://typer.tiangolo.com/tutorial/typer-command/\\#generate-docs-with-the-typer-command \"Permanent link\")\n\nThen you could generate docs for it with the `typer` command.\n\nYou can use the subcommand `utils`.\n\nAnd then the subcommand `docs`.\n\n```\n\nfast →typer some_script.py utils docs\nrestart ↻\n```\n\nTip\n\nIf you installed only `typer-slim` and you don't have the `typer` command, you can still generate docs with:\n\n```md-code__content\n$ python -m typer some_script.py utils docs\n\n```\n\n**Options**:\n\n- `--name TEXT`: The name of the CLI program to use in docs.\n- `--output FILE`: An output file to write docs to, like README.md.\n- `--title TEXT`: A title to use in the docs, by default the name of the command.\n\nFor example:\n\n```\n\nfast →typer my_package.main utils docs --name awesome-cli --output README.md\nDocs saved to: README.md\n\nrestart ↻\n```\n\n### Sample docs output [¶](https://typer.tiangolo.com/tutorial/typer-command/\\#sample-docs-output \"Permanent link\")\n\nFor example, for the previous script, the generated docs would look like:\n\n* * *\n\n## `awesome-cli` [¶](https://typer.tiangolo.com/tutorial/typer-command/\\#awesome-cli \"Permanent link\")\n\nAwesome CLI user manager.\n\n**Usage**:\n\n```md-code__content\n$ awesome-cli [OPTIONS] COMMAND [ARGS]...\n\n```\n\n**Options**:\n\n- `--install-completion`: Install completion for the current shell.\n- `--show-completion`: Show completion for the current shell, to copy it or customize the installation.\n- `--help`: Show this message and exit.\n\n**Commands**:\n\n- `create`: Create a new user with USERNAME.\n- `delete`: Delete a user with USERNAME.\n- `delete-all`: Delete ALL users in the database.\n- `init`: Initialize the users database.\n\n## `awesome-cli create` [¶](https://typer.tiangolo.com/tutorial/typer-command/\\#awesome-cli-create \"Permanent link\")\n\nCreate a new user with USERNAME.\n\n**Usage**:\n\n```md-code__content\n$ awesome-cli create [OPTIONS] USERNAME\n\n```\n\n**Options**:\n\n- `--help`: Show this message and exit.\n\n## `awesome-cli delete` [¶](https://typer.tiangolo.com/tutorial/typer-command/\\#awesome-cli-delete \"Permanent link\")\n\nDelete a user with USERNAME.\n\nIf --force is not used, will ask for confirmation.\n\n**Usage**:\n\n```md-code__content\n$ awesome-cli delete [OPTIONS] USERNAME\n\n```\n\n**Options**:\n\n- `--force / --no-force`: Force deletion without confirmation. \\[required\\]\n- `--help`: Show this message and exit.\n\n## `awesome-cli delete-all` [¶](https://typer.tiangolo.com/tutorial/typer-command/\\#awesome-cli-delete-all \"Permanent link\")\n\nDelete ALL users in the database.\n\nIf --force is not used, will ask for confirmation.\n\n**Usage**:\n\n```md-code__content\n$ awesome-cli delete-all [OPTIONS]\n\n```\n\n**Options**:\n\n- `--force / --no-force`: Force deletion without confirmation. \\[required\\]\n- `--help`: Show this message and exit.\n\n## `awesome-cli init` [¶](https://typer.tiangolo.com/tutorial/typer-command/\\#awesome-cli-init \"Permanent link\")\n\nInitialize the users database.\n\n**Usage**:\n\n```md-code__content\n$ awesome-cli init [OPTIONS]\n\n```\n\n**Options**:\n\n- `--help`: Show this message and exit.\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/typer-command/",
      "ogUrl": "https://typer.tiangolo.com/tutorial/typer-command/",
      "title": "typer command - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/typer-command/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/typer-command.png",
      "ogTitle": "typer command - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/typer-command.png",
      "og:title": "typer command - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/typer-command/",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/typer-command.png",
      "twitter:title": "typer command - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/parameter-types/file/#file)\n\n# File [¶](https://typer.tiangolo.com/tutorial/parameter-types/file/\\#file \"Permanent link\")\n\nApart from `Path` _CLI parameters_ you can also declare some types of \"files\".\n\nTip\n\nIn most of the cases you are probably fine just using `Path`.\n\nYou can read and write data with `Path` the same way.\n\nThe difference is that these types will give you a Python [file-like object](https://docs.python.org/3/glossary.html#term-file-object) instead of a Python [Path](https://docs.python.org/3/library/pathlib.html#basic-use).\n\nA \"file-like object\" is the same type of object returned by `open()` as in:\n\n```md-code__content\nwith open('file.txt') as f:\n    # Here f is the file-like object\n    read_data = f.read()\n    print(read_data)\n\n```\n\nBut in some special use cases you might want to use these special types. For example if you are migrating an existing application.\n\n## `FileText` reading [¶](https://typer.tiangolo.com/tutorial/parameter-types/file/\\#filetext-reading \"Permanent link\")\n\n`typer.FileText` gives you a file-like object for reading text, you will get `str` data from it.\n\nThis means that even if your file has text written in a non-english language, e.g. a `text.txt` file with:\n\n```md-code__content\nla cigüeña trae al niño\n\n```\n\nYou will have a `str` with the text inside, e.g.:\n\n```md-code__content\ncontent = \"la cigüeña trae al niño\"\n\n```\n\ninstead of having `bytes`, e.g.:\n\n```md-code__content\ncontent = b\"la cig\\xc3\\xbce\\xc3\\xb1a trae al ni\\xc3\\xb1o\"\n\n```\n\nYou will get all the correct editor support, attributes, methods, etc for the file-like object:\\`\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(config: Annotated[typer.FileText, typer.Option()]):\n    for line in config:\n        print(f\"Config line: {line}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_2_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(config: typer.FileText = typer.Option(...)):\n    for line in config:\n        print(f\"Config line: {line}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nCheck it:\n\n```\n\nfast →💬 Create a quick text configecho \"some settings\" > config.txt\n💬 Add another line to the config to test itecho \"some more settings\" >> config.txt\n💬 Now run your programpython main.py --config config.txt\nConfig line: some settings\n\nConfig line: some more settings\n\nrestart ↻\n```\n\n## `FileTextWrite` [¶](https://typer.tiangolo.com/tutorial/parameter-types/file/\\#filetextwrite \"Permanent link\")\n\nFor writing text, you can use `typer.FileTextWrite`:\n\n[Python 3.8+](#__tabbed_3_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(config: Annotated[typer.FileTextWrite, typer.Option()]):\n    config.write(\"Some config written by the app\")\n    print(\"Config written\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_4_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(config: typer.FileTextWrite = typer.Option(...)):\n    config.write(\"Some config written by the app\")\n    print(\"Config written\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nThis would be for writing human text, like:\n\n```md-code__content\nsome settings\nla cigüeña trae al niño\n\n```\n\n...not to write binary `bytes`.\n\nCheck it:\n\n```\n\nfast →python main.py --config text.txt\nConfig written\n\n💬 Check the contents of the filecat text.txt\nSome config written by the app\n\nrestart ↻\n```\n\nTechnical Details\n\n`typer.FileTextWrite` is a just a convenience class.\n\nIt's the same as using `typer.FileText` and setting `mode=\"w\"`. You will learn about `mode` later below.\n\n## `FileBinaryRead` [¶](https://typer.tiangolo.com/tutorial/parameter-types/file/\\#filebinaryread \"Permanent link\")\n\nTo read binary data you can use `typer.FileBinaryRead`.\n\nYou will receive `bytes` from it.\n\nIt's useful for reading binary files like images:\n\n[Python 3.8+](#__tabbed_5_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(file: Annotated[typer.FileBinaryRead, typer.Option()]):\n    processed_total = 0\n    for bytes_chunk in file:\n        # Process the bytes in bytes_chunk\n        processed_total += len(bytes_chunk)\n        print(f\"Processed bytes total: {processed_total}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_6_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(file: typer.FileBinaryRead = typer.Option(...)):\n    processed_total = 0\n    for bytes_chunk in file:\n        # Process the bytes in bytes_chunk\n        processed_total += len(bytes_chunk)\n        print(f\"Processed bytes total: {processed_total}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nCheck it:\n\n```\n\nfast →python main.py --file lena.jpg\nProcessed bytes total: 512\nProcessed bytes total: 1024\nProcessed bytes total: 1536\nProcessed bytes total: 2048\n\nrestart ↻\n```\n\n## `FileBinaryWrite` [¶](https://typer.tiangolo.com/tutorial/parameter-types/file/\\#filebinarywrite \"Permanent link\")\n\nTo write binary data you can use `typer.FileBinaryWrite`.\n\nYou would write `bytes` to it.\n\nIt's useful for writing binary files like images.\n\nHave in mind that you have to pass `bytes` to its `.write()` method, not `str`.\n\nIf you have a `str`, you have to encode it first to get `bytes`.\n\n[Python 3.8+](#__tabbed_7_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(file: Annotated[typer.FileBinaryWrite, typer.Option()]):\n    first_line_str = \"some settings\\n\"\n    # You cannot write str directly to a binary file, you have to encode it to get bytes\n    first_line_bytes = first_line_str.encode(\"utf-8\")\n    # Then you can write the bytes\n    file.write(first_line_bytes)\n    # This is already bytes, it starts with b\"\n    second_line = b\"la cig\\xc3\\xbce\\xc3\\xb1a trae al ni\\xc3\\xb1o\"\n    file.write(second_line)\n    print(\"Binary file written\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_8_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(file: typer.FileBinaryWrite = typer.Option(...)):\n    first_line_str = \"some settings\\n\"\n    # You cannot write str directly to a binary file, you have to encode it to get bytes\n    first_line_bytes = first_line_str.encode(\"utf-8\")\n    # Then you can write the bytes\n    file.write(first_line_bytes)\n    # This is already bytes, it starts with b\"\n    second_line = b\"la cig\\xc3\\xbce\\xc3\\xb1a trae al ni\\xc3\\xb1o\"\n    file.write(second_line)\n    print(\"Binary file written\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n```\n\nfast →python main.py --file binary.dat\nBinary file written\n\n💬 Check the binary file was createdls ./binary.dat\n./binary.dat\n\nrestart ↻\n```\n\n## File _CLI parameter_ configurations [¶](https://typer.tiangolo.com/tutorial/parameter-types/file/\\#file-cli-parameter-configurations \"Permanent link\")\n\nYou can use several configuration parameters for these types (classes) in `typer.Option()` and `typer.Argument()`:\n\n- `mode`: controls the \" [mode](https://docs.python.org/3/library/functions.html#open)\" to open the file with.\n  - It's automatically set for you by using the classes above.\n  - Read more about it below.\n- `encoding`: to force a specific encoding, e.g. `\"utf-8\"`.\n- `lazy`: delay I/O operations. Automatic by default.\n  - By default, when writing files, Click will generate a file-like object that is not yet the actual file. Once you start writing, it will go, open the file and start writing to it, but not before. This is mainly useful to avoid creating the file until you start writing to it. It's normally safe to leave this automatic. But you can overwrite it setting `lazy=False`. By default, it's `lazy=True` for writing and `lazy=False` for reading.\n- `atomic`: if true, all writes will actually go to a temporal file and then moved to the final destination after completing. This is useful with files modified frequently by several users/programs.\n\n## Advanced `mode` [¶](https://typer.tiangolo.com/tutorial/parameter-types/file/\\#advanced-mode \"Permanent link\")\n\nBy default, **Typer** will configure the [`mode`](https://docs.python.org/3/library/functions.html#open) for you:\n\n- `typer.FileText`: `mode=\"r\"`, to read text.\n- `typer.FileTextWrite`: `mode=\"w\"`, to write text.\n- `typer.FileBinaryRead`: `mode=\"rb\"`, to read binary data.\n- `typer.FileBinaryWrite`: `mode=\"wb\"`, to write binary data.\n\n### Note about `FileTextWrite` [¶](https://typer.tiangolo.com/tutorial/parameter-types/file/\\#note-about-filetextwrite \"Permanent link\")\n\n`typer.FileTextWrite` is actually just a convenience class. It's the same as using `typer.FileText` with `mode=\"w\"`.\n\nBut it's probably shorter and more intuitive as you can get it with autocompletion in your editor by just starting to type `typer.File`... just like the other classes.\n\n### Customize `mode` [¶](https://typer.tiangolo.com/tutorial/parameter-types/file/\\#customize-mode \"Permanent link\")\n\nYou can override the `mode` from the defaults above.\n\nFor example, you could use `mode=\"a\"` to write \"appending\" to the same file:\n\n[Python 3.8+](#__tabbed_9_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(config: Annotated[typer.FileText, typer.Option(mode=\"a\")]):\n    config.write(\"This is a single line\\n\")\n    print(\"Config line written\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_10_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(config: typer.FileText = typer.Option(..., mode=\"a\")):\n    config.write(\"This is a single line\\n\")\n    print(\"Config line written\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nTip\n\nAs you are manually setting `mode=\"a\"`, you can use `typer.FileText` or `typer.FileTextWrite`, both will work.\n\nCheck it:\n\n```\n\nfast →python main.py --config config.txt\nConfig line written\n\n💬 Run your program a couple more times to see how it appends instead of overwritingpython main.py --config config.txt\nConfig line written\n\npython main.py --config config.txt\nConfig line written\n\n💬 Check the contents of the file, it should have each of the 3 lines appendedcat config.txt\nThis is a single line\nThis is a single line\nThis is a single line\n\nrestart ↻\n```\n\n## About the different types [¶](https://typer.tiangolo.com/tutorial/parameter-types/file/\\#about-the-different-types \"Permanent link\")\n\nInfo\n\nThese are technical details about why the different types/classes provided by **Typer**.\n\nBut you don't need this information to be able to use them. You can skip it.\n\n**Typer** provides you these different types (classes) because they inherit directly from the actual Python implementation that will be provided underneath for each case.\n\nThis way your editor will give you the right type checks and completion for each type.\n\nEven if you use `lazy`. When you use `lazy` Click creates a especial object to delay writes, and serves as a \"proxy\" to the actual file that will be written. But this especial proxy object doesn't expose the attributes and methods needed for type checks and completion in the editor. If you access those attributes or call the methods, the \"proxy\" lazy object will call them in the final object and it will all work. But you wouldn't get autocompletion for them.\n\nBut because these **Typer** classes inherit from the actual implementation that will be provided underneath (not the lazy object), you will get all the autocompletion and type checks in the editor.\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/parameter-types/file/",
      "ogUrl": "https://typer.tiangolo.com/tutorial/parameter-types/file/",
      "title": "File - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/parameter-types/file/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/parameter-types/file.png",
      "ogTitle": "File - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/parameter-types/file.png",
      "og:title": "File - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/parameter-types/file/",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/parameter-types/file.png",
      "twitter:title": "File - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/progressbar/#progress-bar)\n\n# Progress Bar [¶](https://typer.tiangolo.com/tutorial/progressbar/\\#progress-bar \"Permanent link\")\n\nIf you are executing an operation that can take some time, you can inform it to the user. 🤓\n\n## Progress Bar [¶](https://typer.tiangolo.com/tutorial/progressbar/\\#progress-bar_1 \"Permanent link\")\n\nYou can use [Rich's Progress Display](https://rich.readthedocs.io/en/stable/progress.html) to show a progress bar, for example:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nimport time\n\nimport typer\nfrom rich.progress import track\n\ndef main():\n    total = 0\n    for value in track(range(100), description=\"Processing...\"):\n        # Fake processing time\n        time.sleep(0.01)\n        total += 1\n    print(f\"Processed {total} things.\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nYou put the thing that you want to iterate over inside of Rich's `track()`, and then iterate over that.\n\nCheck it:\n\n```\n\nfast →python main.py\n\nProcessed 100 things.\n\nrestart ↻\n```\n\n...actually, it will look a lot prettier. ✨ But I can't show you the animation here in the docs. 😅\n\nThe colors and information will look something like this:\n\n```\n\nfast →python main.py\nProcessing... ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━╸━━━━━━━━━━  74% 0:00:01\n\nrestart ↻\n```\n\n## Spinner [¶](https://typer.tiangolo.com/tutorial/progressbar/\\#spinner \"Permanent link\")\n\nWhen you don't know how long the operation will take, you can use a spinner instead.\n\nRich allows you to display many things in complex and advanced ways.\n\nFor example, this will show two spinners:\n\n[Python 3.8+](#__tabbed_2_1)\n\n```md-code__content\nimport time\n\nimport typer\nfrom rich.progress import Progress, SpinnerColumn, TextColumn\n\ndef main():\n    with Progress(\n        SpinnerColumn(),\n        TextColumn(\"[progress.description]{task.description}\"),\n        transient=True,\n    ) as progress:\n        progress.add_task(description=\"Processing...\", total=None)\n        progress.add_task(description=\"Preparing...\", total=None)\n        time.sleep(5)\n    print(\"Done!\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nI can't show you the beautiful animation here in the docs. 😅\n\nBut at some point in time it will look like this (imagine it's spinning). 🤓\n\n```\n\nfast →python main.py\n⠹ Processing...\n⠹ Preparing...\n\nrestart ↻\n```\n\nYou can learn more about it in the [Rich docs for Progress Display](https://rich.readthedocs.io/en/stable/progress.html).\n\n## Typer `progressbar` [¶](https://typer.tiangolo.com/tutorial/progressbar/\\#typer-progressbar \"Permanent link\")\n\nIf you can, you should use **Rich** as explained above, it has more features, it's more advanced, and can display information more beautifully. ✨\n\nTip\n\nIf you can use Rich, use the information above, the Rich docs, and skip the rest of this page. 😎\n\nBut if you can't use Rich, Typer (actually Click) comes with a simple utility to show progress bars.\n\nInfo\n\n`typer.progressbar()` comes directly from Click, you can read more about it in [Click's docs](https://click.palletsprojects.com/en/8.1.x/utils/#showing-progress-bars).\n\n### Use `typer.progressbar` [¶](https://typer.tiangolo.com/tutorial/progressbar/\\#use-typerprogressbar \"Permanent link\")\n\nTip\n\nRemember, you are much better off using [Rich](https://rich.readthedocs.io/) for this. 😎\n\nYou can use `typer.progressbar()` with a `with` statement, as in:\n\n```md-code__content\nwith typer.progressbar(something) as progress:\n    pass\n\n```\n\nAnd you pass as function argument to `typer.progressbar()` the thing that you would normally iterate over.\n\n[Python 3.8+](#__tabbed_3_1)\n\n```md-code__content\nimport time\n\nimport typer\n\ndef main():\n    total = 0\n    with typer.progressbar(range(100)) as progress:\n        for value in progress:\n            # Fake processing time\n            time.sleep(0.01)\n            total += 1\n    print(f\"Processed {total} things.\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nSo, if you have a list of users, this could be:\n\n```md-code__content\nusers = [\"Camila\", \"Rick\", \"Morty\"]\n\nwith typer.progressbar(users) as progress:\n    pass\n\n```\n\nAnd the `with` statement using `typer.progressbar()` gives you an object that you can iterate over, just like if it was the same thing that you would iterate over normally.\n\nBut by iterating over this object **Typer** (actually Click) will know to update the progress bar:\n\n```md-code__content\nusers = [\"Camila\", \"Rick\", \"Morty\"]\n\nwith typer.progressbar(users) as progress:\n    for user in progress:\n        typer.echo(user)\n\n```\n\nTip\n\nNotice that there are 2 levels of code blocks. One for the `with` statement and one for the `for` statement.\n\nInfo\n\nThis is mostly useful for operations that take some time.\n\nIn the example above we are faking it with `time.sleep()`.\n\nCheck it:\n\n```\n\nfast →python main.py\n\nProcessed 100 things.\n\nrestart ↻\n```\n\n### Setting a Progress Bar `length` [¶](https://typer.tiangolo.com/tutorial/progressbar/\\#setting-a-progress-bar-length \"Permanent link\")\n\nTip\n\nRemember, you are much better off using [Rich](https://rich.readthedocs.io/) for this. 😎\n\nThe progress bar is generated from the length of the iterable (e.g. the list of users).\n\nBut if the length is not available (for example, with something that fetches a new user from a web API each time) you can pass an explicit `length` to `typer.progressbar()`.\n\n[Python 3.8+](#__tabbed_4_1)\n\n```md-code__content\nimport time\n\nimport typer\n\ndef iterate_user_ids():\n    # Let's imagine this is a web API, not a range()\n    for i in range(100):\n        yield i\n\ndef main():\n    total = 0\n    with typer.progressbar(iterate_user_ids(), length=100) as progress:\n        for value in progress:\n            # Fake processing time\n            time.sleep(0.01)\n            total += 1\n    print(f\"Processed {total} user IDs.\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nCheck it:\n\n```\n\nfast →python main.py\n\nProcessed 100 user IDs.\n\nrestart ↻\n```\n\n#### About the function with `yield` [¶](https://typer.tiangolo.com/tutorial/progressbar/\\#about-the-function-with-yield \"Permanent link\")\n\nIf you hadn't seen something like that `yield` above, that's a \" [generator](https://docs.python.org/3/glossary.html#term-generator)\".\n\nYou can iterate over that function with a `for` and at each iteration it will give you the value at `yield`.\n\n`yield` is like a `return` that gives values multiple times and let's you use the function in a `for` loop.\n\nFor example:\n\n```md-code__content\ndef iterate_user_ids():\n    # Let's imagine this is a web API, not a range()\n    for i in range(100):\n        yield i\n\nfor i in iterate_user_ids():\n    print(i)\n\n```\n\nwould print each of the \"user IDs\" (here it's just the numbers from `0` to `99`).\n\n### Add a `label` [¶](https://typer.tiangolo.com/tutorial/progressbar/\\#add-a-label \"Permanent link\")\n\nTip\n\nRemember, you are much better off using [Rich](https://rich.readthedocs.io/) for this. 😎\n\nYou can also set a `label`:\n\n[Python 3.8+](#__tabbed_5_1)\n\n```md-code__content\nimport time\n\nimport typer\n\ndef main():\n    total = 0\n    with typer.progressbar(range(100), label=\"Processing\") as progress:\n        for value in progress:\n            # Fake processing time\n            time.sleep(0.01)\n            total += 1\n    print(f\"Processed {total} things.\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nCheck it:\n\nfast →\n\n## Iterate manually [¶](https://typer.tiangolo.com/tutorial/progressbar/\\#iterate-manually \"Permanent link\")\n\nIf you need to manually iterate over something and update the progress bar irregularly, you can do it by not passing an iterable but just a `length` to `typer.progressbar()`.\n\nAnd then calling the `.update()` method in the object from the `with` statement:\n\n[Python 3.8+](#__tabbed_6_1)\n\n```md-code__content\nimport time\n\nimport typer\n\ndef main():\n    total = 1000\n    with typer.progressbar(length=total) as progress:\n        for batch in range(4):\n            # Fake processing time\n            time.sleep(1)\n            # Increment by 250 on each loop iteration\n            # (it will take 4 seconds to reach 1000)\n            progress.update(250)\n    print(f\"Processed {total} things in batches.\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nCheck it:\n\nfast →\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/progressbar/",
      "ogUrl": "https://typer.tiangolo.com/tutorial/progressbar/",
      "title": "Progress Bar - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/progressbar/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/progressbar.png",
      "ogTitle": "Progress Bar - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/progressbar.png",
      "og:title": "Progress Bar - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/progressbar/",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/progressbar.png",
      "twitter:title": "Progress Bar - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/subcommands/single-file/#subcommands-in-a-single-file)\n\n# SubCommands in a Single File [¶](https://typer.tiangolo.com/tutorial/subcommands/single-file/\\#subcommands-in-a-single-file \"Permanent link\")\n\nIn some cases, it's possible that your application code needs to live on a single file.\n\nYou can still use the same ideas:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\nitems_app = typer.Typer()\napp.add_typer(items_app, name=\"items\")\nusers_app = typer.Typer()\napp.add_typer(users_app, name=\"users\")\n\n@items_app.command(\"create\")\ndef items_create(item: str):\n    print(f\"Creating item: {item}\")\n\n@items_app.command(\"delete\")\ndef items_delete(item: str):\n    print(f\"Deleting item: {item}\")\n\n@items_app.command(\"sell\")\ndef items_sell(item: str):\n    print(f\"Selling item: {item}\")\n\n@users_app.command(\"create\")\ndef users_create(user_name: str):\n    print(f\"Creating user: {user_name}\")\n\n@users_app.command(\"delete\")\ndef users_delete(user_name: str):\n    print(f\"Deleting user: {user_name}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nThere are several things to notice here...\n\n## Apps at the top [¶](https://typer.tiangolo.com/tutorial/subcommands/single-file/\\#apps-at-the-top \"Permanent link\")\n\nFirst, you can create `typer.Typer()` objects and add them to another one at the top.\n\nIt doesn't have to be done after creating the subcommands:\n\n[Python 3.8+](#__tabbed_2_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\nitems_app = typer.Typer()\napp.add_typer(items_app, name=\"items\")\nusers_app = typer.Typer()\napp.add_typer(users_app, name=\"users\")\n\n@items_app.command(\"create\")\ndef items_create(item: str):\n    print(f\"Creating item: {item}\")\n\n@items_app.command(\"delete\")\ndef items_delete(item: str):\n    print(f\"Deleting item: {item}\")\n\n@items_app.command(\"sell\")\ndef items_sell(item: str):\n    print(f\"Selling item: {item}\")\n\n@users_app.command(\"create\")\ndef users_create(user_name: str):\n    print(f\"Creating user: {user_name}\")\n\n@users_app.command(\"delete\")\ndef users_delete(user_name: str):\n    print(f\"Deleting user: {user_name}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nYou can add the commands (subcommands) to each `typer.Typer()` app later and it will still work.\n\n## Function names [¶](https://typer.tiangolo.com/tutorial/subcommands/single-file/\\#function-names \"Permanent link\")\n\nAs you now have subcommands like `create` for `users` and for `items`, you can no longer call the functions with just the name, like `def create()`, because they would overwrite each other.\n\nSo we use longer names:\n\n[Python 3.8+](#__tabbed_3_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\nitems_app = typer.Typer()\napp.add_typer(items_app, name=\"items\")\nusers_app = typer.Typer()\napp.add_typer(users_app, name=\"users\")\n\n@items_app.command(\"create\")\ndef items_create(item: str):\n    print(f\"Creating item: {item}\")\n\n@items_app.command(\"delete\")\ndef items_delete(item: str):\n    print(f\"Deleting item: {item}\")\n\n@items_app.command(\"sell\")\ndef items_sell(item: str):\n    print(f\"Selling item: {item}\")\n\n@users_app.command(\"create\")\ndef users_create(user_name: str):\n    print(f\"Creating user: {user_name}\")\n\n@users_app.command(\"delete\")\ndef users_delete(user_name: str):\n    print(f\"Deleting user: {user_name}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\n## Command name [¶](https://typer.tiangolo.com/tutorial/subcommands/single-file/\\#command-name \"Permanent link\")\n\nWe are naming the functions with longer names so that they don't overwrite each other.\n\nBut we still want the subcommands to be `create`, `delete`, etc.\n\nTo call them like:\n\n```\n\nfast →💬 We want this ✔️python main.py items create\nrestart ↻\n```\n\ninstead of:\n\n```\n\nfast →💬 We don't want this ⛔️python main.py items items-create\nrestart ↻\n```\n\nSo we pass the name we want to use for each subcommand as the function argument to the decorator:\n\n[Python 3.8+](#__tabbed_4_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\nitems_app = typer.Typer()\napp.add_typer(items_app, name=\"items\")\nusers_app = typer.Typer()\napp.add_typer(users_app, name=\"users\")\n\n@items_app.command(\"create\")\ndef items_create(item: str):\n    print(f\"Creating item: {item}\")\n\n@items_app.command(\"delete\")\ndef items_delete(item: str):\n    print(f\"Deleting item: {item}\")\n\n@items_app.command(\"sell\")\ndef items_sell(item: str):\n    print(f\"Selling item: {item}\")\n\n@users_app.command(\"create\")\ndef users_create(user_name: str):\n    print(f\"Creating user: {user_name}\")\n\n@users_app.command(\"delete\")\ndef users_delete(user_name: str):\n    print(f\"Deleting user: {user_name}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\n## Check it [¶](https://typer.tiangolo.com/tutorial/subcommands/single-file/\\#check-it \"Permanent link\")\n\nIt still works the same:\n\n```\n\nfast →💬 Check the helppython main.py --help\nUsage: main.py [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  --install-completion  Install completion for the current shell.\n  --show-completion     Show completion for the current shell, to copy it or\n                        customize the installation.\n  --help                Show this message and exit.\n\nCommands:\n  items\n  users\n\nrestart ↻\n```\n\nCheck the `items` command:\n\n```\n\nfast →💬 Check the help for itemspython main.py items --help\n💬 It shows its own commands (subcommands): create, delete, sellUsage: main.py items [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  create\n  delete\n  sell\n\n💬 Try itpython main.py items create Wand\nCreating item: Wand\n\npython main.py items sell Vase\nSelling item: Vase\n\nrestart ↻\n```\n\nAnd the same for the `users` command:\n\n```\n\nfast →python main.py users --help\nUsage: main.py users [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  create\n  delete\n\n💬 Try itpython main.py users create Camila\nCreating user: Camila\n\nrestart ↻\n```\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/subcommands/single-file/",
      "ogUrl": "https://typer.tiangolo.com/tutorial/subcommands/single-file/",
      "title": "SubCommands in a Single File - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/subcommands/single-file/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/subcommands/single-file.png",
      "ogTitle": "SubCommands in a Single File - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/subcommands/single-file.png",
      "og:title": "SubCommands in a Single File - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/subcommands/single-file/",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/subcommands/single-file.png",
      "twitter:title": "SubCommands in a Single File - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/subcommands/callback-override/#sub-typer-callback-override)\n\n# Sub-Typer Callback Override [¶](https://typer.tiangolo.com/tutorial/subcommands/callback-override/\\#sub-typer-callback-override \"Permanent link\")\n\nWhen creating a **Typer** app you can define a callback function, it always executes and defines the _CLI arguments_ and _CLI options_ that go before a command.\n\nWhen adding a Typer app inside of another, the sub-Typer can also have its own callback.\n\nIt can handle any _CLI parameters_ that go before its own commands and execute any extra code:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\n\nusers_app = typer.Typer()\napp.add_typer(users_app, name=\"users\")\n\n@users_app.callback()\ndef users_callback():\n    print(\"Running a users command\")\n\n@users_app.command()\ndef create(name: str):\n    print(f\"Creating user: {name}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nIn this case it doesn't define any _CLI parameters_, it just writes a message.\n\nCheck it:\n\n```\n\nfast →python main.py users create Camila\n💬 Notice the first message is not created by the command function but by the callbackRunning a users command\nCreating user: Camila\n\nrestart ↻\n```\n\n## Add a callback on creation [¶](https://typer.tiangolo.com/tutorial/subcommands/callback-override/\\#add-a-callback-on-creation \"Permanent link\")\n\nIt's also possible to add a callback when creating the `typer.Typer()` app that will be added to another Typer app:\n\n[Python 3.8+](#__tabbed_2_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\n\ndef users_callback():\n    print(\"Running a users command\")\n\nusers_app = typer.Typer(callback=users_callback)\napp.add_typer(users_app, name=\"users\")\n\n@users_app.command()\ndef create(name: str):\n    print(f\"Creating user: {name}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nThis achieves exactly the same as above, it's just another place to add the callback.\n\nCheck it:\n\n```\n\nfast →python main.py users create Camila\nRunning a users command\nCreating user: Camila\n\nrestart ↻\n```\n\n## Overriding the callback on creation [¶](https://typer.tiangolo.com/tutorial/subcommands/callback-override/\\#overriding-the-callback-on-creation \"Permanent link\")\n\nIf a callback was added when creating the `typer.Typer()` app, it's possible to override it with a new one using `@app.callback()`.\n\nThis is the same information you saw on the section about [Commands - Typer Callback](https://typer.tiangolo.com/tutorial/commands/callback/), and it applies the same for sub-Typer apps:\n\n[Python 3.8+](#__tabbed_3_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\n\ndef default_callback():\n    print(\"Running a users command\")\n\nusers_app = typer.Typer(callback=default_callback)\napp.add_typer(users_app, name=\"users\")\n\n@users_app.callback()\ndef user_callback():\n    print(\"Callback override, running users command\")\n\n@users_app.command()\ndef create(name: str):\n    print(f\"Creating user: {name}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nHere we had defined a callback when creating the `typer.Typer()` sub-app, but then we override it with a new callback with the function `user_callback()`.\n\nAs `@app.callback()` takes precedence over `typer.Typer(callback=some_function)`, now our CLI app will use this new callback.\n\nCheck it:\n\n```\n\nfast →python main.py users create Camila\n💬 Notice the message from the new callbackCallback override, running users command\nCreating user: Camila\n\nrestart ↻\n```\n\n## Overriding the callback when adding a sub-Typer [¶](https://typer.tiangolo.com/tutorial/subcommands/callback-override/\\#overriding-the-callback-when-adding-a-sub-typer \"Permanent link\")\n\nLastly, you can override the callback defined anywhere else when adding a sub-Typer with `app.add_typer()` using the `callback` parameter.\n\nThis has the highest priority:\n\n[Python 3.8+](#__tabbed_4_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\n\ndef default_callback():\n    print(\"Running a users command\")\n\nusers_app = typer.Typer(callback=default_callback)\n\ndef callback_for_add_typer():\n    print(\"I have the high land! Running users command\")\n\napp.add_typer(users_app, name=\"users\", callback=callback_for_add_typer)\n\n@users_app.callback()\ndef user_callback():\n    print(\"Callback override, running users command\")\n\n@users_app.command()\ndef create(name: str):\n    print(f\"Creating user: {name}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nNotice that the precedence goes to `app.add_typer()` and is not affected by the order of execution. There's another callback defined below, but the one from `app.add_typer()` wins.\n\nNow when you use the CLI program it will use the new callback function `callback_for_add_typer()`.\n\nCheck it:\n\n```\n\nfast →python users create Camila\n💬 Notice the message from the callback added in add_typer()I have the high land! Running users command\nCreating user: Camila\n\nrestart ↻\n```\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/subcommands/callback-override/",
      "ogUrl": "https://typer.tiangolo.com/tutorial/subcommands/callback-override/",
      "title": "Sub-Typer Callback Override - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/subcommands/callback-override/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/subcommands/callback-override.png",
      "ogTitle": "Sub-Typer Callback Override - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/subcommands/callback-override.png",
      "og:title": "Sub-Typer Callback Override - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/subcommands/callback-override/",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/subcommands/callback-override.png",
      "twitter:title": "Sub-Typer Callback Override - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/arguments/help/#cli-arguments-with-help)\n\n# CLI Arguments with Help [¶](https://typer.tiangolo.com/tutorial/arguments/help/\\#cli-arguments-with-help \"Permanent link\")\n\nIn the _First Steps_ section you saw how to add help for a CLI app/command by adding it to a function's docstring.\n\nHere's how that last example looked like:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nimport typer\n\ndef main(name: str, lastname: str = \"\", formal: bool = False):\n    \"\"\"\n    Say hi to NAME, optionally with a --lastname.\n\n    If --formal is used, say hi very formally.\n    \"\"\"\n    if formal:\n        print(f\"Good day Ms. {name} {lastname}.\")\n    else:\n        print(f\"Hello {name} {lastname}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nNow that you also know how to use `typer.Argument()`, let's use it to add documentation specific for a _CLI argument_.\n\n## Add a `help` text for a _CLI argument_ [¶](https://typer.tiangolo.com/tutorial/arguments/help/\\#add-a-help-text-for-a-cli-argument \"Permanent link\")\n\nYou can use the `help` parameter to add a help text for a _CLI argument_:\n\n[Python 3.8+](#__tabbed_2_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(name: Annotated[str, typer.Argument(help=\"The name of the user to greet\")]):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_3_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(name: str = typer.Argument(..., help=\"The name of the user to greet\")):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nAnd it will be used in the automatic `--help` option:\n\n```\n\nfast →python main.py --help\n💬 Check the section with Arguments below 🚀Usage: main.py [OPTIONS] NAME\n\nArguments:\n  NAME  The name of the user to greet  [required]\n\nOptions:\n  --help                Show this message and exit.\n\nrestart ↻\n```\n\n## Combine help text and docstrings [¶](https://typer.tiangolo.com/tutorial/arguments/help/\\#combine-help-text-and-docstrings \"Permanent link\")\n\nAnd of course, you can also combine that `help` with the docstring:\n\n[Python 3.8+](#__tabbed_4_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(name: Annotated[str, typer.Argument(help=\"The name of the user to greet\")]):\n    \"\"\"\n    Say hi to NAME very gently, like Dirk.\n    \"\"\"\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_5_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(name: str = typer.Argument(..., help=\"The name of the user to greet\")):\n    \"\"\"\n    Say hi to NAME very gently, like Dirk.\n    \"\"\"\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nAnd the `--help` option will combine all the information:\n\n```\n\nfast →python main.py --help\n💬 Notice that we have the help text from the docstring and also the Arguments 📝Usage: main.py [OPTIONS] NAME\n\n  Say hi to NAME very gently, like Dirk.\n\nArguments:\n  NAME  The name of the user to greet  [required]\n\nOptions:\n  --help                Show this message and exit.\n\nrestart ↻\n```\n\n## Help with defaults [¶](https://typer.tiangolo.com/tutorial/arguments/help/\\#help-with-defaults \"Permanent link\")\n\nIf you have a _CLI argument_ with a default value, like `\"World\"`:\n\n[Python 3.8+](#__tabbed_6_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(name: Annotated[str, typer.Argument(help=\"Who to greet\")] = \"World\"):\n    \"\"\"\n    Say hi to NAME very gently, like Dirk.\n    \"\"\"\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_7_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(name: str = typer.Argument(\"World\", help=\"Who to greet\")):\n    \"\"\"\n    Say hi to NAME very gently, like Dirk.\n    \"\"\"\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nIt will show that default value in the help text:\n\n```\n\nfast →python main.py --help\n💬 Notice the [default: World] 🔍Usage: main.py [OPTIONS] [NAME]\n\n  Say hi to NAME very gently, like Dirk.\n\nArguments:\n  [NAME]  Who to greet  [default: World]\n\nOptions:\n  --help                Show this message and exit.\n\nrestart ↻\n```\n\nBut you can disable that if you want to, with `show_default=False`:\n\n[Python 3.8+](#__tabbed_8_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(\n    name: Annotated[\\\n        str, typer.Argument(help=\"Who to greet\", show_default=False)\\\n    ] = \"World\",\n):\n    \"\"\"\n    Say hi to NAME very gently, like Dirk.\n    \"\"\"\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_9_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(name: str = typer.Argument(\"World\", help=\"Who to greet\", show_default=False)):\n    \"\"\"\n    Say hi to NAME very gently, like Dirk.\n    \"\"\"\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nAnd then it won't show the default value:\n\n```\n\nfast →python main.py --help\n💬 Notice the there's no [default: World] now 🔥Usage: main.py [OPTIONS] [NAME]\n\n  Say hi to NAME very gently, like Dirk.\n\nArguments:\n  [NAME]  Who to greet\n\nOptions:\n  --help                Show this message and exit.\n\nrestart ↻\n```\n\nTechnical Details\n\nIn Click applications the default values are hidden by default. 🙈\n\nIn **Typer** these default values are shown by default. 👀\n\n## Custom default string [¶](https://typer.tiangolo.com/tutorial/arguments/help/\\#custom-default-string \"Permanent link\")\n\nYou can use the same `show_default` to pass a custom string (instead of a `bool`) to customize the default value to be shown in the help text:\n\n[Python 3.8+](#__tabbed_10_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(\n    name: Annotated[\\\n        str,\\\n        typer.Argument(\\\n            help=\"Who to greet\", show_default=\"Deadpoolio the amazing's name\"\\\n        ),\\\n    ] = \"Wade Wilson\",\n):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_11_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(\n    name: str = typer.Argument(\n        \"Wade Wilson\", help=\"Who to greet\", show_default=\"Deadpoolio the amazing's name\"\n    ),\n):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nAnd it will be used in the help text:\n\n```\n\nfast →python main.py --help\nUsage: main.py [OPTIONS] [NAME]\n\nArguments:\n  [NAME]  Who to greet  [default: (Deadpoolio the amazing's name)]\n\nOptions:\n  --help                Show this message and exit.\n\n💬 See it shows \"(Deadpoolio the amazing's name)\" instead of the actual default of \"Wade Wilson\"\nrestart ↻\n```\n\n## Custom help name ( `metavar`) [¶](https://typer.tiangolo.com/tutorial/arguments/help/\\#custom-help-name-metavar \"Permanent link\")\n\nYou can also customize the text used in the generated help text to represent a _CLI argument_.\n\nBy default, it will be the same name you declared, in uppercase letters.\n\nSo, if you declare it as:\n\n```md-code__content\nname: str\n\n```\n\nIt will be shown as:\n\n```md-code__content\nNAME\n\n```\n\nBut you can customize it with the `metavar` parameter for `typer.Argument()`.\n\nFor example, let's say you don't want to have the default of `NAME`, you want to have `username`, in lowercase, and you really want ✨ emojis ✨ everywhere:\n\n[Python 3.8+](#__tabbed_12_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(name: Annotated[str, typer.Argument(metavar=\"✨username✨\")] = \"World\"):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_13_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(name: str = typer.Argument(\"World\", metavar=\"✨username✨\")):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nNow the generated help text will have `✨username✨` instead of `NAME`:\n\n```\n\nfast →python main.py --help\nUsage: main.py [OPTIONS] ✨username✨\n\nArguments:\n  ✨username✨  [default: World]\n\nOptions:\n  --help                Show this message and exit.\n\nrestart ↻\n```\n\n## _CLI Argument_ help panels [¶](https://typer.tiangolo.com/tutorial/arguments/help/\\#cli-argument-help-panels \"Permanent link\")\n\nYou might want to show the help information for _CLI arguments_ in different panels when using the `--help` option.\n\nIf you have installed Rich as described in the docs for [Printing and Colors](https://typer.tiangolo.com/tutorial/printing/), you can set the `rich_help_panel` parameter to the name of the panel where you want this _CLI argument_ to be shown:\n\n[Python 3.8+](#__tabbed_14_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(\n    name: Annotated[str, typer.Argument(help=\"Who to greet\")],\n    lastname: Annotated[\\\n        str, typer.Argument(help=\"The last name\", rich_help_panel=\"Secondary Arguments\")\\\n    ] = \"\",\n    age: Annotated[\\\n        str,\\\n        typer.Argument(help=\"The user's age\", rich_help_panel=\"Secondary Arguments\"),\\\n    ] = \"\",\n):\n    \"\"\"\n    Say hi to NAME very gently, like Dirk.\n    \"\"\"\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_15_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(\n    name: str = typer.Argument(..., help=\"Who to greet\"),\n    lastname: str = typer.Argument(\n        \"\", help=\"The last name\", rich_help_panel=\"Secondary Arguments\"\n    ),\n    age: str = typer.Argument(\n        \"\", help=\"The user's age\", rich_help_panel=\"Secondary Arguments\"\n    ),\n):\n    \"\"\"\n    Say hi to NAME very gently, like Dirk.\n    \"\"\"\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nThen, if you check the `--help` option, you will see a default panel named \" `Arguments`\" for the _CLI arguments_ that don't have a custom `rich_help_panel`.\n\nAnd next you will see other panels for the _CLI arguments_ that have a custom panel set in the `rich_help_panel` parameter:\n\n```\n\nfast →python main.py --help\n Usage: main.py [OPTIONS] NAME [LASTNAME] [AGE]\n\n Say hi to NAME very gently, like Dirk.\n\n╭─ Arguments ───────────────────────────────────────────────────────╮\n│ *    name      TEXT  Who to greet [default: None] [required]      │\n╰───────────────────────────────────────────────────────────────────╯\n╭─ Secondary Arguments ─────────────────────────────────────────────╮\n│   lastname      [LASTNAME]  The last name                         │\n│   age           [AGE]       The user's age                        │\n╰───────────────────────────────────────────────────────────────────╯\n╭─ Options ─────────────────────────────────────────────────────────╮\n│ --help                        Show this message and exit.         │\n╰───────────────────────────────────────────────────────────────────╯\n\nrestart ↻\n```\n\nIn this example we have a custom _CLI arguments_ panel named \" `Secondary Arguments`\".\n\n## Help with style using Rich [¶](https://typer.tiangolo.com/tutorial/arguments/help/\\#help-with-style-using-rich \"Permanent link\")\n\nIn a future section you will see how to use custom markup in the `help` for _CLI arguments_ when reading about [Commands - Command Help](https://typer.tiangolo.com/tutorial/commands/help/#rich-markdown-and-markup).\n\nIf you are in a hurry you can jump there, but otherwise, it would be better to continue reading here and following the tutorial in order.\n\n## Hide a _CLI argument_ from the help text [¶](https://typer.tiangolo.com/tutorial/arguments/help/\\#hide-a-cli-argument-from-the-help-text \"Permanent link\")\n\nIf you want, you can make a _CLI argument_ **not** show up in the `Arguments` section in the help text.\n\nYou will probably not want to do this normally, but it's possible:\n\n[Python 3.8+](#__tabbed_16_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(name: Annotated[str, typer.Argument(hidden=True)] = \"World\"):\n    \"\"\"\n    Say hi to NAME very gently, like Dirk.\n    \"\"\"\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_17_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(name: str = typer.Argument(\"World\", hidden=True)):\n    \"\"\"\n    Say hi to NAME very gently, like Dirk.\n    \"\"\"\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nCheck it:\n\n```\n\nfast →python main.py --help\n💬 Notice there's no Arguments section at all 🔥Usage: main.py [OPTIONS] [NAME]\n\n  Say hi to NAME very gently, like Dirk.\n\nOptions:\n  --help                Show this message and exit.\n\nrestart ↻\n```\n\nInfo\n\nHave in mind that the _CLI argument_ will still show up in the first line with `Usage`.\n\nBut it won't show up in the main help text under the `Arguments` section.\n\n### Help text for _CLI arguments_ in Click [¶](https://typer.tiangolo.com/tutorial/arguments/help/\\#help-text-for-cli-arguments-in-click \"Permanent link\")\n\nClick itself doesn't support adding help for _CLI arguments_, and it doesn't generate help for them as in the \" `Arguments:`\" sections in the examples above.\n\nNot supporting `help` in _CLI arguments_ is an intentional [design decision in Click](https://click.palletsprojects.com/en/7.x/documentation/#documenting-arguments):\n\n> This is to follow the general convention of Unix tools of using arguments for only the most necessary things, and to document them in the command help text by referring to them by name.\n\nSo, in Click applications, you are expected to write all the documentation for _CLI arguments_ by hand in the docstring.\n\n* * *\n\nNevertheless, **Typer supports `help` for _CLI arguments_**. ✨ 🤷‍♂\n\n**Typer** doesn't follow that convention and instead supports `help` to make it easier to have consistent help texts with a consistent format for your CLI programs. 🎨\n\nThis is also to help you create CLI programs that are ✨ awesome ✨ _by default_. With very little code.\n\nIf you want to keep Click's convention in a **Typer** app, you can do it with the `hidden` parameter as described above.\n\nTechnical Details\n\nTo support `help` in _CLI arguments_ **Typer** does a lot of internal work in its own sub-classes of Click's internal classes.\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/arguments/help/",
      "ogUrl": "https://typer.tiangolo.com/tutorial/arguments/help/",
      "title": "CLI Arguments with Help - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/arguments/help/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/arguments/help.png",
      "ogTitle": "CLI Arguments with Help - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/arguments/help.png",
      "og:title": "CLI Arguments with Help - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/arguments/help/",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/arguments/help.png",
      "twitter:title": "CLI Arguments with Help - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/printing/#printing-and-colors)\n\n# Printing and Colors [¶](https://typer.tiangolo.com/tutorial/printing/\\#printing-and-colors \"Permanent link\")\n\nYou can use the normal `print()` to show information on the screen:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nimport typer\n\ndef main():\n    print(\"Hello World\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nIt will show the output normally:\n\n```\n\nfast →python main.py\nHello World\n\nrestart ↻\n```\n\n## Use Rich [¶](https://typer.tiangolo.com/tutorial/printing/\\#use-rich \"Permanent link\")\n\nYou can also display beautiful and more complex information using [Rich](https://rich.readthedocs.io/). It comes by default when you install `typer`.\n\n### Use Rich `print` [¶](https://typer.tiangolo.com/tutorial/printing/\\#use-rich-print \"Permanent link\")\n\nFor the simplest cases, you can just import `print` from `rich` and use it instead of the standard `print`:\n\n[Python 3.8+](#__tabbed_2_1)\n\n```md-code__content\nimport typer\nfrom rich import print\n\ndata = {\n    \"name\": \"Rick\",\n    \"age\": 42,\n    \"items\": [{\"name\": \"Portal Gun\"}, {\"name\": \"Plumbus\"}],\n    \"active\": True,\n    \"affiliation\": None,\n}\n\ndef main():\n    print(\"Here's the data\")\n    print(data)\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nJust with that, **Rich** will be able to print your data with nice colors and structure:\n\n```\n\nfast →python main.py\nHere's the data\n{\n    'name': 'Rick',\n    'age': 42,\n    'items': [\\\n        {'name': 'Portal Gun'},\\\n        {'name': 'Plumbus'}\\\n    ],\n    'active': True,\n    'affiliation': None\n}\n\nrestart ↻\n```\n\n### Rich Markup [¶](https://typer.tiangolo.com/tutorial/printing/\\#rich-markup \"Permanent link\")\n\nRich also supports a [custom markup syntax](https://rich.readthedocs.io/en/stable/markup.html) to set colors and styles, for example:\n\n[Python 3.8+](#__tabbed_3_1)\n\n```md-code__content\nimport typer\nfrom rich import print\n\ndef main():\n    print(\"[bold red]Alert![/bold red] [green]Portal gun[/green] shooting! :boom:\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n```\n\nfast →python main.py\nAlert! Portal gun shooting! 💥\n\nrestart ↻\n```\n\nIn this example you can see how to use font styles, colors, and even emojis.\n\nTo learn more check out the [Rich docs](https://rich.readthedocs.io/en/stable/markup.html).\n\n### Rich Tables [¶](https://typer.tiangolo.com/tutorial/printing/\\#rich-tables \"Permanent link\")\n\nThe way Rich works internally is that it uses a `Console` object to display the information.\n\nWhen you call Rich's `print`, it automatically creates this object and uses it.\n\nBut for advanced use cases, you could create a `Console` yourself.\n\n[Python 3.8+](#__tabbed_4_1)\n\n```md-code__content\nimport typer\nfrom rich.console import Console\nfrom rich.table import Table\n\nconsole = Console()\n\ndef main():\n    table = Table(\"Name\", \"Item\")\n    table.add_row(\"Rick\", \"Portal Gun\")\n    table.add_row(\"Morty\", \"Plumbus\")\n    console.print(table)\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nIn this example, we create a `Console`, and a `Table`. And then we can add some rows to the table, and print it.\n\nIf you run it, you will see a nicely formatted table:\n\n```\n\nfast →python main.py\n┏━━━━━━━┳━━━━━━━━━━━━┓\n┃ Name  ┃ Item       ┃\n┡━━━━━━━╇━━━━━━━━━━━━┩\n│ Rick  │ Portal Gun │\n│ Morty │ Plumbus    │\n└───────┴────────────┘\n\nrestart ↻\n```\n\nRich has many other features, as an example, you can check the docs for:\n\n- [Prompt](https://rich.readthedocs.io/en/stable/prompt.html)\n- [Markdown](https://rich.readthedocs.io/en/stable/markdown.html)\n- [Panel](https://rich.readthedocs.io/en/stable/panel.html)\n- ...and more.\n\n### Typer and Rich [¶](https://typer.tiangolo.com/tutorial/printing/\\#typer-and-rich \"Permanent link\")\n\nIf you are wondering what tool should be used for what, **Typer** is useful for structuring the command line application, with options, arguments, subcommands, data validation, etc.\n\nIn general, **Typer** tends to be the entry point to your program, taking the first input from the user.\n\n**Rich** is useful for the parts that need to _display_ information. Showing beautiful content on the screen.\n\nThe best results for your command line application would be achieved combining both **Typer** and **Rich**.\n\n## \"Standard Output\" and \"Standard Error\" [¶](https://typer.tiangolo.com/tutorial/printing/\\#standard-output-and-standard-error \"Permanent link\")\n\nThe way printing works underneath is that the **operating system** (Linux, Windows, macOS) treats what we print as if our CLI program was **writing text** to a \" **virtual file**\" called \" **standard output**\".\n\nWhen our code \"prints\" things it is actually \"writing\" to this \"virtual file\" of \"standard output\".\n\nThis might seem strange, but that's how the CLI program and the operating system interact with each other.\n\nAnd then the operating system **shows on the screen** whatever our CLI program \" **wrote**\" to that \" **virtual file**\" called \" **standard output**\".\n\n### Standard Error [¶](https://typer.tiangolo.com/tutorial/printing/\\#standard-error \"Permanent link\")\n\nAnd there's another \" **virtual file**\" called \" **standard error**\" that is normally only used for errors.\n\nBut we can also \"print\" to \"standard error\". And both are shown on the terminal to the users.\n\nInfo\n\nIf you use PowerShell it's quite possible that what you print to \"standard error\" won't be shown in the terminal.\n\nIn PowerShell, to see \"standard error\" you would have to check the variable `$Error`.\n\nBut it will work normally in Bash, Zsh, and Fish.\n\n### Printing to \"standard error\" [¶](https://typer.tiangolo.com/tutorial/printing/\\#printing-to-standard-error \"Permanent link\")\n\nYou can print to \"standard error\" creating a Rich `Console` with `stderr=True`.\n\nTip\n\n`stderr` is short for \"standard error\".\n\nUsing `stderr=True` tells **Rich** that the output should be shown in \"standard error\".\n\n[Python 3.8+](#__tabbed_5_1)\n\n```md-code__content\nimport typer\nfrom rich.console import Console\n\nerr_console = Console(stderr=True)\n\ndef main():\n    err_console.print(\"Here is something written to standard error\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nWhen you try it in the terminal, it will probably just look the same:\n\n```\n\nfast →python main.py\nHere is something written to standard error\n\nrestart ↻\n```\n\n## \"Standard Input\" [¶](https://typer.tiangolo.com/tutorial/printing/\\#standard-input \"Permanent link\")\n\nAs a final detail, when you type text in your keyboard to your terminal, the operating system also considers it another \" **virtual file**\" that you are writing text to.\n\nThis virtual file is called \" **standard input**\".\n\n### What is this for [¶](https://typer.tiangolo.com/tutorial/printing/\\#what-is-this-for \"Permanent link\")\n\nRight now this probably seems quite useless 🤷‍♂.\n\nBut understanding that will come handy in the future, for example for autocompletion and testing.\n\n## Typer Echo [¶](https://typer.tiangolo.com/tutorial/printing/\\#typer-echo \"Permanent link\")\n\nWarning\n\nIn most of the cases, for displaying advanced information, it is recommended to use [Rich](https://rich.readthedocs.io/).\n\nYou can probably skip the rest of this section. 🎉😎\n\n**Typer** also has a small utility `typer.echo()` to print information on the screen, it comes directly from Click. But normally you shouldn't need it.\n\nFor the simplest cases, you can use the standard Python `print()`.\n\nAnd for the cases where you want to display data more beautifully, or more advanced content, you should use **Rich** instead.\n\n### Why `typer.echo` [¶](https://typer.tiangolo.com/tutorial/printing/\\#why-typerecho \"Permanent link\")\n\n`typer.echo()` (which is actually just `click.echo()`) applies some checks to try and convert binary data to strings, and other similar things.\n\nBut in most of the cases you wouldn't need it, as in modern Python strings ( `str`) already support and use Unicode, and you would rarely deal with pure `bytes` that you want to print on the screen.\n\nIf you have some `bytes` objects, you would probably want to decode them intentionally and directly before trying to print them.\n\nAnd if you want to print data with colors and other features, you are much better off with the more advanced tools in **Rich**.\n\nInfo\n\n`typer.echo()` comes directly from Click, you can read more about it in [Click's docs](https://click.palletsprojects.com/en/7.x/quickstart/#echoing).\n\n### Color [¶](https://typer.tiangolo.com/tutorial/printing/\\#color \"Permanent link\")\n\nTechnical Details\n\nThe way color works in terminals is by using some codes (ANSI escape sequences) as part of the text.\n\nSo, a colored text is still just a `str`.\n\nTip\n\nAgain, you are much better off using [Rich](https://rich.readthedocs.io/) for this. 😎\n\nYou can create colored strings to output to the terminal with `typer.style()`, that gives you `str` s that you can then pass to `typer.echo()`:\n\n[Python 3.8+](#__tabbed_6_1)\n\n```md-code__content\nimport typer\n\ndef main(good: bool = True):\n    message_start = \"everything is \"\n    if good:\n        ending = typer.style(\"good\", fg=typer.colors.GREEN, bold=True)\n    else:\n        ending = typer.style(\"bad\", fg=typer.colors.WHITE, bg=typer.colors.RED)\n    message = message_start + ending\n    typer.echo(message)\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nTip\n\nThe parameters `fg` and `bg` receive strings with the color names for the \"\\*\\*f\\*\\*ore\\*\\*g\\*\\*round\" and \"\\*\\*b\\*\\*ack\\*\\*g\\*\\*round\" colors. You could simply pass `fg=\"green\"` and `bg=\"red\"`.\n\nBut **Typer** provides them all as variables like `typer.colors.GREEN` just so you can use autocompletion while selecting them.\n\nCheck it:\n\nfast →\n\nYou can pass these function arguments to `typer.style()`:\n\n- `fg`: the foreground color.\n- `bg`: the background color.\n- `bold`: enable or disable bold mode.\n- `dim`: enable or disable dim mode. This is badly supported.\n- `underline`: enable or disable underline.\n- `blink`: enable or disable blinking.\n- `reverse`: enable or disable inverse rendering (foreground becomes background and the other way round).\n- `reset`: by default a reset-all code is added at the end of the string which means that styles do not carry over. This can be disabled to compose styles.\n\nInfo\n\nYou can read more about it in [Click's docs about `style()`](https://click.palletsprojects.com/en/7.x/api/#click.style)\n\n### `typer.secho()` \\- style and print [¶](https://typer.tiangolo.com/tutorial/printing/\\#typersecho-style-and-print \"Permanent link\")\n\nTip\n\nIn case you didn't see above, you are much better off using [Rich](https://rich.readthedocs.io/) for this. 😎\n\nThere's a shorter form to style and print at the same time with `typer.secho()` it's like `typer.echo()` but also adds style like `typer.style()`:\n\n[Python 3.8+](#__tabbed_7_1)\n\n```md-code__content\nimport typer\n\ndef main(name: str):\n    typer.secho(f\"Welcome here {name}\", fg=typer.colors.MAGENTA)\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nCheck it:\n\nfast →\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/printing/",
      "ogUrl": "https://typer.tiangolo.com/tutorial/printing/",
      "title": "Printing and Colors - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/printing/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/printing.png",
      "ogTitle": "Printing and Colors - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/printing.png",
      "og:title": "Printing and Colors - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/printing/",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/printing.png",
      "twitter:title": "Printing and Colors - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/app-dir/#cli-application-directory)\n\n# CLI Application Directory [¶](https://typer.tiangolo.com/tutorial/app-dir/\\#cli-application-directory \"Permanent link\")\n\nYou can get the application directory where you can, for example, save configuration files with `typer.get_app_dir()`:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nfrom pathlib import Path\n\nimport typer\n\nAPP_NAME = \"my-super-cli-app\"\n\ndef main():\n    app_dir = typer.get_app_dir(APP_NAME)\n    config_path: Path = Path(app_dir) / \"config.json\"\n    if not config_path.is_file():\n        print(\"Config file doesn't exist yet\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nIt will give you a directory for storing configurations appropriate for your CLI program for the current user in each operating system.\n\nCheck it:\n\n```\n\nfast →python main.py\nConfig file doesn't exist yet\n\nrestart ↻\n```\n\n## About `Path` [¶](https://typer.tiangolo.com/tutorial/app-dir/\\#about-path \"Permanent link\")\n\nIf you hadn't seen something like that:\n\n```md-code__content\nPath(app_dir) / \"config.json\"\n\n```\n\nA `Path` object can be used with `/` and it will convert it to the separator for the current system ( `/` for Unix systems and `\\` for Windows).\n\nIf the first element is a `Path` object the next ones (after the `/`) can be `str`.\n\nAnd it will create a new `Path` object from that.\n\nIf you want a quick guide on using `Path()` you can check [this post on Real Python](https://realpython.com/python-pathlib/) or [this post by Trey Hunner](https://treyhunner.com/2018/12/why-you-should-be-using-pathlib/).\n\nIn the code above, we are also explicitly declaring `config_path` as having type `Path` to help the editor provide completion and type checks:\n\n```md-code__content\nconfig_path: Path = Path(app_dir) / \"config.json\"\n\n```\n\nOtherwise it could think it's a sub-type (a `PurePath`) and stop providing completion for some methods.\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/app-dir/",
      "ogUrl": "https://typer.tiangolo.com/tutorial/app-dir/",
      "title": "CLI Application Directory - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/app-dir/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/app-dir.png",
      "ogTitle": "CLI Application Directory - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/app-dir.png",
      "og:title": "CLI Application Directory - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/app-dir/",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/app-dir.png",
      "twitter:title": "CLI Application Directory - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/arguments/envvar/#cli-arguments-with-environment-variables)\n\n# CLI Arguments with Environment Variables [¶](https://typer.tiangolo.com/tutorial/arguments/envvar/\\#cli-arguments-with-environment-variables \"Permanent link\")\n\nYou can also configure a _CLI argument_ to read a value from an environment variable if it is not provided in the command line as a _CLI argument_.\n\nTip\n\nYou can learn more about environment variables in the [Environment Variables](https://typer.tiangolo.com/environment-variables/) page.\n\nTo do that, use the `envvar` parameter for `typer.Argument()`:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(name: Annotated[str, typer.Argument(envvar=\"AWESOME_NAME\")] = \"World\"):\n    print(f\"Hello Mr. {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_2_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(name: str = typer.Argument(\"World\", envvar=\"AWESOME_NAME\")):\n    print(f\"Hello Mr. {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nIn this case, the _CLI argument_ `name` will have a default value of `\"World\"`, but will also read any value passed to the environment variable `AWESOME_NAME` if no value is provided in the command line:\n\n```\n\nfast →💬 Check the helppython main.py --help\nUsage: main.py [OPTIONS] [NAME]\n\nArguments:\n  [NAME]  [env var: AWESOME_NAME;default: World]\n\nOptions:\n  --help                Show this message and exit.\n\n💬 Call it without a CLI argumentpython main.py\nHello Mr. World\n\n💬 Now pass a value for the CLI argumentpython main.py Czernobog\nHello Mr. Czernobog\n\n💬 And now use the environment variableAWESOME_NAME=Wednesday python main.py\nHello Mr. Wednesday\n\n💬 CLI arguments take precedence over env varsAWESOME_NAME=Wednesday python main.py Czernobog\nHello Mr. Czernobog\n\nrestart ↻\n```\n\n## Multiple environment variables [¶](https://typer.tiangolo.com/tutorial/arguments/envvar/\\#multiple-environment-variables \"Permanent link\")\n\nYou are not restricted to a single environment variable, you can declare a list of environment variables that could be used to get a value if it was not passed in the command line:\n\n[Python 3.8+](#__tabbed_3_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(\n    name: Annotated[str, typer.Argument(envvar=[\"AWESOME_NAME\", \"GOD_NAME\"])] = \"World\",\n):\n    print(f\"Hello Mr. {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_4_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(name: str = typer.Argument(\"World\", envvar=[\"AWESOME_NAME\", \"GOD_NAME\"])):\n    print(f\"Hello Mr. {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nCheck it:\n\n```\n\nfast →💬 Check the helppython main.py --help\nUsage: main.py [OPTIONS] [NAME]\n\nArguments:\n  [NAME]  [env var: AWESOME_NAME, GOD_NAME;default: World]\n\nOptions:\n  --help                Show this message and exit.\n\n💬 Try the first env varAWESOME_NAME=Wednesday python main.py\nHello Mr. Wednesday\n\n💬 Try the second env varGOD_NAME=Anubis python main.py\nHello Mr. Anubis\n\nrestart ↻\n```\n\n## Hide an env var from the help text [¶](https://typer.tiangolo.com/tutorial/arguments/envvar/\\#hide-an-env-var-from-the-help-text \"Permanent link\")\n\nBy default, environment variables used will be shown in the help text, but you can disable them with `show_envvar=False`:\n\n[Python 3.8+](#__tabbed_5_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(\n    name: Annotated[\\\n        str, typer.Argument(envvar=\"AWESOME_NAME\", show_envvar=False)\\\n    ] = \"World\",\n):\n    print(f\"Hello Mr. {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_6_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(name: str = typer.Argument(\"World\", envvar=\"AWESOME_NAME\", show_envvar=False)):\n    print(f\"Hello Mr. {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nCheck it:\n\n```\n\nfast →//Check the helppython main.py --help\n💬 It won't show the env varUsage: main.py [OPTIONS] [NAME]\n\nArguments:\n  [NAME]  [default: World]\n\nOptions:\n  --help                Show this message and exit.\n\n💬 But it will still be able to use itAWESOME_NAME=Wednesday python main.py\nHello Mr. Wednesday\n\nrestart ↻\n```\n\nTechnical Details\n\nIn Click applications the env vars are hidden by default. 🙈\n\nIn **Typer** these env vars are shown by default. 👀\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/arguments/envvar/",
      "ogUrl": "https://typer.tiangolo.com/tutorial/arguments/envvar/",
      "title": "CLI Arguments with Environment Variables - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/arguments/envvar/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/arguments/envvar.png",
      "ogTitle": "CLI Arguments with Environment Variables - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/arguments/envvar.png",
      "og:title": "CLI Arguments with Environment Variables - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/arguments/envvar/",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/arguments/envvar.png",
      "twitter:title": "CLI Arguments with Environment Variables - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/exceptions/#exceptions-and-errors)\n\n# Exceptions and Errors [¶](https://typer.tiangolo.com/tutorial/exceptions/\\#exceptions-and-errors \"Permanent link\")\n\nWhen your code has errors and you run it, it will show the error and an exception.\n\nTyper does some tricks to help you detect those errors quickly.\n\n## Example Broken App [¶](https://typer.tiangolo.com/tutorial/exceptions/\\#example-broken-app \"Permanent link\")\n\nLet's take this example broken app:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nimport typer\n\ndef main(name: str = \"morty\"):\n    print(name + 3)\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nThis code is broken because you can't sum a string and a number ( `name + 3`).\n\n## Exceptions with Rich [¶](https://typer.tiangolo.com/tutorial/exceptions/\\#exceptions-with-rich \"Permanent link\")\n\nIf you have **Rich** installed (for example if you installed `\"typer[all]\"`), **Typer** will use it to automatically show you nicely printed errors.\n\nIt will **omit** all the parts of the traceback (the chain of things that called your function) that come from the internal parts in Typer and Click.\n\nSo, the error you see will be **much clearer** and simpler, to help you detect the problem in your code quickly:\n\n```\n\nfast →python main.py\n╭──────────────── Traceback (most recent call last) ────────────────╮\n│ /home/user/code/superapp/main.py:5 in main                        │\n│                                                                   │\n│    2                                                              │\n│    3                                                              │\n│    4 def main(name: str = \"morty\"):                               │\n│ ❱  5 │   print(name + 3)                                          │\n│    6                                                              │\n│    7                                                              │\n│    8 if __name__ == \"__main__\":                                   │\n│                                                                   │\n│ ╭──── locals ────╮                                                │\n│ │ name = 'morty' │                                                │\n│ ╰────────────────╯                                                │\n╰───────────────────────────────────────────────────────────────────╯\nTypeError: can only concatenate str (not \"int\") to str\n\nrestart ↻\n```\n\n## Exceptions without Rich [¶](https://typer.tiangolo.com/tutorial/exceptions/\\#exceptions-without-rich \"Permanent link\")\n\nIf you don't have Rich installed, Typer will still do some tricks to show you the information **as clearly as possible**:\n\n```\n\nfast →python main.py\nTraceback (most recent call last):\n\n  File \"main.py\", line 12, in\n    typer.run(main)\n\n  File \"main.py\", line 8, in main\n    print(name + 3)\n\nTypeError: can only concatenate str (not \"int\") to str\n\nrestart ↻\n```\n\n## Disable Local Variables for Security [¶](https://typer.tiangolo.com/tutorial/exceptions/\\#disable-local-variables-for-security \"Permanent link\")\n\nIf your Typer application handles **delicate information**, for example a **password**, a **key**, a **token**, then it could be problematic if the automatic errors show the value in those local variables.\n\nThis would be relevant in particular if your CLI application is being run on some CI (continuous integration) system that is recording the logs.\n\nThe default errors above, when using Rich, show a section with:\n\n```md-code__content\nname = 'morty'\n\n```\n\nIn this case, `name` is a local variable, it comes from a parameter passed to the function.\n\nBut if it was something like a password, you would have liked to hide it.\n\nIn that case, you can create the `typer.Typer()` application explicitly and set the parameter `pretty_exceptions_show_locals=False`:\n\n[Python 3.8+](#__tabbed_2_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer(pretty_exceptions_show_locals=False)\n\n@app.command()\ndef main(password: str):\n    print(password + 3)\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nAnd now when you run it, you will see the error without the local variables:\n\n```\n\nfast →python main.py supersecret\n╭──────────────── Traceback (most recent call last) ────────────────╮\n│ /home/user/code/superapp/main.py:8 in main                        │\n│                                                                   │\n│    5                                                              │\n│    6 @app.command()                                               │\n│    7 def main(password: str):                                     │\n│ ❱  8 │   print(password + 3)                                      │\n│    9                                                              │\n│   10                                                              │\n│   11 if __name__ == \"__main__\":                                   │\n╰───────────────────────────────────────────────────────────────────╯\nTypeError: can only concatenate str (not \"int\") to str\n\nrestart ↻\n```\n\nNote that you passed the password `supersecret`, but it's not shown anywhere in the error message.\n\nBeing able to see the values of local variables is normally very **helpful** to diagnose, **debug**, and fix problems, but if you are dealing with delicate information, now you know how to secure it. 🔒\n\n## Disable Short Output [¶](https://typer.tiangolo.com/tutorial/exceptions/\\#disable-short-output \"Permanent link\")\n\nIf you want to show the full exception, including the parts in Typer and Click, you can use the parameter `pretty_exceptions_short=False`:\n\n[Python 3.8+](#__tabbed_3_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer(pretty_exceptions_short=False)\n\n@app.command()\ndef main(name: str = \"morty\"):\n    print(name + 3)\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nNow when you run it, you will see the whole output:\n\n```\n\nfast →python main.py\n╭──────────────── Traceback (most recent call last) ────────────────╮\n│ /home/user/code/superapp/main.py:12 in <module>                   │\n│                                                                   │\n│    9                                                              │\n│   10                                                              │\n│   11 if __name__ == \"__main__\":                                   │\n│ ❱ 12 │   app()                                                    │\n│   13                                                              │\n│                                                                   │\n│ ╭─────────────────────────── locals ────────────────────────────╮ │\n│ │ __annotations__ = {}                                          │ │\n│ │    __builtins__ = <module 'builtins' (built-in)>              │ │\n│ │      __cached__ = None                                        │ │\n│ │         __doc__ = None                                        │ │\n│ │        __file__ = 'main.py'                                   │ │\n│ │      __loader__ = <_frozen_importlib_external.SourceFileLoad… │ │\n│ │                   object at 0x7f047db1c050>                   │ │\n│ │        __name__ = '__main__'                                  │ │\n│ │     __package__ = None                                        │ │\n│ │        __spec__ = None                                        │ │\n│ │             app = <typer.main.Typer object at 0x7f047db51d90> │ │\n│ │            main = <function main at 0x7f047db56830>           │ │\n│ │           typer = <module 'typer' from                        │ │\n│ │                   '/home/user/code/superapp/env/lib/python3.… │ │\n│ ╰───────────────────────────────────────────────────────────────╯ │\n│                                                                   │\n│ /home/user/code/superapp/env/lib/python3.7/site-packages/typer/ma │\n│ in.py:328 in __call__                                             │\n│                                                                   │\n│ /home/user/code/superapp/env/lib/python3.7/site-packages/typer/ma │\n│ in.py:311 in __call__                                             │\n│                                                                   │\n│ /home/user/code/superapp/env/lib/python3.7/site-packages/click/co │\n│ re.py:1130 in __call__                                            │\n│                                                                   │\n│ /home/user/code/superapp/env/lib/python3.7/site-packages/typer/co │\n│ re.py:723 in main                                                 │\n│                                                                   │\n│ /home/user/code/superapp/env/lib/python3.7/site-packages/typer/co │\n│ re.py:216 in _main                                                │\n│                                                                   │\n│ /home/user/code/superapp/env/lib/python3.7/site-packages/click/co │\n│ re.py:1404 in invoke                                              │\n│                                                                   │\n│ /home/user/code/superapp/env/lib/python3.7/site-packages/click/co │\n│ re.py:760 in invoke                                               │\n│                                                                   │\n│ /home/user/code/superapp/env/lib/python3.7/site-packages/typer/ma │\n│ in.py:683 in wrapper                                              │\n│                                                                   │\n│ /home/user/code/superapp/main.py:8 in main                        │\n│                                                                   │\n│    5                                                              │\n│    6 @app.command()                                               │\n│    7 def main(name: str = \"morty\"):                               │\n│ ❱  8 │   print(name + 3)                                          │\n│    9                                                              │\n│   10                                                              │\n│   11 if __name__ == \"__main__\":                                   │\n│                                                                   │\n│ ╭──── locals ────╮                                                │\n│ │ name = 'morty' │                                                │\n│ ╰────────────────╯                                                │\n╰───────────────────────────────────────────────────────────────────╯\nTypeError: can only concatenate str (not \"int\") to str\n\nrestart ↻\n```\n\n## Disable Pretty Exceptions [¶](https://typer.tiangolo.com/tutorial/exceptions/\\#disable-pretty-exceptions \"Permanent link\")\n\nYou can also entirely disable pretty exceptions with the parameter `pretty_exceptions_enable=False`:\n\n[Python 3.8+](#__tabbed_4_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer(pretty_exceptions_enable=False)\n\n@app.command()\ndef main(name: str = \"morty\"):\n    print(name + 3)\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nAnd now you will see the full standard exception as with any other Python program:\n\n```\n\nfast →python main.py\nTraceback (most recent call last):\n  File \"main.py\", line 12, in\n    app()\n  File \"/home/user/code/superapp/env/lib/python3.7/site-packages/typer/main.py\", line 328, in __call__\n    raise e\n  File \"/home/user/code/superapp/env/lib/python3.7/site-packages/typer/main.py\", line 311, in __call__\n    return get_command(self)(*args, **kwargs)\n  File \"/home/user/code/superapp/env/lib/python3.7/site-packages/click/core.py\", line 1130, in __call__\n    return self.main(*args, **kwargs)\n  File \"/home/user/code/superapp/env/lib/python3.7/site-packages/typer/core.py\", line 723, in main\n    **extra,\n  File \"/home/user/code/superapp/env/lib/python3.7/site-packages/typer/core.py\", line 216, in _main\n    rv = self.invoke(ctx)\n  File \"/home/user/code/superapp/env/lib/python3.7/site-packages/click/core.py\", line 1404, in invoke\n    return ctx.invoke(self.callback, **ctx.params)\n  File \"/home/user/code/superapp/env/lib/python3.7/site-packages/click/core.py\", line 760, in invoke\n    return __callback(*args, **kwargs)\n  File \"/home/user/code/superapp/env/lib/python3.7/site-packages/typer/main.py\", line 683, in wrapper\n    return callback(**use_params)  # type: ignore\n  File \"main.py\", line 8, in main\n    print(name + 3)\nTypeError: can only concatenate str (not \"int\") to str\n\nrestart ↻\n```\n\nYou could also achieve the same with the environment variable `_TYPER_STANDARD_TRACEBACK=1`.\n\nThis will work for any other Typer program too, in case you need to debug a problem in a Typer program made by someone else:\n\n```\n\nfast →export _TYPER_STANDARD_TRACEBACK=1python main.py\n\nTraceback (most recent call last):\n  File \"main.py\", line 12, in\n    app()\n  File \"/home/user/code/superapp/env/lib/python3.7/site-packages/typer/main.py\", line 328, in __call__\n    raise e\n  File \"/home/user/code/superapp/env/lib/python3.7/site-packages/typer/main.py\", line 311, in __call__\n    return get_command(self)(*args, **kwargs)\n  File \"/home/user/code/superapp/env/lib/python3.7/site-packages/click/core.py\", line 1130, in __call__\n    return self.main(*args, **kwargs)\n  File \"/home/user/code/superapp/env/lib/python3.7/site-packages/typer/core.py\", line 723, in main\n    **extra,\n  File \"/home/user/code/superapp/env/lib/python3.7/site-packages/typer/core.py\", line 216, in _main\n    rv = self.invoke(ctx)\n  File \"/home/user/code/superapp/env/lib/python3.7/site-packages/click/core.py\", line 1404, in invoke\n    return ctx.invoke(self.callback, **ctx.params)\n  File \"/home/user/code/superapp/env/lib/python3.7/site-packages/click/core.py\", line 760, in invoke\n    return __callback(*args, **kwargs)\n  File \"/home/user/code/superapp/env/lib/python3.7/site-packages/typer/main.py\", line 683, in wrapper\n    return callback(**use_params)  # type: ignore\n  File \"main.py\", line 8, in main\n    print(name + 3)\nTypeError: can only concatenate str (not \"int\") to str\n\nrestart ↻\n```\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/exceptions/",
      "ogUrl": "https://typer.tiangolo.com/tutorial/exceptions/",
      "title": "Exceptions and Errors - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/exceptions/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/exceptions.png",
      "ogTitle": "Exceptions and Errors - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/exceptions.png",
      "og:title": "Exceptions and Errors - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/exceptions/",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/exceptions.png",
      "twitter:title": "Exceptions and Errors - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/package/#building-a-package)\n\n# Building a Package [¶](https://typer.tiangolo.com/tutorial/package/\\#building-a-package \"Permanent link\")\n\nWhen you create a CLI program with **Typer** you probably want to create your own Python package.\n\nThat's what allows your users to install it and have it as an independent program that they can use in their terminal.\n\nAnd that's also required for shell auto completion to work (unless you use your program through `typer` command).\n\nNowadays, there are several ways and tools to create Python packages (what you install with `pip install something`).\n\nYou might even have your favorite already.\n\nHere's a very opinionated, short guide, showing one of the alternative ways of creating a Python package with a **Typer** app, from scratch.\n\nTip\n\nIf you already have a favorite way of creating Python packages, feel free to skip this.\n\n## Prerequisites [¶](https://typer.tiangolo.com/tutorial/package/\\#prerequisites \"Permanent link\")\n\nFor this guide we'll use [Poetry](https://python-poetry.org/).\n\nPoetry's docs are great, so go ahead, check them and install it.\n\n## Create a project [¶](https://typer.tiangolo.com/tutorial/package/\\#create-a-project \"Permanent link\")\n\nLet's say we want to create a CLI application called `portal-gun`.\n\nTo make sure your package doesn't collide with the package created by someone else, we'll name it with a prefix of your name.\n\nSo, if your name is Rick, we'll call it `rick-portal-gun`.\n\nCreate a project with Poetry:\n\n```\n\nfast →poetry new rick-portal-gun\nCreated package rick_portal_gun in rick-portal-gun\n\n💬 Enter the new project directorycd ./rick-portal-gun\n\nrestart ↻\n```\n\n## Dependencies and environment [¶](https://typer.tiangolo.com/tutorial/package/\\#dependencies-and-environment \"Permanent link\")\n\nAdd `typer` to your dependencies:\n\n```\n\nfast →poetry add typer\n💬 It creates a virtual environment for your projectCreating virtualenv rick-portal-gun-w31dJa0b-py3.10 in /home/rick/.cache/pypoetry/virtualenvs\nUsing version ^0.12.0 for typer\n\nUpdating dependencies\nResolving dependencies... (1.2s)\n\nPackage operations: 8 installs, 0 updates, 0 removals\n\n  - Installing mdurl (0.1.2)\n  - Installing markdown-it-py (3.0.0)\n  - Installing pygments (2.17.2)\n  - Installing click (8.1.7)\n  - Installing rich (13.7.1)\n  - Installing shellingham (1.5.4)\n  - Installing typing-extensions (4.11.0)\n  - Installing typer (0.12.3)\n\nWriting lock file\n\n💬 Activate that new virtual environmentpoetry shell\nSpawning shell within /home/rick/.cache/pypoetry/virtualenvs/rick-portal-gun-w31dJa0b-py3.10\n\n💬 Open an editor using this new environment, for example VS Codecode ./\nrestart ↻\n```\n\nYou can see that you have a generated project structure that looks like:\n\n```md-code__content\n.\n├── poetry.lock\n├── pyproject.toml\n├── README.md\n├── rick_portal_gun\n│   └── __init__.py\n└── tests\n    └── __init__.py\n\n```\n\n## Create your app [¶](https://typer.tiangolo.com/tutorial/package/\\#create-your-app \"Permanent link\")\n\nNow let's create an extremely simple **Typer** app.\n\nCreate a file `rick_portal_gun/main.py` with:\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\n\n@app.callback()\ndef callback():\n    \"\"\"\n    Awesome Portal Gun\n    \"\"\"\n\n@app.command()\ndef shoot():\n    \"\"\"\n    Shoot the portal gun\n    \"\"\"\n    typer.echo(\"Shooting portal gun\")\n\n@app.command()\ndef load():\n    \"\"\"\n    Load the portal gun\n    \"\"\"\n    typer.echo(\"Loading portal gun\")\n\n```\n\nTip\n\nAs we are creating an installable Python package, there's no need to add a section with `if __name__ == \"__main__\":`.\n\n## Modify the README [¶](https://typer.tiangolo.com/tutorial/package/\\#modify-the-readme \"Permanent link\")\n\nLet's change the README to have something like:\n\n```md-code__content\n# Portal Gun\n\nThe awesome Portal Gun\n\n```\n\n## Add a \"script\" [¶](https://typer.tiangolo.com/tutorial/package/\\#add-a-script \"Permanent link\")\n\nWe are creating a Python package that can be installed with `pip install`.\n\nBut we want it to provide a CLI program that can be executed in the shell.\n\nTo do that, we add a configuration to the `pyproject.toml` in the section `[tool.poetry.scripts]`:\n\n```md-code__content\n[tool.poetry]\nname = \"rick-portal-gun\"\nversion = \"0.1.0\"\ndescription = \"\"\nauthors = [\"Rick Sanchez <rick@example.com>\"]\nreadme = \"README.md\"\n\n[tool.poetry.scripts]\nrick-portal-gun = \"rick_portal_gun.main:app\"\n\n[tool.poetry.dependencies]\npython = \"^3.10\"\ntyper = \"^0.12.0\"\n\n[build-system]\nrequires = [\"poetry-core\"]\nbuild-backend = \"poetry.core.masonry.api\"\n\n```\n\nHere's what that line means:\n\n`rick-portal-gun`: will be the name of the CLI program. That's how we will call it in the terminal once it is installed. Like:\n\n```\n\nfast →rick-portal-gun\n💬 Something happens here ✨\nrestart ↻\n```\n\n`rick_portal_gun.main`, in the part `\"rick_portal_gun.main:app\"`, with underscores, refers to the Python module to import. That's what someone would use in a section like:\n\n```md-code__content\nfrom rick_portal_gun.main import # something goes here\n\n```\n\nThe `app` in `\"rick_portal_gun.main:app\"` is the thing to import from the module, and to call as a function, like:\n\n```md-code__content\nfrom rick_portal_gun.main import app\napp()\n\n```\n\nThat config section tells Poetry that when this package is installed we want it to create a command line program called `rick-portal-gun`.\n\nAnd that the object to call (like a function) is the one in the variable `app` inside of the module `rick_portal_gun.main`.\n\n## Install your package [¶](https://typer.tiangolo.com/tutorial/package/\\#install-your-package \"Permanent link\")\n\nThat's what we need to create a package.\n\nYou can now install it:\n\n```\n\nfast →poetry install\nInstalling dependencies from lock file\n\nNo dependencies to install or update\n\n  - Installing the current project: rick-portal-gun (0.1.0)\n\nrestart ↻\n```\n\n## Try your CLI program [¶](https://typer.tiangolo.com/tutorial/package/\\#try-your-cli-program \"Permanent link\")\n\nYour package is installed in the environment created by Poetry, but you can already use it.\n\n```\n\nfast →💬 You can use the which program to check which rick-portal-gun program is available (if any)which rick-portal-gun\n💬 You get the one from your environment/home/rick/.cache/pypoetry/virtualenvs/rick-portal-gun-w31dJa0b-py3.10/bin/rick-portal-gun\n\n💬 Try itrick-portal-gun --help\n💬 You get all the standard helpUsage: rick-portal-gun [OPTIONS] COMMAND [ARGS]...\n\n  Awesome Portal Gun\n\nOptions:\n  --install-completion  Install completion for the current shell.\n  --show-completion     Show completion for the current shell, to copy it or customize the installation.\n\n  --help                Show this message and exit.\n\nCommands:\n  load   Load the portal gun\n  shoot  Shoot the portal gun\n\nrestart ↻\n```\n\n## Create a wheel package [¶](https://typer.tiangolo.com/tutorial/package/\\#create-a-wheel-package \"Permanent link\")\n\nPython packages have a standard format called a \"wheel\". It's a file that ends in `.whl`.\n\nYou can create a wheel with Poetry:\n\n```\n\nfast →poetry build\nBuilding rick-portal-gun (0.1.0)\n - Building sdist\n - Built rick-portal-gun-0.1.0.tar.gz\n - Building wheel\n - Built rick_portal_gun-0.1.0-py3-none-any.whl\n\nrestart ↻\n```\n\nAfter that, if you check in your project directory, you should now have a couple of extra files at `./dist/`:\n\n```md-code__content\n.\n├── dist\n│   ├── rick_portal_gun-0.1.0-py3-none-any.whl\n│   └── rick-portal-gun-0.1.0.tar.gz\n├── pyproject.toml\n├── README.md\n├── ...\n\n```\n\nThe `.whl` is the wheel file. You can send that wheel file to anyone and they can use it to install your program (we'll see how to upload it to PyPI in a bit).\n\n## Test your wheel package [¶](https://typer.tiangolo.com/tutorial/package/\\#test-your-wheel-package \"Permanent link\")\n\nNow you can open another terminal and install that package from the file for your own user with:\n\n```\n\nfast →pip install --user /home/rick/rick-portal-gun/dist/rick_portal_gun-0.1.0-py3-none-any.whl\n\nrestart ↻\n```\n\nWarning\n\nThe `--user` is important, that ensures you install it in your user's directory and not in the global system.\n\nIf you installed it in the global system (e.g. with `sudo`) you could install a version of a library (e.g. a sub-dependency) that is incompatible with your system.\n\nTip\n\nBonus points if you use [`pipx`](https://github.com/pipxproject/pipx) to install it while keeping an isolated environment for your Python CLI programs 🚀\n\nNow you have your CLI program installed. And you can use it freely:\n\n```\n\nfast →rick-portal-gun shoot\n💬 It works 🎉Shooting portal gun\n\nrestart ↻\n```\n\nHaving it installed globally (and not in a single environment), you can now install completion globally for it:\n\n```\n\nfast →rick-portal-gun --install-completion\nzsh completion installed in /home/rick/.zshrc.\nCompletion will take effect once you restart the terminal.\n\nrestart ↻\n```\n\nTip\n\nIf you want to remove completion you can just delete the added line in that file.\n\nAnd after you restart the terminal you will get completion for your new CLI program:\n\n```\n\nfast →rick-portal-gun [TAB][TAB]\n💬 You get completion for your CLI program ✨load   -- Load the portal gun\nshoot  -- Shoot the portal gun\n\nrestart ↻\n```\n\n## Support `python -m` (optional) [¶](https://typer.tiangolo.com/tutorial/package/\\#support-python-m-optional \"Permanent link\")\n\nYou may have seen that you can call many Python modules as scripts with `python -m some-module`.\n\nFor example, one way to call `pip` is:\n\n```\n\nfast →pip install fastapi\nrestart ↻\n```\n\nBut you can also call Python with the `-m` _CLI Option_ and pass a module for it to execute as if it was a script, like:\n\n```\n\nfast →python -m pip install fastapi\nrestart ↻\n```\n\nHere we pass `pip` as the value for `-m`, so, Python will execute the module `pip` as if it was a script. And then it will pass the rest of the _CLI Parameters_ ( `install fastapi`) to it.\n\nThese two are more or less equivalent, the `install fastapi` will be passed to `pip`.\n\nTip\n\nIn the case of `pip`, in many occasions it's actually recommended that you run it with `python -m`, because if you create a virtual environment with its own `python`, that will ensure that you use the `pip` from _that_ environment.\n\n### Add a `__main__.py` [¶](https://typer.tiangolo.com/tutorial/package/\\#add-a-__main__py \"Permanent link\")\n\nYou can support that same style of calling the package/module for your own package, simply by adding a file `__main__.py`.\n\nPython will look for that file and execute it.\n\nThe file would live right beside `__init__.py`:\n\n```md-code__content\n.\n├── poetry.lock\n├── pyproject.toml\n├── README.md\n├── rick_portal_gun\n│   ├── __init__.py\n│   ├── __main__.py\n│   └── main.py\n└── tests\n    └── __init__.py\n\n```\n\nNo other file has to import it, you don't have to reference it in your `pyproject.toml` or anything else, it just works by default, as it is standard Python behavior.\n\nThen in that file you can execute your **Typer** program:\n\n```md-code__content\nfrom .main import app\napp()\n\n```\n\nNow, after installing your package, if you call it with `python -m` it will work (for the main part):\n\n```\n\nfast →python -m rick_portal_gun --help\nUsage: __main__.py [OPTIONS] COMMAND [ARGS]...\n\n  Awesome Portal Gun\n\nOptions:\n  --install-completion  Install completion for the current shell.\n  --show-completion     Show completion for the current shell, to copy it or customize the installation.\n\n  --help                Show this message and exit.\n\nCommands:\n  load   Load the portal gun\n  shoot  Shoot the portal gun\n\nrestart ↻\n```\n\nTip\n\nNotice that you have to pass the importable version of the package name, so `rick_portal_gun` instead of `rick-portal-gun`.\n\nThat works! 🚀 Sort of... 🤔\n\nSee the `__main__.py` in the help instead of `rick-portal-gun`? We'll fix that next.\n\n### Set a program name in `__main__.py` [¶](https://typer.tiangolo.com/tutorial/package/\\#set-a-program-name-in-__main__py \"Permanent link\")\n\nWe are setting the program name in the file `pyproject.toml` in the line like:\n\n```md-code__content\n[tool.poetry.scripts]\nrick-portal-gun = \"rick_portal_gun.main:app\"\n\n```\n\nBut when Python runs our package as a script with `python -m`, it doesn't have the information of the program name.\n\nSo, to fix the help text to use the correct program name when called with `python -m`, we can pass it to the app in `__main__.py`:\n\n```md-code__content\nfrom .main import app\napp(prog_name=\"rick-portal-gun\")\n\n```\n\nTip\n\nYou can pass all the arguments and keyword arguments you could pass to a Click application, including `prog_name`.\n\n```\n\nfast →python -m rick_portal_gun --help\nUsage: rick-portal-gun [OPTIONS] COMMAND [ARGS]...\n\n  Awesome Portal Gun\n\nOptions:\n  --install-completion  Install completion for the current shell.\n  --show-completion     Show completion for the current shell, to copy it or customize the installation.\n\n  --help                Show this message and exit.\n\nCommands:\n  load   Load the portal gun\n  shoot  Shoot the portal gun\n\nrestart ↻\n```\n\nGreat! That works correctly! 🎉 ✅\n\nNotice that now it uses `rick-portal-gun` instead of `__main__.py` in the help.\n\n### Autocompletion and `python -m` [¶](https://typer.tiangolo.com/tutorial/package/\\#autocompletion-and-python-m \"Permanent link\")\n\nHave in mind that TAB completion (shell auto-completion) won't work when using `python -m`.\n\nAuto-completion depends on the name of the program called, it's tied to each specific program name.\n\nSo, to have shell completion for `rick-portal-gun` you would have to call it directly:\n\n```\n\nfast →rick-portal-gun [TAB][TAB]\nrestart ↻\n```\n\nBut you can still support `python -m` for the cases where it's useful.\n\n## Publish to PyPI (optional) [¶](https://typer.tiangolo.com/tutorial/package/\\#publish-to-pypi-optional \"Permanent link\")\n\nYou can publish that new package to [PyPI](https://pypi.org/) to make it public, so others can install it easily.\n\nSo, go ahead and create an account there (it's free).\n\n### PyPI API token [¶](https://typer.tiangolo.com/tutorial/package/\\#pypi-api-token \"Permanent link\")\n\nTo do it, you first need to configure a PyPI auth token.\n\nLogin to [PyPI](https://pypi.org/).\n\nAnd then go to [https://pypi.org/manage/account/token/](https://pypi.org/manage/account/token/) to create a new token.\n\nLet's say your new API token is:\n\n```md-code__content\npypi-wubalubadubdub-deadbeef1234\n\n```\n\nNow configure Poetry to use this token with the command `poetry config pypi-token.pypi`:\n\n```\n\nfast →poetry config pypi-token.pypi pypi-wubalubadubdub-deadbeef1234💬 It won't show any output, but it's already configured\nrestart ↻\n```\n\n### Publish to PyPI [¶](https://typer.tiangolo.com/tutorial/package/\\#publish-to-pypi \"Permanent link\")\n\nNow you can publish your package with Poetry.\n\nYou could build the package (as we did above) and then publish later, or you could tell poetry to build it before publishing in one go:\n\n```\n\nfast →poetry publish --build\nyes\n\nBuilding rick-portal-gun (0.1.0)\n - Building sdist\n - Built rick-portal-gun-0.1.0.tar.gz\n - Building wheel\n - Built rick_portal_gun-0.1.0-py3-none-any.whl\n\nPublishing rick-portal-gun (0.1.0) to PyPI\n - Uploading rick-portal-gun-0.1.0.tar.gz 100%\n - Uploading rick_portal_gun-0.1.0-py3-none-any.whl 100%\n\nrestart ↻\n```\n\nNow you can go to PyPI and check your projects at [https://pypi.org/manage/projects/](https://pypi.org/manage/projects/).\n\nYou should now see your new \"rick-portal-gun\" package.\n\n### Install from PyPI [¶](https://typer.tiangolo.com/tutorial/package/\\#install-from-pypi \"Permanent link\")\n\nNow to see that we can install it form PyPI, open another terminal, and uninstall the currently installed package.\n\n```\n\nfast →pip uninstall rick-portal-gun\nFound existing installation: rick-portal-gun 0.1.0\nUninstalling rick-portal-gun-0.1.0:\n  Would remove:\n    /home/rick/.local/bin/rick-portal-gun\n    /home/rick/.local/lib/python3.10/site-packages/rick_portal_gun-0.1.0.dist-info/*\n    /home/rick/.local/lib/python3.10/site-packages/rick_portal_gun/*Y    Successfully uninstalled rick-portal-gun-0.1.0\n\nrestart ↻\n```\n\nAnd now install it again, but this time using just the name, so that `pip` pulls it from PyPI:\n\n```\n\nfast →pip install --user rick-portal-gun\n💬 Notice that it says \"Downloading\" 🚀Collecting rick-portal-gun\n  Downloading rick_portal_gun-0.1.0-py3-none-any.whl.metadata (435 bytes)\nRequirement already satisfied: typer<0.13.0,>=0.12.3 in ./.local/lib/python3.10/site-packages (from rick-portal-gun==0.1.0) (0.12.3)\nRequirement already satisfied: typing-extensions>=3.7.4.3 in ./.local/lib/python3.10/site-packages (from typer<0.13.0,>=0.12.3->rick-portal-gun==0.1.0) (4.11.0)\nRequirement already satisfied: click>=8.0.0 in ./.local/lib/python3.10/site-packages (from typer<0.13.0,>=0.12.3->rick-portal-gun==0.1.0) (8.1.7)\nRequirement already satisfied: shellingham>=1.3.0 in ./.local/lib/python3.10/site-packages (from typer<0.13.0,>=0.12.3->rick-portal-gun==0.1.0) (1.5.4)\nRequirement already satisfied: rich>=10.11.0 in ./.local/lib/python3.10/site-packages (from typer<0.13.0,>=0.12.3->rick-portal-gun==0.1.0) (13.7.1)\nRequirement already satisfied: pygments<3.0.0,>=2.13.0 in ./.local/lib/python3.10/site-packages (from rich>=10.11.0->typer<0.13.0,>=0.12.3->rick-portal-gun==0.1.0) (2.17.2)\nRequirement already satisfied: markdown-it-py>=2.2.0 in ./.local/lib/python3.10/site-packages (from rich>=10.11.0->typer<0.13.0,>=0.12.3->rick-portal-gun==0.1.0) (3.0.0)\nRequirement already satisfied: mdurl~=0.1 in ./.local/lib/python3.10/site-packages (from markdown-it-py>=2.2.0->rich>=10.11.0->typer<0.13.0,>=0.12.3->rick-portal-gun==0.1.0) (0.1.2)\nDownloading rick_portal_gun-0.1.0-py3-none-any.whl (1.8 kB)\nInstalling collected packages: rick-portal-gun\nSuccessfully installed rick-portal-gun-0.1.0\n\nrestart ↻\n```\n\nAnd now test the newly installed package from PyPI:\n\n```\n\nfast →rick-portal-gun load\n💬 It works! 🎉Loading portal gun\n\nrestart ↻\n```\n\n## Generate docs [¶](https://typer.tiangolo.com/tutorial/package/\\#generate-docs \"Permanent link\")\n\nYou can use the `typer` command to generate docs for your package that you can put in your `README.md`:\n\n```\n\nfast →typer rick_portal_gun.main utils docs --output README.md --name rick-portal-gun\nDocs saved to: README.md\n\nrestart ↻\n```\n\nYou just have to pass it the module to import ( `rick_portal_gun.main`) and it will detect the `typer.Typer` app automatically.\n\nBy specifying the `--name` of the program it will be able to use it while generating the docs.\n\nTip\n\nIf you installed `typer-slim` and don't have the `typer` command, you can use `python -m typer` instead.\n\n### Publish a new version with the docs [¶](https://typer.tiangolo.com/tutorial/package/\\#publish-a-new-version-with-the-docs \"Permanent link\")\n\nNow you can publish a new version with the updated docs.\n\nFor that you need to first increase the version in `pyproject.toml`:\n\n```md-code__content\n[tool.poetry]\nname = \"rick-portal-gun\"\nversion = \"0.2.0\"\ndescription = \"\"\nauthors = [\"Rick Sanchez <rick@example.com>\"]\nreadme = \"README.md\"\n\n[tool.poetry.scripts]\nrick-portal-gun = \"rick_portal_gun.main:app\"\n\n[tool.poetry.dependencies]\npython = \"^3.10\"\ntyper = \"^0.12.0\"\n\n[build-system]\nrequires = [\"poetry-core\"]\nbuild-backend = \"poetry.core.masonry.api\"\n\n```\n\nAnd in the file `rick_portal_gun/__init__.py`:\n\n```md-code__content\n__version__ = '0.2.0'\n\n```\n\nAnd then build and publish again:\n\n```\n\nfast →poetry publish --build\n\nBuilding rick-portal-gun (0.2.0)\n - Building sdist\n - Built rick-portal-gun-0.2.0.tar.gz\n - Building wheel\n - Built rick_portal_gun-0.2.0-py3-none-any.whl\n\nPublishing rick-portal-gun (0.2.0) to PyPI\n - Uploading rick-portal-gun-0.2.0.tar.gz 100%\n - Uploading rick_portal_gun-0.2.0-py3-none-any.whl 100%\n\nrestart ↻\n```\n\nAnd now you can go to PyPI, to the project page, and reload it, and it will now have your new generated docs.\n\n## What's next [¶](https://typer.tiangolo.com/tutorial/package/\\#whats-next \"Permanent link\")\n\nThis is a very simple guide. You could add many more steps.\n\nFor example, you should use [Git](https://git-scm.com/), the version control system, to save your code.\n\nYou can add a lot of extra metadata to your `pyproject.toml`, check the docs for [Poetry: Libraries](https://python-poetry.org/docs/libraries/).\n\nYou could use [`pipx`](https://github.com/pipxproject/pipx) to manage your installed CLI Python programs in isolated environments.\n\nMaybe use automatic formatting with [Black](https://github.com/psf/black).\n\nYou'll probably want to publish your code as open source to [GitHub](https://github.com/).\n\nAnd then you could integrate a CI tool to run your tests and deploy your package automatically.\n\nAnd there's a long etc. But now you have the basics and you can continue on your own 🚀.\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/package/",
      "ogUrl": "https://typer.tiangolo.com/tutorial/package/",
      "title": "Building a Package - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/package/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/package.png",
      "ogTitle": "Building a Package - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/package.png",
      "og:title": "Building a Package - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/package/",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/package.png",
      "twitter:title": "Building a Package - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/options/required/#required-cli-options)\n\n# Required CLI Options [¶](https://typer.tiangolo.com/tutorial/options/required/\\#required-cli-options \"Permanent link\")\n\nWe said before that _by default_:\n\n- _CLI options_ are **optional**\n- _CLI arguments_ are **required**\n\nWell, that's how they work _by default_, and that's the convention in many CLI programs and systems.\n\nBut if you really want, you can change that.\n\nTo make a _CLI option_ required, you can put `typer.Option()` inside of `Annotated` and leave the parameter without a default value.\n\nLet's make `--lastname` a required _CLI option_:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(name: str, lastname: Annotated[str, typer.Option()]):\n    print(f\"Hello {name} {lastname}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_2_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(name: str, lastname: str = typer.Option()):\n    print(f\"Hello {name} {lastname}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nThe same way as with `typer.Argument()`, the old style of using the function parameter default value is also supported, in that case you would just not pass anything to the `default` parameter.\n\n[Python 3.8+ - non-Annotated](#__tabbed_3_1)\n\n```md-code__content\nimport typer\n\ndef main(name: str, lastname: str = typer.Option()):\n    print(f\"Hello {name} {lastname}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+](#__tabbed_4_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(name: str, lastname: Annotated[str, typer.Option()]):\n    print(f\"Hello {name} {lastname}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nOr you can explicitly pass `...` to `typer.Option(default=...)`:\n\n[Python 3.8+](#__tabbed_5_1)\n\n```md-code__content\nimport typer\n\ndef main(name: str, lastname: str = typer.Option(default=...)):\n    print(f\"Hello {name} {lastname}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nInfo\n\nIf you hadn't seen that `...` before: it is a special single value, it is [part of Python and is called \"Ellipsis\"](https://docs.python.org/3/library/constants.html#Ellipsis).\n\nThat will tell **Typer** that it's still a _CLI option_, but it doesn't have a default value, and it's required.\n\nTip\n\nAgain, prefer to use the `Annotated` version if possible. That way your code will mean the same in standard Python and in **Typer**.\n\nAnd test it:\n\n```\n\nfast →💬 Pass the NAME CLI argumentpython main.py Camila\n💬 We didn't pass the now required --lastname CLI optionUsage: main.py [OPTIONS] NAME\nTry \"main.py --help\" for help.\n\nError: Missing option '--lastname'.\n\n💬 Now update it to pass the required --lastname CLI optionpython main.py Camila --lastname Gutiérrez\nHello Camila Gutiérrez\n\n💬 And if you check the helppython main.py --help\nUsage: main.py [OPTIONS] NAME\n\nOptions:\n  --lastname TEXT       [required]\n  --help                Show this message and exit.\n\n💬 It now tells you that --lastname is required 🎉\nrestart ↻\n```\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/options/required/",
      "ogUrl": "https://typer.tiangolo.com/tutorial/options/required/",
      "title": "Required CLI Options - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/options/required/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/options/required.png",
      "ogTitle": "Required CLI Options - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/options/required.png",
      "og:title": "Required CLI Options - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/options/required/",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/options/required.png",
      "twitter:title": "Required CLI Options - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/multiple-values/multiple-options/#multiple-cli-options)\n\n# Multiple CLI Options [¶](https://typer.tiangolo.com/tutorial/multiple-values/multiple-options/\\#multiple-cli-options \"Permanent link\")\n\nYou can declare a _CLI option_ that can be used multiple times, and then get all the values.\n\nFor example, let's say you want to accept several users in a single execution.\n\nFor this, use the standard Python `typing.List` to declare it as a `list` of `str`:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nfrom typing import List, Optional\n\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(user: Annotated[Optional[List[str]], typer.Option()] = None):\n    if not user:\n        print(f\"No provided users (raw input = {user})\")\n        raise typer.Abort()\n    for u in user:\n        print(f\"Processing user: {u}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_2_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nfrom typing import List, Optional\n\nimport typer\n\ndef main(user: Optional[List[str]] = typer.Option(None)):\n    if not user:\n        print(f\"No provided users (raw input = {user})\")\n        raise typer.Abort()\n    for u in user:\n        print(f\"Processing user: {u}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nYou will receive the values as you declared them, as a `list` of `str`.\n\nCheck it:\n\n```\n\nfast →💬 The default value is 'None'python main.py\nNo provided users (raw input = None)\nAborted!\n\n💬 Now pass a userpython main.py --user Camila\nProcessing user: Camila\n\n💬 And now try with several userspython main.py --user Camila --user Rick --user Morty\nProcessing user: Camila\nProcessing user: Rick\nProcessing user: Morty\n\nrestart ↻\n```\n\n## Multiple `float` [¶](https://typer.tiangolo.com/tutorial/multiple-values/multiple-options/\\#multiple-float \"Permanent link\")\n\nThe same way, you can use other types and they will be converted by **Typer** to their declared type:\n\n[Python 3.8+](#__tabbed_3_1)\n\n```md-code__content\nfrom typing import List\n\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(number: Annotated[List[float], typer.Option()] = []):\n    print(f\"The sum is {sum(number)}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_4_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nfrom typing import List\n\nimport typer\n\ndef main(number: List[float] = typer.Option([])):\n    print(f\"The sum is {sum(number)}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nCheck it:\n\n```\n\nfast →python main.py\nThe sum is 0\n\n💬 Try with some numberspython main.py --number 2\nThe sum is 2.0\n\n💬 Try with some numberspython main.py --number 2 --number 3 --number 4.5\nThe sum is 9.5\n\nrestart ↻\n```\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/multiple-values/multiple-options/",
      "ogUrl": "https://typer.tiangolo.com/tutorial/multiple-values/multiple-options/",
      "title": "Multiple CLI Options - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/multiple-values/multiple-options/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/multiple-values/multiple-options.png",
      "ogTitle": "Multiple CLI Options - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/multiple-values/multiple-options.png",
      "og:title": "Multiple CLI Options - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/multiple-values/multiple-options/",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/multiple-values/multiple-options.png",
      "twitter:title": "Multiple CLI Options - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/options/callback-and-context/#cli-option-callback-and-context)\n\n# CLI Option Callback and Context [¶](https://typer.tiangolo.com/tutorial/options/callback-and-context/\\#cli-option-callback-and-context \"Permanent link\")\n\nIn some occasions you might want to have some custom logic for a specific _CLI parameter_ (for a _CLI option_ or _CLI argument_) that is executed with the value received from the terminal.\n\nIn those cases you can use a _CLI parameter_ callback function.\n\n## Validate _CLI parameters_ [¶](https://typer.tiangolo.com/tutorial/options/callback-and-context/\\#validate-cli-parameters \"Permanent link\")\n\nFor example, you could do some validation before the rest of the code is executed.\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nfrom typing import Optional\n\nimport typer\nfrom typing_extensions import Annotated\n\ndef name_callback(value: str):\n    if value != \"Camila\":\n        raise typer.BadParameter(\"Only Camila is allowed\")\n    return value\n\ndef main(name: Annotated[Optional[str], typer.Option(callback=name_callback)] = None):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_2_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nfrom typing import Optional\n\nimport typer\n\ndef name_callback(value: str):\n    if value != \"Camila\":\n        raise typer.BadParameter(\"Only Camila is allowed\")\n    return value\n\ndef main(name: Optional[str] = typer.Option(default=None, callback=name_callback)):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nHere you pass a function to `typer.Option()` or `typer.Argument()` with the keyword argument `callback`.\n\nThe function receives the value from the command line. It can do anything with it, and then return the value.\n\nIn this case, if the `--name` is not `Camila` we raise a `typer.BadParameter()` exception.\n\nThe `BadParameter` exception is special, it shows the error with the parameter that generated it.\n\nCheck it:\n\n```\n\nfast →python main.py --name Camila\nHello Camila\n\npython main.py --name Rick\nUsage: main.py [OPTIONS]\n\n💬 We get the error from the callbackError: Invalid value for '--name': Only Camila is allowed\n\nrestart ↻\n```\n\n## Handling completion [¶](https://typer.tiangolo.com/tutorial/options/callback-and-context/\\#handling-completion \"Permanent link\")\n\nThere's something to be aware of with callbacks and completion that requires some small special handling.\n\nBut first let's just use completion in your shell (Bash, Zsh, Fish, or PowerShell).\n\nAfter installing completion (for your own Python package), when you use your CLI program and start adding a _CLI option_ with `--` an then hit `TAB`, your shell will show you the available _CLI options_ (the same for _CLI arguments_, etc).\n\nTo check it quickly with the previous script use the `typer` command:\n\n```\n\nfast →💬 Hit the TAB key in your keyboard below where you see the: [TAB]typer ./main.py [TAB][TAB]\n💬 Depending on your terminal/shell you will get some completion like this ✨run    -- Run the provided Typer app.\nutils  -- Extra utility commands for Typer apps.\n\n💬 Then try with \"run\" and --helptyper ./main.py run --help\n💬 You get a help text with your CLI options as you normally wouldUsage: typer run [OPTIONS]\n\n  Run the provided Typer app.\n\nOptions:\n  --name TEXT  [required]\n  --help       Show this message and exit.\n\n💬 Then try completion with your programtyper ./main.py run --[TAB][TAB]\n💬 You get completion for CLI options--help  -- Show this message and exit.\n--name\n\n💬 And you can run it as if it was with Python directlytyper ./main.py run --name Camila\nHello Camila\n\nrestart ↻\n```\n\n### How shell completion works [¶](https://typer.tiangolo.com/tutorial/options/callback-and-context/\\#how-shell-completion-works \"Permanent link\")\n\nThe way it works internally is that the shell/terminal will call your CLI program with some special environment variables (that hold the current _CLI parameters_, etc) and your CLI program will print some special values that the shell will use to present completion. All this is handled for you by **Typer** behind the scenes.\n\nBut the main **important point** is that it is all based on values printed by your program that the shell reads.\n\n### Breaking completion in a callback [¶](https://typer.tiangolo.com/tutorial/options/callback-and-context/\\#breaking-completion-in-a-callback \"Permanent link\")\n\nLet's say that when the callback is running, we want to show a message saying that it's validating the name:\n\n[Python 3.8+](#__tabbed_3_1)\n\n```md-code__content\nfrom typing import Optional\n\nimport typer\nfrom typing_extensions import Annotated\n\ndef name_callback(value: str):\n    print(\"Validating name\")\n    if value != \"Camila\":\n        raise typer.BadParameter(\"Only Camila is allowed\")\n    return value\n\ndef main(name: Annotated[Optional[str], typer.Option(callback=name_callback)] = None):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_4_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nfrom typing import Optional\n\nimport typer\n\ndef name_callback(value: str):\n    print(\"Validating name\")\n    if value != \"Camila\":\n        raise typer.BadParameter(\"Only Camila is allowed\")\n    return value\n\ndef main(name: Optional[str] = typer.Option(default=None, callback=name_callback)):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nAnd because the callback will be called when the shell calls your program asking for completion, that message `\"Validating name\"` will be printed and it will break completion.\n\nIt will look something like:\n\n```\n\nfast →💬 Run it normallytyper ./main.py run --name Camila\n💬 See the extra message \"Validating name\"Validating name\nHello Camila\n\ntyper ./main.py run --[TAB][TAB]\n💬 Some weird broken error message ⛔️(eval):1: command not found: Validating\nrutyper ./main.pyed Typer app.\n\nrestart ↻\n```\n\n### Fix completion - using the `Context` [¶](https://typer.tiangolo.com/tutorial/options/callback-and-context/\\#fix-completion-using-the-context \"Permanent link\")\n\nWhen you create a **Typer** application it uses Click underneath.\n\nAnd every Click application has a special object called a [\"Context\"](https://click.palletsprojects.com/en/7.x/commands/#nested-handling-and-contexts) that is normally hidden.\n\nBut you can access the context by declaring a function parameter of type `typer.Context`.\n\nThe \"context\" has some additional data about the current execution of your program:\n\n[Python 3.8+](#__tabbed_5_1)\n\n```md-code__content\nfrom typing import Optional\n\nimport typer\nfrom typing_extensions import Annotated\n\ndef name_callback(ctx: typer.Context, value: str):\n    if ctx.resilient_parsing:\n        return\n    print(\"Validating name\")\n    if value != \"Camila\":\n        raise typer.BadParameter(\"Only Camila is allowed\")\n    return value\n\ndef main(name: Annotated[Optional[str], typer.Option(callback=name_callback)] = None):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_6_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nfrom typing import Optional\n\nimport typer\n\ndef name_callback(ctx: typer.Context, value: str):\n    if ctx.resilient_parsing:\n        return\n    print(\"Validating name\")\n    if value != \"Camila\":\n        raise typer.BadParameter(\"Only Camila is allowed\")\n    return value\n\ndef main(name: Optional[str] = typer.Option(default=None, callback=name_callback)):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nThe `ctx.resilient_parsing` will be `True` when handling completion, so you can just return without printing anything else.\n\nBut it will be `False` when calling the program normally. So you can continue the execution of your previous code.\n\nThat's all is needed to fix completion. 🚀\n\nCheck it:\n\n```\n\nfast →typer ./main.py run --[TAB][TAB]\n💬 Now it works correctly 🎉--help  -- Show this message and exit.\n--name\n\n💬 And you can call it normallytyper ./main.py run --name Camila\nValidating name\nHello Camila\n\nrestart ↻\n```\n\n## Using the `CallbackParam` object [¶](https://typer.tiangolo.com/tutorial/options/callback-and-context/\\#using-the-callbackparam-object \"Permanent link\")\n\nThe same way you can access the `typer.Context` by declaring a function parameter with its value, you can declare another function parameter with type `typer.CallbackParam` to get the specific Click `Parameter` object.\n\n[Python 3.8+](#__tabbed_7_1)\n\n```md-code__content\nfrom typing import Optional\n\nimport typer\nfrom typing_extensions import Annotated\n\ndef name_callback(ctx: typer.Context, param: typer.CallbackParam, value: str):\n    if ctx.resilient_parsing:\n        return\n    print(f\"Validating param: {param.name}\")\n    if value != \"Camila\":\n        raise typer.BadParameter(\"Only Camila is allowed\")\n    return value\n\ndef main(name: Annotated[Optional[str], typer.Option(callback=name_callback)] = None):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_8_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nfrom typing import Optional\n\nimport typer\n\ndef name_callback(ctx: typer.Context, param: typer.CallbackParam, value: str):\n    if ctx.resilient_parsing:\n        return\n    print(f\"Validating param: {param.name}\")\n    if value != \"Camila\":\n        raise typer.BadParameter(\"Only Camila is allowed\")\n    return value\n\ndef main(name: Optional[str] = typer.Option(default=None, callback=name_callback)):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nIt's probably not very common, but you could do it if you need it.\n\nFor example if you had a callback that could be used by several _CLI parameters_, that way the callback could know which parameter is each time.\n\nCheck it:\n\n```\n\nfast →python main.py --name Camila\nValidating param: name\nHello Camila\n\nrestart ↻\n```\n\n## Technical Details [¶](https://typer.tiangolo.com/tutorial/options/callback-and-context/\\#technical-details \"Permanent link\")\n\nBecause you get the relevant data in the callback function based on standard Python type annotations, you get type checks and autocompletion in your editor for free.\n\nAnd **Typer** will make sure you get the function parameters you want.\n\nYou don't have to worry about their names, their order, etc.\n\nAs it's based on standard Python types, it \" **just works**\". ✨\n\n### Click's `Parameter` [¶](https://typer.tiangolo.com/tutorial/options/callback-and-context/\\#clicks-parameter \"Permanent link\")\n\nThe `typer.CallbackParam` is actually just a sub-class of Click's [`Parameter`](https://click.palletsprojects.com/en/7.x/api/#click.Parameter), so you get all the right completion in your editor.\n\n### Callback with type annotations [¶](https://typer.tiangolo.com/tutorial/options/callback-and-context/\\#callback-with-type-annotations \"Permanent link\")\n\nYou can get the `typer.Context` and the `typer.CallbackParam` simply by declaring a function parameter of each type.\n\nThe order doesn't matter, the name of the function parameters doesn't matter.\n\nYou could also get only the `typer.CallbackParam` and not the `typer.Context`, or vice versa, it will still work.\n\n### `value` function parameter [¶](https://typer.tiangolo.com/tutorial/options/callback-and-context/\\#value-function-parameter \"Permanent link\")\n\nThe `value` function parameter in the callback can also have any name (e.g. `lastname`) and any type, but it should have the same type annotation as in the main function, because that's what it will receive.\n\nIt's also possible to not declare its type. It will still work.\n\nAnd it's possible to not declare the `value` parameter at all, and, for example, only get the `typer.Context`. That will also work.\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/options/callback-and-context/",
      "ogUrl": "https://typer.tiangolo.com/tutorial/options/callback-and-context/",
      "title": "CLI Option Callback and Context - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/options/callback-and-context/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/options/callback-and-context.png",
      "ogTitle": "CLI Option Callback and Context - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/options/callback-and-context.png",
      "og:title": "CLI Option Callback and Context - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/options/callback-and-context/",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/options/callback-and-context.png",
      "twitter:title": "CLI Option Callback and Context - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/parameter-types/enum/#enum-choices)\n\n# Enum - Choices [¶](https://typer.tiangolo.com/tutorial/parameter-types/enum/\\#enum-choices \"Permanent link\")\n\nTo define a _CLI parameter_ that can take a value from a predefined set of values you can use a standard Python [`enum.Enum`](https://docs.python.org/3/library/enum.html):\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nfrom enum import Enum\n\nimport typer\n\nclass NeuralNetwork(str, Enum):\n    simple = \"simple\"\n    conv = \"conv\"\n    lstm = \"lstm\"\n\ndef main(network: NeuralNetwork = NeuralNetwork.simple):\n    print(f\"Training neural network of type: {network.value}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nTip\n\nNotice that the function parameter `network` will be an `Enum`, not a `str`.\n\nTo get the `str` value in your function's code use `network.value`.\n\nCheck it:\n\n```\n\nfast →python main.py --help\n💬 Notice the predefined values [simple|conv|lstm]Usage: main.py [OPTIONS]\n\nOptions:\n  --network [simple|conv|lstm]  [default: simple]\n  --help                        Show this message and exit.\n\n💬 Try itpython main.py --network conv\nTraining neural network of type: conv\n\n💬 Invalid valuepython main.py --network capsule\nUsage: main.py [OPTIONS]\nTry \"main.py --help\" for help.\n\nError: Invalid value for '--network': 'capsule' is not one of 'simple', 'conv', 'lstm'.\n\n💬 Note that enums are case sensitive by defaultpython main.py --network CONV\nUsage: main.py [OPTIONS]\nTry \"main.py --help\" for help.\n\nError: Invalid value for '--network': 'CONV' is not one of 'simple', 'conv', 'lstm'.\n\nrestart ↻\n```\n\n### Case insensitive Enum choices [¶](https://typer.tiangolo.com/tutorial/parameter-types/enum/\\#case-insensitive-enum-choices \"Permanent link\")\n\nYou can make an `Enum` (choice) _CLI parameter_ be case-insensitive with the `case_sensitive` parameter:\n\n[Python 3.8+](#__tabbed_2_1)\n\n```md-code__content\nfrom enum import Enum\n\nimport typer\nfrom typing_extensions import Annotated\n\nclass NeuralNetwork(str, Enum):\n    simple = \"simple\"\n    conv = \"conv\"\n    lstm = \"lstm\"\n\ndef main(\n    network: Annotated[\\\n        NeuralNetwork, typer.Option(case_sensitive=False)\\\n    ] = NeuralNetwork.simple,\n):\n    print(f\"Training neural network of type: {network.value}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_3_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nfrom enum import Enum\n\nimport typer\n\nclass NeuralNetwork(str, Enum):\n    simple = \"simple\"\n    conv = \"conv\"\n    lstm = \"lstm\"\n\ndef main(\n    network: NeuralNetwork = typer.Option(NeuralNetwork.simple, case_sensitive=False),\n):\n    print(f\"Training neural network of type: {network.value}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nAnd then the values of the `Enum` will be checked no matter if lower case, upper case, or a mix:\n\n```\n\nfast →💬 Notice the upper case CONVpython main.py --network CONV\nTraining neural network of type: conv\n\n💬 A mix also workspython main.py --network LsTm\nTraining neural network of type: lstm\n\nrestart ↻\n```\n\n### List of Enum values [¶](https://typer.tiangolo.com/tutorial/parameter-types/enum/\\#list-of-enum-values \"Permanent link\")\n\nA _CLI parameter_ can also take a list of `Enum` values:\n\n[Python 3.8+](#__tabbed_4_1)\n\n```md-code__content\nfrom enum import Enum\nfrom typing import List\n\nimport typer\nfrom typing_extensions import Annotated\n\nclass Food(str, Enum):\n    food_1 = \"Eggs\"\n    food_2 = \"Bacon\"\n    food_3 = \"Cheese\"\n\ndef main(groceries: Annotated[List[Food], typer.Option()] = [Food.food_1, Food.food_3]):\n    print(f\"Buying groceries: {', '.join([f.value for f in groceries])}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_5_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nfrom enum import Enum\nfrom typing import List\n\nimport typer\n\nclass Food(str, Enum):\n    food_1 = \"Eggs\"\n    food_2 = \"Bacon\"\n    food_3 = \"Cheese\"\n\ndef main(groceries: List[Food] = typer.Option([Food.food_1, Food.food_3])):\n    print(f\"Buying groceries: {', '.join([f.value for f in groceries])}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nThis works just like any other parameter value taking a list of things:\n\n```\n\nfast →python main.py --help\n💬 Notice the default values being shownUsage: main.py [OPTIONS]\n\nOptions:\n  --groceries [Eggs|Bacon|Cheese]  [default: Eggs, Cheese]\n  --help                           Show this message and exit.\n\n💬 Try it with the default valuespython main.py\nBuying groceries: Eggs, Cheese\n\n💬 Try it with a single valuepython main.py --groceries \"Eggs\"\nBuying groceries: Eggs\n\n💬 Try it with multiple valuespython main.py --groceries \"Eggs\" --groceries \"Bacon\"\nBuying groceries: Eggs, Bacon\n\nrestart ↻\n```\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/parameter-types/enum/",
      "ogUrl": "https://typer.tiangolo.com/tutorial/parameter-types/enum/",
      "title": "Enum - Choices - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/parameter-types/enum/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/parameter-types/enum.png",
      "ogTitle": "Enum - Choices - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/parameter-types/enum.png",
      "og:title": "Enum - Choices - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/parameter-types/enum/",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/parameter-types/enum.png",
      "twitter:title": "Enum - Choices - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/options/help/#cli-options-with-help)\n\n# CLI Options with Help [¶](https://typer.tiangolo.com/tutorial/options/help/\\#cli-options-with-help \"Permanent link\")\n\nYou already saw how to add a help text for _CLI arguments_ with the `help` parameter.\n\nLet's now do the same for _CLI options_:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(\n    name: str,\n    lastname: Annotated[str, typer.Option(help=\"Last name of person to greet.\")] = \"\",\n    formal: Annotated[bool, typer.Option(help=\"Say hi formally.\")] = False,\n):\n    \"\"\"\n    Say hi to NAME, optionally with a --lastname.\n\n    If --formal is used, say hi very formally.\n    \"\"\"\n    if formal:\n        print(f\"Good day Ms. {name} {lastname}.\")\n    else:\n        print(f\"Hello {name} {lastname}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_2_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(\n    name: str,\n    lastname: str = typer.Option(\"\", help=\"Last name of person to greet.\"),\n    formal: bool = typer.Option(False, help=\"Say hi formally.\"),\n):\n    \"\"\"\n    Say hi to NAME, optionally with a --lastname.\n\n    If --formal is used, say hi very formally.\n    \"\"\"\n    if formal:\n        print(f\"Good day Ms. {name} {lastname}.\")\n    else:\n        print(f\"Hello {name} {lastname}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nThe same way as with `typer.Argument()`, we can put `typer.Option()` inside of `Annotated`.\n\nWe can then pass the `help` keyword parameter:\n\n```md-code__content\nlastname: Annotated[str, typer.Option(help=\"this option does this and that\")] = \"\"\n\n```\n\n...to create the help for that _CLI option_.\n\nThe same way as with `typer.Argument()`, **Typer** also supports the old style using the function parameter default value:\n\n```md-code__content\nlastname: str = typer.Option(default=\"\", help=\"this option does this and that\")\n\n```\n\nCopy that example from above to a file `main.py`.\n\nTest it:\n\n```\n\nfast →python main.py --help\nUsage: main.py [OPTIONS] NAME\n\n  Say hi to NAME, optionally with a --lastname.\n\n  If --formal is used, say hi very formally.\n\nArguments:\n  NAME  [required]\n\nOptions:\n  --lastname TEXT         Last name of person to greet. [default: ]\n  --formal / --no-formal  Say hi formally.  [default: False]\n  --help                  Show this message and exit.\n\n💬 Now you have a help text for the --lastname and --formal CLI options 🎉\nrestart ↻\n```\n\n## _CLI Options_ help panels [¶](https://typer.tiangolo.com/tutorial/options/help/\\#cli-options-help-panels \"Permanent link\")\n\nThe same as with _CLI arguments_, you can put the help for some _CLI options_ in different panels to be shown with the `--help` option.\n\nIf you have installed Rich as described in the docs for [Printing and Colors](https://typer.tiangolo.com/tutorial/printing/), you can set the `rich_help_panel` parameter to the name of the panel you want for each _CLI option_:\n\n[Python 3.8+](#__tabbed_3_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(\n    name: str,\n    lastname: Annotated[str, typer.Option(help=\"Last name of person to greet.\")] = \"\",\n    formal: Annotated[\\\n        bool,\\\n        typer.Option(\\\n            help=\"Say hi formally.\", rich_help_panel=\"Customization and Utils\"\\\n        ),\\\n    ] = False,\n    debug: Annotated[\\\n        bool,\\\n        typer.Option(\\\n            help=\"Enable debugging.\", rich_help_panel=\"Customization and Utils\"\\\n        ),\\\n    ] = False,\n):\n    \"\"\"\n    Say hi to NAME, optionally with a --lastname.\n\n    If --formal is used, say hi very formally.\n    \"\"\"\n    if formal:\n        print(f\"Good day Ms. {name} {lastname}.\")\n    else:\n        print(f\"Hello {name} {lastname}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_4_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(\n    name: str,\n    lastname: str = typer.Option(\"\", help=\"Last name of person to greet.\"),\n    formal: bool = typer.Option(\n        False, help=\"Say hi formally.\", rich_help_panel=\"Customization and Utils\"\n    ),\n    debug: bool = typer.Option(\n        False, help=\"Enable debugging.\", rich_help_panel=\"Customization and Utils\"\n    ),\n):\n    \"\"\"\n    Say hi to NAME, optionally with a --lastname.\n\n    If --formal is used, say hi very formally.\n    \"\"\"\n    if formal:\n        print(f\"Good day Ms. {name} {lastname}.\")\n    else:\n        print(f\"Hello {name} {lastname}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nNow, when you check the `--help` option, you will see a default panel named \" `Options`\" for the _CLI options_ that don't have a custom `rich_help_panel`.\n\nAnd below you will see other panels for the _CLI options_ that have a custom panel set in the `rich_help_panel` parameter:\n\n```\n\nfast →python main.py --help\n Usage: main.py [OPTIONS] NAME\n\n Say hi to NAME, optionally with a --lastname.\n If --formal is used, say hi very formally.\n\n╭─ Arguments ───────────────────────────────────────────────────────╮\n│ *    name      TEXT  [default: None] [required]                   │\n╰───────────────────────────────────────────────────────────────────╯\n╭─ Options ─────────────────────────────────────────────────────────╮\n│ --lastname                  TEXT  Last name of person to greet.   │\n│ --help                            Show this message and exit.     │\n╰───────────────────────────────────────────────────────────────────╯\n╭─ Customization and Utils ─────────────────────────────────────────╮\n│ --formal    --no-formal      Say hi formally.                     │\n│                              [default: no-formal]                 │\n│ --debug     --no-debug       Enable debugging.                    │\n│                              [default: no-debug]                  │\n╰───────────────────────────────────────────────────────────────────╯\n\nrestart ↻\n```\n\nHere we have a custom _CLI options_ panel named \" `Customization and Utils`\".\n\n## Help with style using Rich [¶](https://typer.tiangolo.com/tutorial/options/help/\\#help-with-style-using-rich \"Permanent link\")\n\nIn a future section you will see how to use custom markup in the `help` for _CLI options_ when reading about [Commands - Command Help](https://typer.tiangolo.com/tutorial/commands/help/#rich-markdown-and-markup).\n\nIf you are in a hurry you can jump there, but otherwise, it would be better to continue reading here and following the tutorial in order.\n\n## Hide default from help [¶](https://typer.tiangolo.com/tutorial/options/help/\\#hide-default-from-help \"Permanent link\")\n\nYou can tell Typer to not show the default value in the help text with `show_default=False`:\n\n[Python 3.8+](#__tabbed_5_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(fullname: Annotated[str, typer.Option(show_default=False)] = \"Wade Wilson\"):\n    print(f\"Hello {fullname}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_6_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(fullname: str = typer.Option(\"Wade Wilson\", show_default=False)):\n    print(f\"Hello {fullname}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nAnd it will no longer show the default value in the help text:\n\n```\n\nfast →python main.py\nHello Wade Wilson\n\n💬 Show the helppython main.py --help\nUsage: main.py [OPTIONS]\n\nOptions:\n  --fullname TEXT\n  --help                Show this message and exit.\n\n💬 Notice there's no [default: Wade Wilson] 🔥\nrestart ↻\n```\n\nTechnical Details\n\nIn Click applications the default values are hidden by default. 🙈\n\nIn **Typer** these default values are shown by default. 👀\n\n## Custom default string [¶](https://typer.tiangolo.com/tutorial/options/help/\\#custom-default-string \"Permanent link\")\n\nYou can use the same `show_default` to pass a custom string (instead of a `bool`) to customize the default value to be shown in the help text:\n\n[Python 3.8+](#__tabbed_7_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(\n    fullname: Annotated[\\\n        str, typer.Option(show_default=\"Deadpoolio the amazing's name\")\\\n    ] = \"Wade Wilson\",\n):\n    print(f\"Hello {fullname}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_8_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(\n    fullname: str = typer.Option(\n        \"Wade Wilson\", show_default=\"Deadpoolio the amazing's name\"\n    ),\n):\n    print(f\"Hello {fullname}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nAnd it will be used in the help text:\n\n```\n\nfast →python main.py\nHello Wade Wilson\n\n💬 Show the helppython main.py --help\nUsage: main.py [OPTIONS]\n\nOptions:\n  --fullname TEXT       [default: (Deadpoolio the amazing's name)]\n  --help                Show this message and exit.\n\n💬 Notice how it shows \"(Deadpoolio the amazing's name)\" instead of the actual default of \"Wade Wilson\"\nrestart ↻\n```\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/options/help/",
      "ogUrl": "https://typer.tiangolo.com/tutorial/options/help/",
      "title": "CLI Options with Help - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/options/help/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/options/help.png",
      "ogTitle": "CLI Options with Help - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/options/help.png",
      "og:title": "CLI Options with Help - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/options/help/",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/options/help.png",
      "twitter:title": "CLI Options with Help - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/using-click/#using-click)\n\n# Using Click [¶](https://typer.tiangolo.com/tutorial/using-click/\\#using-click \"Permanent link\")\n\nWarning\n\nThis is a more advanced topic, if you are starting with **Typer**, feel free to skip it.\n\nIt will be mostly useful for people that already work with Click and have questions around it.\n\n**Typer** is powered by [Click](https://click.palletsprojects.com). It does all the work underneath.\n\nHere is some more information related to using both together.\n\n## A single app with both Click and **Typer** [¶](https://typer.tiangolo.com/tutorial/using-click/\\#a-single-app-with-both-click-and-typer \"Permanent link\")\n\nIf you already have a Click application and want to migrate to **Typer**, or to add some Typer components, you can get a Click `Command` from your Typer application and then use Click directly.\n\n### How Click works [¶](https://typer.tiangolo.com/tutorial/using-click/\\#how-click-works \"Permanent link\")\n\nBefore knowing how to combine Click and **Typer**, let's first check a little about how Click works.\n\n#### Click `Command` [¶](https://typer.tiangolo.com/tutorial/using-click/\\#click-command \"Permanent link\")\n\nAny Click application has an object of class `Command`. That's, more or less, the most basic Click object.\n\nA `Command` can have its own _CLI arguments_ and _CLI options_, and it has a function that it calls.\n\nFor example, in this Click app:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nimport click\n\n@click.command()\n@click.option(\"--count\", default=1, help=\"Number of greetings.\")\n@click.option(\"--name\", prompt=\"Your name\", help=\"The person to greet.\")\ndef hello(count, name):\n    \"\"\"Simple program that greets NAME for a total of COUNT times.\"\"\"\n    for x in range(count):\n        click.echo(f\"Hello {name}!\")\n\nif __name__ == \"__main__\":\n    hello()\n\n```\n\nThe original `hello` variable is converted by Click from a function to a `Command` object. And the original `hello` function is used by that `Command` internally, but it is no longer named `hello` (as `hello` is now a Click `Command`).\n\n#### Click `Group` [¶](https://typer.tiangolo.com/tutorial/using-click/\\#click-group \"Permanent link\")\n\nThen Click also has a `Group` class, it **inherits from `Command`**. So, a `Group` object is _also_ a `Command`.\n\nA `Group` can also have its own _CLI arguments_ and _CLI options_.\n\nA `Group` can have subcommands of class `Command` or sub groups of class `Group` as well.\n\nAnd a `Group` can also have a function that it calls, right before calling the function for any specific subcommand.\n\nFor example:\n\n[Python 3.8+](#__tabbed_2_1)\n\n```md-code__content\nimport click\n\n@click.group()\ndef cli():\n    pass\n\n@click.command()\ndef initdb():\n    click.echo(\"Initialized the database\")\n\n@click.command()\ndef dropdb():\n    click.echo(\"Dropped the database\")\n\ncli.add_command(initdb)\ncli.add_command(dropdb)\n\nif __name__ == \"__main__\":\n    cli()\n\n```\n\nThe `cli` variable is converted by Click from a function to a `Group` object. And the original `cli` function is used by that `Group` internally.\n\nTip\n\nThe original `cli` function would be the equivalent of a [Typer Callback](https://typer.tiangolo.com/tutorial/commands/callback/).\n\nThen the `cli` variable, that now is a `Group` object, is used to add sub-commands.\n\n### How **Typer** works [¶](https://typer.tiangolo.com/tutorial/using-click/\\#how-typer-works \"Permanent link\")\n\nTyper doesn't modify the functions. You create an explicit variable of class `typer.Typer` and use it to _register_ those functions.\n\nAnd then, when you call the app, Typer goes and creates a Click `Command` (or `Group`), and then calls it.\n\nIf your app only has one command, then when you call it, **Typer** creates a single Click `Command` object and calls it.\n\nBut **Typer** creates a Click `Group` object if your app has any of:\n\n- More than one command.\n- A callback.\n- Sub-Typer apps (sub commands).\n\nTip\n\nIf you want to learn more about this check the section [One or Multiple Commands](https://typer.tiangolo.com/tutorial/commands/one-or-multiple/).\n\n### Combine Click and **Typer** [¶](https://typer.tiangolo.com/tutorial/using-click/\\#combine-click-and-typer \"Permanent link\")\n\n**Typer** uses an internal function `typer.main.get_command()` to generate a Click `Command` (or `Group`) from a `typer.Typer` object.\n\nYou can use it directly, and use the Click object with other Click applications.\n\n### Including a Click app in a **Typer** app [¶](https://typer.tiangolo.com/tutorial/using-click/\\#including-a-click-app-in-a-typer-app \"Permanent link\")\n\nFor example, you could have a **Typer** app, generate a Click `Group` from it, and then include other Click apps in it:\n\n[Python 3.8+](#__tabbed_3_1)\n\n```md-code__content\nimport click\nimport typer\n\napp = typer.Typer()\n\n@app.command()\ndef top():\n    \"\"\"\n    Top level command, form Typer\n    \"\"\"\n    print(\"The Typer app is at the top level\")\n\n@app.callback()\ndef callback():\n    \"\"\"\n    Typer app, including Click subapp\n    \"\"\"\n\n@click.command()\n@click.option(\"--name\", prompt=\"Your name\", help=\"The person to greet.\")\ndef hello(name):\n    \"\"\"Simple program that greets NAME for a total of COUNT times.\"\"\"\n    click.echo(f\"Hello {name}!\")\n\ntyper_click_object = typer.main.get_command(app)\n\ntyper_click_object.add_command(hello, \"hello\")\n\nif __name__ == \"__main__\":\n    typer_click_object()\n\n```\n\nNotice that we add a callback that does nothing (only document the CLI program), to make sure **Typer** creates a Click `Group`. That way we can add sub-commands to that Click `Group`.\n\nThen we generate a Click object from our `typer.Typer` app ( `typer_click_object`), and then we can include another Click object ( `hello`) in this Click `Group`.\n\nAnd that way, our **Typer** app will have a subcommand `top` built with Typer, and a subcommand `hello` built with Click.\n\nCheck it:\n\n```\n\nfast →python main.py --help\n💬 Notice we have both subcommands, top and helloUsage: main.py [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  --install-completion  Install completion for the current shell.\n  --show-completion     Show completion for the current shell, to copy it or customize the installation.\n  --help                Show this message and exit.\n\nCommands:\n  hello\n  top\n\n💬 Call the Typer partpython main.py top\nThe Typer app is at the top level\n\n💬 Call the Click partpython main.py hello --name Camila\nHello Camila!\n\nrestart ↻\n```\n\n### Including a **Typer** app in a Click app [¶](https://typer.tiangolo.com/tutorial/using-click/\\#including-a-typer-app-in-a-click-app \"Permanent link\")\n\nThe same way, you can do the contrary and include a **Typer** sub app in a bigger Click app:\n\n[Python 3.8+](#__tabbed_4_1)\n\n```md-code__content\nimport click\nimport typer\n\n@click.group()\ndef cli():\n    pass\n\n@cli.command()\ndef initdb():\n    click.echo(\"Initialized the database\")\n\n@cli.command()\ndef dropdb():\n    click.echo(\"Dropped the database\")\n\napp = typer.Typer()\n\n@app.command()\ndef sub():\n    \"\"\"\n    A single-command Typer sub app\n    \"\"\"\n    print(\"Typer is now below Click, the Click app is the top level\")\n\ntyper_click_object = typer.main.get_command(app)\n\ncli.add_command(typer_click_object, \"sub\")\n\nif __name__ == \"__main__\":\n    cli()\n\n```\n\nNotice that we don't have to add a callback or more commands, we can just create a **Typer** app that generates a single Click `Command`, as we don't need to include anything under the Typer app.\n\nThen we generate a Click object from our `typer.Typer` app ( `typer_click_object`), and then we use **the Click `cli` to include** our Click object from our Typer app.\n\nIn this case, the original Click app includes the **Typer** app.\n\nAnd then we call the _original Click_ app, not the Typer app.\n\nCheck it:\n\n```\n\nfast →python main.py\n💬 We get our Typer app down there in the sub commandUsage: main.py [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  dropdb\n  initdb\n  sub     A single-command Typer sub app\n\n💬 Use the Click partpython main.py initdb\nInitialized the database\n\n💬 And use the Typer partpython main.py sub\nTyper is now below Click, the Click app is the top level\n\nrestart ↻\n```\n\n## About Click decorators [¶](https://typer.tiangolo.com/tutorial/using-click/\\#about-click-decorators \"Permanent link\")\n\nTyper apps don't work with Click decorators directly.\n\nThis is because **Typer** doesn't modify functions to add metadata or to convert them to another object like Click does.\n\nSo, things like `@click.pass_context` won't work.\n\nMost of the functionality provided by decorators in Click has an alternative way of doing it in **Typer**.\n\nFor example, to access the context, you can just declare a function parameter of type `typer.Context`.\n\nTip\n\nYou can read more about using the context in the docs: [Commands: Using the Context](https://typer.tiangolo.com/tutorial/commands/context/)\n\nBut if you need to use something based on Click decorators, you can always generate a Click object using the methods described above, and use it as you would normally use Click.\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/using-click/",
      "ogUrl": "https://typer.tiangolo.com/tutorial/using-click/",
      "title": "Using Click - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/using-click/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/using-click.png",
      "ogTitle": "Using Click - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/using-click.png",
      "og:title": "Using Click - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/using-click/",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/using-click.png",
      "twitter:title": "Using Click - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/commands/help/#command-help)\n\n# Command Help [¶](https://typer.tiangolo.com/tutorial/commands/help/\\#command-help \"Permanent link\")\n\nThe same as before, you can add help for the commands in the docstrings and the _CLI options_.\n\nAnd the `typer.Typer()` application receives a parameter `help` that you can pass with the main help text for your CLI program:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\napp = typer.Typer(help=\"Awesome CLI user manager.\")\n\n@app.command()\ndef create(username: str):\n    \"\"\"\n    Create a new user with USERNAME.\n    \"\"\"\n    print(f\"Creating user: {username}\")\n\n@app.command()\ndef delete(\n    username: str,\n    force: Annotated[\\\n        bool,\\\n        typer.Option(\\\n            prompt=\"Are you sure you want to delete the user?\",\\\n            help=\"Force deletion without confirmation.\",\\\n        ),\\\n    ],\n):\n    \"\"\"\n    Delete a user with USERNAME.\n\n    If --force is not used, will ask for confirmation.\n    \"\"\"\n    if force:\n        print(f\"Deleting user: {username}\")\n    else:\n        print(\"Operation cancelled\")\n\n@app.command()\ndef delete_all(\n    force: Annotated[\\\n        bool,\\\n        typer.Option(\\\n            prompt=\"Are you sure you want to delete ALL users?\",\\\n            help=\"Force deletion without confirmation.\",\\\n        ),\\\n    ],\n):\n    \"\"\"\n    Delete ALL users in the database.\n\n    If --force is not used, will ask for confirmation.\n    \"\"\"\n    if force:\n        print(\"Deleting all users\")\n    else:\n        print(\"Operation cancelled\")\n\n@app.command()\ndef init():\n    \"\"\"\n    Initialize the users database.\n    \"\"\"\n    print(\"Initializing user database\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_2_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\napp = typer.Typer(help=\"Awesome CLI user manager.\")\n\n@app.command()\ndef create(username: str):\n    \"\"\"\n    Create a new user with USERNAME.\n    \"\"\"\n    print(f\"Creating user: {username}\")\n\n@app.command()\ndef delete(\n    username: str,\n    force: bool = typer.Option(\n        ...,\n        prompt=\"Are you sure you want to delete the user?\",\n        help=\"Force deletion without confirmation.\",\n    ),\n):\n    \"\"\"\n    Delete a user with USERNAME.\n\n    If --force is not used, will ask for confirmation.\n    \"\"\"\n    if force:\n        print(f\"Deleting user: {username}\")\n    else:\n        print(\"Operation cancelled\")\n\n@app.command()\ndef delete_all(\n    force: bool = typer.Option(\n        ...,\n        prompt=\"Are you sure you want to delete ALL users?\",\n        help=\"Force deletion without confirmation.\",\n    ),\n):\n    \"\"\"\n    Delete ALL users in the database.\n\n    If --force is not used, will ask for confirmation.\n    \"\"\"\n    if force:\n        print(\"Deleting all users\")\n    else:\n        print(\"Operation cancelled\")\n\n@app.command()\ndef init():\n    \"\"\"\n    Initialize the users database.\n    \"\"\"\n    print(\"Initializing user database\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nCheck it:\n\n```\n\nfast →💬 Check the new helppython main.py --help\nUsage: main.py [OPTIONS] COMMAND [ARGS]...\n\n  Awesome CLI user manager.\n\nOptions:\n  --install-completion  Install completion for the current shell.\n  --show-completion     Show completion for the current shell, to copy it or customize the installation.\n  --help                Show this message and exit.\n\nCommands:\n  create      Create a new user with USERNAME.\n  delete      Delete a user with USERNAME.\n  delete-all  Delete ALL users in the database.\n  init        Initialize the users database.\n\n💬 Now the commands have inline help 🎉\n💬 Check the help for createpython main.py create --help\nUsage: main.py create [OPTIONS] USERNAME\n\n  Create a new user with USERNAME.\n\nOptions:\n  --help  Show this message and exit.\n\n💬 Check the help for deletepython main.py delete --help\nUsage: main.py delete [OPTIONS] USERNAME\n\n  Delete a user with USERNAME.\n\n  If --force is not used, will ask for confirmation.\n\nOptions:\n  --force / --no-force  Force deletion without confirmation.  [required]\n  --help                Show this message and exit.\n\n💬 Check the help for delete-allpython main.py delete-all --help\nUsage: main.py delete-all [OPTIONS]\n\n  Delete ALL users in the database.\n\n  If --force is not used, will ask for confirmation.\n\nOptions:\n  --force / --no-force  Force deletion without confirmation.  [required]\n  --help                Show this message and exit.\n\n💬 Check the help for initpython main.py init --help\nUsage: main.py init [OPTIONS]\n\n  Initialize the users database.\n\nOptions:\n  --help  Show this message and exit.\n\nrestart ↻\n```\n\nTip\n\n`typer.Typer()` receives several other parameters for other things, we'll see that later.\n\nYou will also see how to use \"Callbacks\" later, and those include a way to add this same help message in a function docstring.\n\n## Overwrite command help [¶](https://typer.tiangolo.com/tutorial/commands/help/\\#overwrite-command-help \"Permanent link\")\n\nYou will probably be better adding the help text as a docstring to your functions, but if for some reason you wanted to overwrite it, you can use the `help` function argument passed to `@app.command()`:\n\n[Python 3.8+](#__tabbed_3_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\n\n@app.command(help=\"Create a new user with USERNAME.\")\ndef create(username: str):\n    \"\"\"\n    Some internal utility function to create.\n    \"\"\"\n    print(f\"Creating user: {username}\")\n\n@app.command(help=\"Delete a user with USERNAME.\")\ndef delete(username: str):\n    \"\"\"\n    Some internal utility function to delete.\n    \"\"\"\n    print(f\"Deleting user: {username}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nCheck it:\n\n```\n\nfast →💬 Check the helppython main.py --help\n💬 Notice it uses the help passed to @app.command()Usage: main.py [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  --install-completion  Install completion for the current shell.\n  --show-completion     Show completion for the current shell, to copy\n                        it or customize the installation.\n  --help                Show this message and exit.\n\nCommands:\n  create  Create a new user with USERNAME.\n  delete  Delete a user with USERNAME.\n\n💬 It uses \"Create a new user with USERNAME.\" instead of \"Some internal utility function to create.\"\nrestart ↻\n```\n\n## Deprecate a Command [¶](https://typer.tiangolo.com/tutorial/commands/help/\\#deprecate-a-command \"Permanent link\")\n\nThere could be cases where you have a command in your app that you need to deprecate, so that your users stop using it, even while it's still supported for a while.\n\nYou can mark it with the parameter `deprecated=True`:\n\n[Python 3.8+](#__tabbed_4_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\n\n@app.command()\ndef create(username: str):\n    \"\"\"\n    Create a user.\n    \"\"\"\n    print(f\"Creating user: {username}\")\n\n@app.command(deprecated=True)\ndef delete(username: str):\n    \"\"\"\n    Delete a user.\n\n    This is deprecated and will stop being supported soon.\n    \"\"\"\n    print(f\"Deleting user: {username}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nAnd when you show the `--help` option you will see it's marked as \" `deprecated`\":\n\n```\n\nfast →python main.py --help\n Usage: main.py [OPTIONS] COMMAND [ARGS]...\n\n╭─ Options ─────────────────────────────────────────────────────────╮\n│ --install-completion          Install completion for the current  │\n│                               shell.                              │\n│ --show-completion             Show completion for the current     │\n│                               shell, to copy it or customize the  │\n│                               installation.                       │\n│ --help                        Show this message and exit.         │\n╰───────────────────────────────────────────────────────────────────╯\n╭─ Commands ────────────────────────────────────────────────────────╮\n│ create        Create a user.                                      │\n│ delete        Delete a user.              (deprecated)            │\n╰───────────────────────────────────────────────────────────────────╯\n\nrestart ↻\n```\n\nAnd if you check the `--help` for the deprecated command (in this example, the command `delete`), it also shows it as deprecated:\n\n```\n\nfast →python main.py delete --help\n Usage: main.py delete [OPTIONS] USERNAME\n\n (deprecated)\n Delete a user.\n This is deprecated and will stop being supported soon.\n\n╭─ Arguments ───────────────────────────────────────────────────────╮\n│ *    username      TEXT  [default: None] [required]               │\n╰───────────────────────────────────────────────────────────────────╯\n╭─ Options ─────────────────────────────────────────────────────────╮\n│ --help          Show this message and exit.                       │\n╰───────────────────────────────────────────────────────────────────╯\n\nrestart ↻\n```\n\n## Rich Markdown and Markup [¶](https://typer.tiangolo.com/tutorial/commands/help/\\#rich-markdown-and-markup \"Permanent link\")\n\nIf you have **Rich** installed as described in [Printing and Colors](https://typer.tiangolo.com/tutorial/printing/), you can configure your app to enable markup text with the parameter `rich_markup_mode`.\n\nThen you can use more formatting in the docstrings and the `help` parameter for _CLI arguments_ and _CLI options_. You will see more about it below. 👇\n\nInfo\n\nBy default, `rich_markup_mode` is `None` if Rich is not installed, and `\"rich\"` if it is installed. In the latter case, you can set `rich_markup_mode` to `None` to disable rich text formatting.\n\n### Rich Markup [¶](https://typer.tiangolo.com/tutorial/commands/help/\\#rich-markup \"Permanent link\")\n\nIf you set `rich_markup_mode=\"rich\"` when creating the `typer.Typer()` app, you will be able to use [Rich Console Markup](https://rich.readthedocs.io/en/stable/markup.html) in the docstring, and even in the help for the _CLI arguments_ and options:\n\n[Python 3.8+](#__tabbed_5_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\napp = typer.Typer(rich_markup_mode=\"rich\")\n\n@app.command()\ndef create(\n    username: Annotated[\\\n        str, typer.Argument(help=\"The username to be [green]created[/green]\")\\\n    ],\n):\n    \"\"\"\n    [bold green]Create[/bold green] a new [italic]shinny[/italic] user. :sparkles:\n\n    This requires a [underline]username[/underline].\n    \"\"\"\n    print(f\"Creating user: {username}\")\n\n@app.command(help=\"[bold red]Delete[/bold red] a user with [italic]USERNAME[/italic].\")\ndef delete(\n    username: Annotated[\\\n        str, typer.Argument(help=\"The username to be [red]deleted[/red]\")\\\n    ],\n    force: Annotated[\\\n        bool, typer.Option(help=\"Force the [bold red]deletion[/bold red] :boom:\")\\\n    ] = False,\n):\n    \"\"\"\n    Some internal utility function to delete.\n    \"\"\"\n    print(f\"Deleting user: {username}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_6_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\napp = typer.Typer(rich_markup_mode=\"rich\")\n\n@app.command()\ndef create(\n    username: str = typer.Argument(\n        ..., help=\"The username to be [green]created[/green]\"\n    ),\n):\n    \"\"\"\n    [bold green]Create[/bold green] a new [italic]shiny[/italic] user. :sparkles:\n\n    This requires a [underline]username[/underline].\n    \"\"\"\n    print(f\"Creating user: {username}\")\n\n@app.command(help=\"[bold red]Delete[/bold red] a user with [italic]USERNAME[/italic].\")\ndef delete(\n    username: str = typer.Argument(..., help=\"The username to be [red]deleted[/red]\"),\n    force: bool = typer.Option(\n        False, help=\"Force the [bold red]deletion[/bold red] :boom:\"\n    ),\n):\n    \"\"\"\n    Some internal utility function to delete.\n    \"\"\"\n    print(f\"Deleting user: {username}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nWith that, you can use [Rich Console Markup](https://rich.readthedocs.io/en/stable/markup.html) to format the text in the docstring for the command `create`, make the word \" `create`\" bold and green, and even use an [emoji](https://rich.readthedocs.io/en/stable/markup.html#emoji).\n\nYou can also use markup in the help for the `username` CLI Argument.\n\nAnd the same as before, the help text overwritten for the command `delete` can also use Rich Markup, the same in the CLI Argument and CLI Option.\n\nIf you run the program and check the help, you will see that **Typer** uses **Rich** internally to format the help.\n\nCheck the help for the `create` command:\n\n```\n\nfast →python main.py create --help\n Usage: main.py create [OPTIONS] USERNAME\n\n Create a new shiny user. ✨\n This requires a username.\n\n╭─ Arguments ───────────────────────────────────────────────────────╮\n│ *    username      TEXT  The username to be created               │\n│                          [default: None]                          │\n│                          [required]                               │\n╰───────────────────────────────────────────────────────────────────╯\n╭─ Options ─────────────────────────────────────────────────────────╮\n│ --help          Show this message and exit.                       │\n╰───────────────────────────────────────────────────────────────────╯\n\nrestart ↻\n```\n\nAnd check the help for the `delete` command:\n\n```\n\nfast →python main.py delete --help\n Usage: main.py delete [OPTIONS] USERNAME\n\n Delete a user with USERNAME.\n\n╭─ Arguments ───────────────────────────────────────────────────────╮\n│ *    username      TEXT  The username to be deleted               │\n│                          [default: None]                          │\n│                          [required]                               │\n╰───────────────────────────────────────────────────────────────────╯\n╭─ Options ─────────────────────────────────────────────────────────╮\n│ --force    --no-force      Force the deletion 💥                  │\n│                            [default: no-force]                    │\n│ --help                     Show this message and exit.            │\n╰───────────────────────────────────────────────────────────────────╯\n\nrestart ↻\n```\n\n### Rich Markdown [¶](https://typer.tiangolo.com/tutorial/commands/help/\\#rich-markdown \"Permanent link\")\n\nIf you set `rich_markup_mode=\"markdown\"` when creating the `typer.Typer()` app, you will be able to use Markdown in the docstring:\n\n[Python 3.8+](#__tabbed_7_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\napp = typer.Typer(rich_markup_mode=\"markdown\")\n\n@app.command()\ndef create(\n    username: Annotated[str, typer.Argument(help=\"The username to be **created**\")],\n):\n    \"\"\"\n    **Create** a new *shinny* user. :sparkles:\n\n    * Create a username\n\n    * Show that the username is created\n\n    ---\n\n    Learn more at the [Typer docs website](https://typer.tiangolo.com)\n    \"\"\"\n    print(f\"Creating user: {username}\")\n\n@app.command(help=\"**Delete** a user with *USERNAME*.\")\ndef delete(\n    username: Annotated[str, typer.Argument(help=\"The username to be **deleted**\")],\n    force: Annotated[bool, typer.Option(help=\"Force the **deletion** :boom:\")] = False,\n):\n    \"\"\"\n    Some internal utility function to delete.\n    \"\"\"\n    print(f\"Deleting user: {username}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_8_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\napp = typer.Typer(rich_markup_mode=\"markdown\")\n\n@app.command()\ndef create(username: str = typer.Argument(..., help=\"The username to be **created**\")):\n    \"\"\"\n    **Create** a new *shiny* user. :sparkles:\n\n    * Create a username\n\n    * Show that the username is created\n\n    ---\n\n    Learn more at the [Typer docs website](https://typer.tiangolo.com)\n    \"\"\"\n    print(f\"Creating user: {username}\")\n\n@app.command(help=\"**Delete** a user with *USERNAME*.\")\ndef delete(\n    username: str = typer.Argument(..., help=\"The username to be **deleted**\"),\n    force: bool = typer.Option(False, help=\"Force the **deletion** :boom:\"),\n):\n    \"\"\"\n    Some internal utility function to delete.\n    \"\"\"\n    print(f\"Deleting user: {username}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nWith that, you can use Markdown to format the text in the docstring for the command `create`, make the word \" `create`\" bold, show a list of items, and even use an [emoji](https://rich.readthedocs.io/en/stable/markup.html#emoji).\n\nAnd the same as before, the help text overwritten for the command `delete` can also use Markdown.\n\nCheck the help for the `create` command:\n\n```\n\nfast →python main.py create --help\n Usage: main.py create [OPTIONS] USERNAME\n\n Create a new shiny user. ✨\n\n  • Create a username\n  • Show that the username is created\n\n ───────────────────────────────────────────────────────────────────\n Learn more at the Typer docs website\n\n╭─ Arguments ───────────────────────────────────────────────────────╮\n│ *    username      TEXT  The username to be created               │\n│                          [default: None]                          │\n│                          [required]                               │\n╰───────────────────────────────────────────────────────────────────╯\n╭─ Options ─────────────────────────────────────────────────────────╮\n│ --help          Show this message and exit.                       │\n╰───────────────────────────────────────────────────────────────────╯\n\nrestart ↻\n```\n\nAnd the same for the `delete` command:\n\n```\n\nfast →python main.py delete --help\n Usage: main.py delete [OPTIONS] USERNAME\n\n Delete a user with USERNAME.\n\n╭─ Arguments ───────────────────────────────────────────────────────╮\n│ *    username      TEXT  The username to be deleted               │\n│                          [default: None]                          │\n│                          [required]                               │\n╰───────────────────────────────────────────────────────────────────╯\n╭─ Options ─────────────────────────────────────────────────────────╮\n│ --force    --no-force      Force the deletion 💥                  │\n│                            [default: no-force]                    │\n│ --help                     Show this message and exit.            │\n╰───────────────────────────────────────────────────────────────────╯\n\nrestart ↻\n```\n\nInfo\n\nNotice that in Markdown you cannot define colors. For colors you might prefer to use Rich markup.\n\n## Help Panels [¶](https://typer.tiangolo.com/tutorial/commands/help/\\#help-panels \"Permanent link\")\n\nIf you have many commands or CLI parameters, you might want to show their documentation in different panels when using the `--help` option.\n\nIf you installed [Rich](https://rich.readthedocs.io/) as described in [Printing and Colors](https://typer.tiangolo.com/tutorial/printing/), you can configure the panel to use for each command or CLI parameter.\n\n### Help Panels for Commands [¶](https://typer.tiangolo.com/tutorial/commands/help/\\#help-panels-for-commands \"Permanent link\")\n\nTo set the panel for a command you can pass the argument `rich_help_panel` with the name of the panel you want to use:\n\n[Python 3.8+](#__tabbed_9_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer(rich_markup_mode=\"rich\")\n\n@app.command()\ndef create(username: str):\n    \"\"\"\n    [green]Create[/green] a new user. :sparkles:\n    \"\"\"\n    print(f\"Creating user: {username}\")\n\n@app.command()\ndef delete(username: str):\n    \"\"\"\n    [red]Delete[/red] a user. :fire:\n    \"\"\"\n    print(f\"Deleting user: {username}\")\n\n@app.command(rich_help_panel=\"Utils and Configs\")\ndef config(configuration: str):\n    \"\"\"\n    [blue]Configure[/blue] the system. :wrench:\n    \"\"\"\n    print(f\"Configuring the system with: {configuration}\")\n\n@app.command(rich_help_panel=\"Utils and Configs\")\ndef sync():\n    \"\"\"\n    [blue]Synchronize[/blue] the system or something fancy like that. :recycle:\n    \"\"\"\n    print(\"Syncing the system\")\n\n@app.command(rich_help_panel=\"Help and Others\")\ndef help():\n    \"\"\"\n    Get [yellow]help[/yellow] with the system. :question:\n    \"\"\"\n    print(\"Opening help portal...\")\n\n@app.command(rich_help_panel=\"Help and Others\")\ndef report():\n    \"\"\"\n    [yellow]Report[/yellow] an issue. :bug:\n    \"\"\"\n    print(\"Please open a new issue online, not a direct message\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nCommands without a panel will be shown in the default panel `Commands`, and the rest will be shown in the next panels:\n\n```\n\nfast →python main.py --help\n Usage: main.py [OPTIONS] COMMAND [ARGS]...\n\n╭─ Options ─────────────────────────────────────────────────────────╮\n│ --install-completion          Install completion for the current  │\n│                               shell.                              │\n│ --show-completion             Show completion for the current     │\n│                               shell, to copy it or customize the  │\n│                               installation.                       │\n│ --help                        Show this message and exit.         │\n╰───────────────────────────────────────────────────────────────────╯\n╭─ Commands ────────────────────────────────────────────────────────╮\n│ create           Create a new user. ✨                            │\n│ delete           Delete a user. 🔥                                │\n╰───────────────────────────────────────────────────────────────────╯\n╭─ Utils and Configs ───────────────────────────────────────────────╮\n│ config   Configure the system. 🔧                                 │\n│ sync     Synchronize the system or something fancy like that. ♻   │\n╰───────────────────────────────────────────────────────────────────╯\n╭─ Help and Others ─────────────────────────────────────────────────╮\n│ help          Get help with the system. ❓                        │\n│ report        Report an issue. 🐛                                 │\n╰───────────────────────────────────────────────────────────────────╯\n\nrestart ↻\n```\n\n### Help Panels for CLI Parameters [¶](https://typer.tiangolo.com/tutorial/commands/help/\\#help-panels-for-cli-parameters \"Permanent link\")\n\nThe same way, you can configure the panels for _CLI arguments_ and _CLI options_ with `rich_help_panel`.\n\nAnd of course, in the same application you can also set the `rich_help_panel` for commands.\n\n[Python 3.8+](#__tabbed_10_1)\n\n```md-code__content\nfrom typing import Union\n\nimport typer\nfrom typing_extensions import Annotated\n\napp = typer.Typer(rich_markup_mode=\"rich\")\n\n@app.command()\ndef create(\n    username: Annotated[str, typer.Argument(help=\"The username to create\")],\n    lastname: Annotated[\\\n        str,\\\n        typer.Argument(\\\n            help=\"The last name of the new user\", rich_help_panel=\"Secondary Arguments\"\\\n        ),\\\n    ] = \"\",\n    force: Annotated[bool, typer.Option(help=\"Force the creation of the user\")] = False,\n    age: Annotated[\\\n        Union[int, None],\\\n        typer.Option(help=\"The age of the new user\", rich_help_panel=\"Additional Data\"),\\\n    ] = None,\n    favorite_color: Annotated[\\\n        Union[str, None],\\\n        typer.Option(\\\n            help=\"The favorite color of the new user\",\\\n            rich_help_panel=\"Additional Data\",\\\n        ),\\\n    ] = None,\n):\n    \"\"\"\n    [green]Create[/green] a new user. :sparkles:\n    \"\"\"\n    print(f\"Creating user: {username}\")\n\n@app.command(rich_help_panel=\"Utils and Configs\")\ndef config(configuration: str):\n    \"\"\"\n    [blue]Configure[/blue] the system. :wrench:\n    \"\"\"\n    print(f\"Configuring the system with: {configuration}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_11_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nfrom typing import Union\n\nimport typer\n\napp = typer.Typer(rich_markup_mode=\"rich\")\n\n@app.command()\ndef create(\n    username: str = typer.Argument(..., help=\"The username to create\"),\n    lastname: str = typer.Argument(\n        \"\", help=\"The last name of the new user\", rich_help_panel=\"Secondary Arguments\"\n    ),\n    force: bool = typer.Option(False, help=\"Force the creation of the user\"),\n    age: Union[int, None] = typer.Option(\n        None, help=\"The age of the new user\", rich_help_panel=\"Additional Data\"\n    ),\n    favorite_color: Union[str, None] = typer.Option(\n        None,\n        help=\"The favorite color of the new user\",\n        rich_help_panel=\"Additional Data\",\n    ),\n):\n    \"\"\"\n    [green]Create[/green] a new user. :sparkles:\n    \"\"\"\n    print(f\"Creating user: {username}\")\n\n@app.command(rich_help_panel=\"Utils and Configs\")\ndef config(configuration: str):\n    \"\"\"\n    [blue]Configure[/blue] the system. :wrench:\n    \"\"\"\n    print(f\"Configuring the system with: {configuration}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nThen if you run the application you will see all the _CLI parameters_ in their respective panels.\n\n- First the **_CLI arguments_** that don't have a panel name set in a **default** one named \" `Arguments`\".\n- Next the **_CLI arguments_** with a **custom panel**. In this example named \" `Secondary Arguments`\".\n- After that, the **_CLI options_** that don't have a panel in a **default** one named \" `Options`\".\n- And finally, the **_CLI options_** with a **custom panel** set. In this example named \" `Additional Data`\".\n\nYou can check the `--help` option for the command `create`:\n\n```\n\nfast →python main.py create --help\n Usage: main.py create [OPTIONS] USERNAME [LASTNAME]\n\n Create a new user. ✨\n\n╭─ Arguments ───────────────────────────────────────────────────────╮\n│ *    username      TEXT  The username to create [default: None]   │\n│                          [required]                               │\n╰───────────────────────────────────────────────────────────────────╯\n╭─ Secondary Arguments ─────────────────────────────────────────────╮\n│   lastname      [LASTNAME]  The last name of the new user         │\n╰───────────────────────────────────────────────────────────────────╯\n╭─ Options ─────────────────────────────────────────────────────────╮\n│ --force    --no-force      Force the creation of the user         │\n│                            [default: no-force]                    │\n│ --help                     Show this message and exit.            │\n╰───────────────────────────────────────────────────────────────────╯\n╭─ Additional Data ─────────────────────────────────────────────────╮\n│ --age                   INTEGER  The age of the new user          │\n│                                  [default: None]                  │\n│ --favorite-color        TEXT     The favorite color of the new    │\n│                                  user                             │\n│                                  [default: None]                  │\n╰───────────────────────────────────────────────────────────────────╯\n\nrestart ↻\n```\n\nAnd of course, the `rich_help_panel` can be used in the same way for commands in the same application.\n\nAnd those panels will be shown when you use the main `--help` option.\n\n```\n\nfast →python main.py --help\n Usage: main.py [OPTIONS] COMMAND [ARGS]...\n\n╭─ Options ─────────────────────────────────────────────────────────╮\n│ --install-completion          Install completion for the current  │\n│                               shell.                              │\n│ --show-completion             Show completion for the current     │\n│                               shell, to copy it or customize the  │\n│                               installation.                       │\n│ --help                        Show this message and exit.         │\n╰───────────────────────────────────────────────────────────────────╯\n╭─ Commands ────────────────────────────────────────────────────────╮\n│ create           Create a new user. ✨                            │\n╰───────────────────────────────────────────────────────────────────╯\n╭─ Utils and Configs ───────────────────────────────────────────────╮\n│ config          Configure the system. 🔧                          │\n╰───────────────────────────────────────────────────────────────────╯\n\nrestart ↻\n```\n\nYou can see the custom panel for the commands for \" `Utils and Configs`\".\n\n## Epilog [¶](https://typer.tiangolo.com/tutorial/commands/help/\\#epilog \"Permanent link\")\n\nIf you need, you can also add an epilog section to the help of your commands:\n\n[Python 3.8+](#__tabbed_12_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer(rich_markup_mode=\"rich\")\n\n@app.command(epilog=\"Made with :heart: in [blue]Venus[/blue]\")\ndef create(username: str):\n    \"\"\"\n    [green]Create[/green] a new user. :sparkles:\n    \"\"\"\n    print(f\"Creating user: {username}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nAnd when you check the `--help` option it will look like:\n\n```\n\nfast →python main.py --help\n Usage: main.py [OPTIONS] USERNAME\n\n Create a new user. ✨\n\n╭─ Arguments ───────────────────────────────────────────────────────╮\n│ *    username      TEXT  [default: None] [required]               │\n╰───────────────────────────────────────────────────────────────────╯\n╭─ Options ─────────────────────────────────────────────────────────╮\n│ --install-completion          Install completion for the current  │\n│                               shell.                              │\n│ --show-completion             Show completion for the current     │\n│                               shell, to copy it or customize the  │\n│                               installation.                       │\n│ --help                        Show this message and exit.         │\n╰───────────────────────────────────────────────────────────────────╯\n\n Made with ❤ in Venus\n\nrestart ↻\n```\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/commands/help/",
      "ogUrl": "https://typer.tiangolo.com/tutorial/commands/help/",
      "title": "Command Help - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/commands/help/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/commands/help.png",
      "ogTitle": "Command Help - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/commands/help.png",
      "og:title": "Command Help - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/commands/help/",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/commands/help.png",
      "twitter:title": "Command Help - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/options-autocompletion/#cli-option-autocompletion)\n\n# CLI Option autocompletion [¶](https://typer.tiangolo.com/tutorial/options-autocompletion/\\#cli-option-autocompletion \"Permanent link\")\n\nAs you have seen, apps built with **Typer** have completion in your shell that works when you create a Python package or using the `typer` command.\n\nIt normally completes _CLI options_, _CLI arguments_, and subcommands (that you will learn about later).\n\nBut you can also provide auto completion for the **values** of _CLI options_ and _CLI arguments_. We will learn about that here.\n\n## Review completion [¶](https://typer.tiangolo.com/tutorial/options-autocompletion/\\#review-completion \"Permanent link\")\n\nBefore checking how to provide custom completions, let's check again how it works.\n\nAfter installing completion for your own Python package (or using the `typer` command), when you use your CLI program and start adding a _CLI option_ with `--` an then hit `TAB`, your shell will show you the available _CLI options_ (the same for _CLI arguments_, etc).\n\nTo check it quickly without creating a new Python package, use the `typer` command.\n\nThen let's create a small example program:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\napp = typer.Typer()\n\n@app.command()\ndef main(name: Annotated[str, typer.Option(help=\"The name to say hi to.\")] = \"World\"):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_2_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\n\n@app.command()\ndef main(name: str = typer.Option(\"World\", help=\"The name to say hi to.\")):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nAnd let's try it with the `typer` command to get completion:\n\n```\n\nfast →💬 Hit the TAB key in your keyboard below where you see the: [TAB]typer ./main.py [TAB][TAB]\n💬 Depending on your terminal/shell you will get some completion like this ✨run    -- Run the provided Typer app.\nutils  -- Extra utility commands for Typer apps.\n\n💬 Then try with \"run\" and --typer ./main.py run --[TAB][TAB]\n💬 You will get completion for --name, depending on your terminal it will look something like this--name  -- The name to say hi to.\n\n💬 And you can run it as if it was with Python directlytyper ./main.py run --name Camila\nHello Camila\n\nrestart ↻\n```\n\n## Custom completion for values [¶](https://typer.tiangolo.com/tutorial/options-autocompletion/\\#custom-completion-for-values \"Permanent link\")\n\nRight now we get completion for the _CLI option_ names, but not for the values.\n\nWe can provide completion for the values creating an `autocompletion` function, similar to the `callback` functions from [CLI Option Callback and Context](https://typer.tiangolo.com/tutorial/options/callback-and-context/):\n\n[Python 3.8+](#__tabbed_3_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef complete_name():\n    return [\"Camila\", \"Carlos\", \"Sebastian\"]\n\napp = typer.Typer()\n\n@app.command()\ndef main(\n    name: Annotated[\\\n        str, typer.Option(help=\"The name to say hi to.\", autocompletion=complete_name)\\\n    ] = \"World\",\n):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_4_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef complete_name():\n    return [\"Camila\", \"Carlos\", \"Sebastian\"]\n\napp = typer.Typer()\n\n@app.command()\ndef main(\n    name: str = typer.Option(\n        \"World\", help=\"The name to say hi to.\", autocompletion=complete_name\n    ),\n):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nWe return a `list` of strings from the `complete_name()` function.\n\nAnd then we get those values when using completion:\n\n```\n\nfast →typer ./main.py run --name [TAB][TAB]\n💬 We get the values returned from the function 🎉Camila     Carlos     Sebastian\n\nrestart ↻\n```\n\nWe got the basics working. Now let's improve it.\n\n## Check the incomplete value [¶](https://typer.tiangolo.com/tutorial/options-autocompletion/\\#check-the-incomplete-value \"Permanent link\")\n\nRight now, we always return those values, even if users start typing `Sebast` and then hit `TAB`, they will also get the completion for `Camila` and `Carlos` (depending on the shell), while we should only get completion for `Sebastian`.\n\nBut we can fix that so that it always works correctly.\n\nModify the `complete_name()` function to receive a parameter of type `str`, it will contain the incomplete value.\n\nThen we can check and return only the values that start with the incomplete value from the command line:\n\n[Python 3.8+](#__tabbed_5_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\nvalid_names = [\"Camila\", \"Carlos\", \"Sebastian\"]\n\ndef complete_name(incomplete: str):\n    completion = []\n    for name in valid_names:\n        if name.startswith(incomplete):\n            completion.append(name)\n    return completion\n\napp = typer.Typer()\n\n@app.command()\ndef main(\n    name: Annotated[\\\n        str, typer.Option(help=\"The name to say hi to.\", autocompletion=complete_name)\\\n    ] = \"World\",\n):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_6_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\nvalid_names = [\"Camila\", \"Carlos\", \"Sebastian\"]\n\ndef complete_name(incomplete: str):\n    completion = []\n    for name in valid_names:\n        if name.startswith(incomplete):\n            completion.append(name)\n    return completion\n\napp = typer.Typer()\n\n@app.command()\ndef main(\n    name: str = typer.Option(\n        \"World\", help=\"The name to say hi to.\", autocompletion=complete_name\n    ),\n):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nNow let's try it:\n\n```\n\nfast →typer ./main.py run --name Ca[TAB][TAB]\n💬 We get the values returned from the function that start with Ca 🎉Camila     Carlos\n\nrestart ↻\n```\n\nNow we are only returning the valid values, that start with `Ca`, we are no longer returning `Sebastian` as a completion option.\n\nTip\n\nYou have to declare the incomplete value of type `str` and that's what you will receive in the function.\n\nNo matter if the actual value will be an `int`, or something else, when doing completion, you will only get a `str` as the incomplete value.\n\nAnd the same way, you can only return `str`, not `int`, etc.\n\n## Add help to completions [¶](https://typer.tiangolo.com/tutorial/options-autocompletion/\\#add-help-to-completions \"Permanent link\")\n\nRight now we are returning a `list` of `str`.\n\nBut some shells (Zsh, Fish, PowerShell) are capable of showing extra help text for completion.\n\nWe can provide that extra help text so that those shells can show it.\n\nIn the `complete_name()` function, instead of providing one `str` per completion element, we provide a `tuple` with 2 items. The first item is the actual completion string, and the second item is the help text.\n\nSo, in the end, we return a `list` of `tuples` of `str`:\n\n[Python 3.8+](#__tabbed_7_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\nvalid_completion_items = [\\\n    (\"Camila\", \"The reader of books.\"),\\\n    (\"Carlos\", \"The writer of scripts.\"),\\\n    (\"Sebastian\", \"The type hints guy.\"),\\\n]\n\ndef complete_name(incomplete: str):\n    completion = []\n    for name, help_text in valid_completion_items:\n        if name.startswith(incomplete):\n            completion_item = (name, help_text)\n            completion.append(completion_item)\n    return completion\n\napp = typer.Typer()\n\n@app.command()\ndef main(\n    name: Annotated[\\\n        str, typer.Option(help=\"The name to say hi to.\", autocompletion=complete_name)\\\n    ] = \"World\",\n):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_8_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\nvalid_completion_items = [\\\n    (\"Camila\", \"The reader of books.\"),\\\n    (\"Carlos\", \"The writer of scripts.\"),\\\n    (\"Sebastian\", \"The type hints guy.\"),\\\n]\n\ndef complete_name(incomplete: str):\n    completion = []\n    for name, help_text in valid_completion_items:\n        if name.startswith(incomplete):\n            completion_item = (name, help_text)\n            completion.append(completion_item)\n    return completion\n\napp = typer.Typer()\n\n@app.command()\ndef main(\n    name: str = typer.Option(\n        \"World\", help=\"The name to say hi to.\", autocompletion=complete_name\n    ),\n):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nTip\n\nIf you want to have help text for each item, make sure each item in the list is a `tuple`. Not a `list`.\n\nClick checks specifically for a `tuple` when extracting the help text.\n\nSo in the end, the return will be a `list` (or other iterable) of `tuples` of 2 `str`.\n\nInfo\n\nThe help text will be visible in Zsh, Fish, and PowerShell.\n\nBash doesn't support showing the help text, but completion will still work the same.\n\nIf you have a shell like Zsh, it would look like:\n\n```\n\nfast →typer ./main.py run --name [TAB][TAB]\n💬 We get the completion items with their help text 🎉Camila     -- The reader of books.\nCarlos     -- The writer of scripts.\nSebastian  -- The type hints guy.\n\nrestart ↻\n```\n\n## Simplify with `yield` [¶](https://typer.tiangolo.com/tutorial/options-autocompletion/\\#simplify-with-yield \"Permanent link\")\n\nInstead of creating and returning a list with values ( `str` or `tuple`), we can use `yield` with each value that we want in the completion.\n\nThat way our function will be a [generator](https://docs.python.org/3.8/glossary.html#index-19) that **Typer** (actually Click) can iterate:\n\n[Python 3.8+](#__tabbed_9_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\nvalid_completion_items = [\\\n    (\"Camila\", \"The reader of books.\"),\\\n    (\"Carlos\", \"The writer of scripts.\"),\\\n    (\"Sebastian\", \"The type hints guy.\"),\\\n]\n\ndef complete_name(incomplete: str):\n    for name, help_text in valid_completion_items:\n        if name.startswith(incomplete):\n            yield (name, help_text)\n\napp = typer.Typer()\n\n@app.command()\ndef main(\n    name: Annotated[\\\n        str, typer.Option(help=\"The name to say hi to.\", autocompletion=complete_name)\\\n    ] = \"World\",\n):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_10_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\nvalid_completion_items = [\\\n    (\"Camila\", \"The reader of books.\"),\\\n    (\"Carlos\", \"The writer of scripts.\"),\\\n    (\"Sebastian\", \"The type hints guy.\"),\\\n]\n\ndef complete_name(incomplete: str):\n    for name, help_text in valid_completion_items:\n        if name.startswith(incomplete):\n            yield (name, help_text)\n\napp = typer.Typer()\n\n@app.command()\ndef main(\n    name: str = typer.Option(\n        \"World\", help=\"The name to say hi to.\", autocompletion=complete_name\n    ),\n):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nThat simplifies our code a bit and works the same.\n\nTip\n\nIf all the `yield` part seems complex for you, don't worry, you can just use the version with the `list` above.\n\nIn the end, that's just to save us a couple of lines of code.\n\nInfo\n\nThe function can use `yield`, so it doesn't have to return strictly a `list`, it just has to be [iterable](https://docs.python.org/3.8/glossary.html#term-iterable).\n\nBut each of the elements for completion has to be a `str` or a `tuple` (when containing a help text).\n\n## Access other _CLI parameters_ with the Context [¶](https://typer.tiangolo.com/tutorial/options-autocompletion/\\#access-other-cli-parameters-with-the-context \"Permanent link\")\n\nLet's say that now we want to modify the program to be able to \"say hi\" to multiple people at the same time.\n\nSo, we will allow multiple `--name` _CLI options_.\n\nTip\n\nYou will learn more about _CLI parameters_ with multiple values later in the tutorial.\n\nSo, for now, take this as a sneak peek 😉.\n\nFor this we use a `List` of `str`:\n\n[Python 3.8+](#__tabbed_11_1)\n\n```md-code__content\nfrom typing import List\n\nimport typer\nfrom typing_extensions import Annotated\n\napp = typer.Typer()\n\n@app.command()\ndef main(\n    name: Annotated[List[str], typer.Option(help=\"The name to say hi to.\")] = [\"World\"],\n):\n    for each_name in name:\n        print(f\"Hello {each_name}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_12_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nfrom typing import List\n\nimport typer\n\napp = typer.Typer()\n\n@app.command()\ndef main(name: List[str] = typer.Option([\"World\"], help=\"The name to say hi to.\")):\n    for each_name in name:\n        print(f\"Hello {each_name}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nAnd then we can use it like:\n\n```\n\nfast →typer ./main.py run --name Camila --name Sebastian\nHello Camila\nHello Sebastian\n\nrestart ↻\n```\n\n### Getting completion for multiple values [¶](https://typer.tiangolo.com/tutorial/options-autocompletion/\\#getting-completion-for-multiple-values \"Permanent link\")\n\nAnd the same way as before, we want to provide **completion** for those names. But we don't want to provide the **same names** for completion if they were already given in previous parameters.\n\nFor that, we will access and use the \"Context\". When you create a **Typer** application it uses Click underneath. And every Click application has a special object called a [\"Context\"](https://click.palletsprojects.com/en/7.x/commands/#nested-handling-and-contexts) that is normally hidden.\n\nBut you can access the context by declaring a function parameter of type `typer.Context`.\n\nAnd from that context you can get the current values for each parameter.\n\n[Python 3.8+](#__tabbed_13_1)\n\n```md-code__content\nfrom typing import List\n\nimport typer\nfrom typing_extensions import Annotated\n\nvalid_completion_items = [\\\n    (\"Camila\", \"The reader of books.\"),\\\n    (\"Carlos\", \"The writer of scripts.\"),\\\n    (\"Sebastian\", \"The type hints guy.\"),\\\n]\n\ndef complete_name(ctx: typer.Context, incomplete: str):\n    names = ctx.params.get(\"name\") or []\n    for name, help_text in valid_completion_items:\n        if name.startswith(incomplete) and name not in names:\n            yield (name, help_text)\n\napp = typer.Typer()\n\n@app.command()\ndef main(\n    name: Annotated[\\\n        List[str],\\\n        typer.Option(help=\"The name to say hi to.\", autocompletion=complete_name),\\\n    ] = [\"World\"],\n):\n    for n in name:\n        print(f\"Hello {n}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_14_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nfrom typing import List\n\nimport typer\n\nvalid_completion_items = [\\\n    (\"Camila\", \"The reader of books.\"),\\\n    (\"Carlos\", \"The writer of scripts.\"),\\\n    (\"Sebastian\", \"The type hints guy.\"),\\\n]\n\ndef complete_name(ctx: typer.Context, incomplete: str):\n    names = ctx.params.get(\"name\") or []\n    for name, help_text in valid_completion_items:\n        if name.startswith(incomplete) and name not in names:\n            yield (name, help_text)\n\napp = typer.Typer()\n\n@app.command()\ndef main(\n    name: List[str] = typer.Option(\n        [\"World\"], help=\"The name to say hi to.\", autocompletion=complete_name\n    ),\n):\n    for n in name:\n        print(f\"Hello {n}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nWe are getting the `names` already provided with `--name` in the command line before this completion was triggered.\n\nIf there's no `--name` in the command line, it will be `None`, so we use `or []` to make sure we have a `list` (even if empty) to check its contents later.\n\nThen, when we have a completion candidate, we check if each `name` was already provided with `--name` by checking if it's in that list of `names` with `name not in names`.\n\nAnd then we `yield` each item that has not been used yet.\n\nCheck it:\n\n```\n\nfast →typer ./main.py run --name [TAB][TAB]\n💬 The first time we trigger completion, we get all the namesCamila     -- The reader of books.\nCarlos     -- The writer of scripts.\nSebastian  -- The type hints guy.\n\n💬 Add a name and trigger completion againtyper ./main.py run --name Sebastian --name Ca[TAB][TAB]\n💬 Now we get completion only for the names we haven't used 🎉Camila  -- The reader of books.\nCarlos  -- The writer of scripts.\n\n💬 And if we add another of the available names:typer ./main.py run --name Sebastian --name Camila --name [TAB][TAB]\n💬 We get completion for the only available oneCarlos  -- The writer of scripts.\n\nrestart ↻\n```\n\nTip\n\nIt's quite possible that if there's only one option left, your shell will complete it right away instead of showing the option with the help text, to save you more typing.\n\n## Getting the raw _CLI parameters_ [¶](https://typer.tiangolo.com/tutorial/options-autocompletion/\\#getting-the-raw-cli-parameters \"Permanent link\")\n\nYou can also get the raw _CLI parameters_, just a `list` of `str` with everything passed in the command line before the incomplete value.\n\nFor example, something like `[\"typer\", \"main.py\", \"run\", \"--name\"]`.\n\nTip\n\nThis would be for advanced scenarios, in most use cases you would be better off using the context.\n\nBut it's still possible if you need it.\n\nAs a simple example, let's show it on the screen before completion.\n\nBecause completion is based on the output printed by your program (handled internally by **Typer**), during completion we can't just print something else as we normally do.\n\n### Printing to \"standard error\" [¶](https://typer.tiangolo.com/tutorial/options-autocompletion/\\#printing-to-standard-error \"Permanent link\")\n\nTip\n\nIf you need a refresher about what is \"standard output\" and \"standard error\" check the section in [Printing and Colors: \"Standard Output\" and \"Standard Error\"](https://typer.tiangolo.com/tutorial/printing/#standard-output-and-standard-error).\n\nThe completion system only reads from \"standard output\", so, printing to \"standard error\" won't break completion. 🚀\n\nYou can print to \"standard error\" with a **Rich** `Console(stderr=True)`.\n\nUsing `stderr=True` tells **Rich** that the output should be shown in \"standard error\".\n\n[Python 3.8+](#__tabbed_15_1)\n\n```md-code__content\nfrom typing import List\n\nimport typer\nfrom rich.console import Console\nfrom typing_extensions import Annotated\n\nvalid_completion_items = [\\\n    (\"Camila\", \"The reader of books.\"),\\\n    (\"Carlos\", \"The writer of scripts.\"),\\\n    (\"Sebastian\", \"The type hints guy.\"),\\\n]\n\nerr_console = Console(stderr=True)\n\ndef complete_name(args: List[str], incomplete: str):\n    err_console.print(f\"{args}\")\n    for name, help_text in valid_completion_items:\n        if name.startswith(incomplete):\n            yield (name, help_text)\n\napp = typer.Typer()\n\n@app.command()\ndef main(\n    name: Annotated[\\\n        List[str],\\\n        typer.Option(help=\"The name to say hi to.\", autocompletion=complete_name),\\\n    ] = [\"World\"],\n):\n    for n in name:\n        print(f\"Hello {n}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_16_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nfrom typing import List\n\nimport typer\nfrom rich.console import Console\n\nvalid_completion_items = [\\\n    (\"Camila\", \"The reader of books.\"),\\\n    (\"Carlos\", \"The writer of scripts.\"),\\\n    (\"Sebastian\", \"The type hints guy.\"),\\\n]\n\nerr_console = Console(stderr=True)\n\ndef complete_name(args: List[str], incomplete: str):\n    err_console.print(f\"{args}\")\n    for name, help_text in valid_completion_items:\n        if name.startswith(incomplete):\n            yield (name, help_text)\n\napp = typer.Typer()\n\n@app.command()\ndef main(\n    name: List[str] = typer.Option(\n        [\"World\"], help=\"The name to say hi to.\", autocompletion=complete_name\n    ),\n):\n    for n in name:\n        print(f\"Hello {n}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nInfo\n\nIf you can't install and use Rich, you can also use `print(lastname, file=sys.stderr)` or `typer.echo(\"some text\", err=True)` instead.\n\nWe get all the _CLI parameters_ as a raw `list` of `str` by declaring a parameter with type `List[str]`, here it's named `args`.\n\nTip\n\nHere we name the list of all the raw _CLI parameters_ `args` because that's the convention with Click.\n\nBut it doesn't contain only _CLI arguments_, it has everything, including _CLI options_ and values, as a raw `list` of `str`.\n\nAnd then we just print it to \"standard error\".\n\n```\n\nfast →typer ./main.py run --name [TAB][TAB]\n💬 First we see the raw CLI parameters['./main.py', 'run', '--name']\n\n💬 And then we see the actual completionCamila     -- The reader of books.\nCarlos     -- The writer of scripts.\nSebastian  -- The type hints guy.\n\nrestart ↻\n```\n\nTip\n\nThis is a very simple (and quite useless) example, just so you know how it works and that you can use it.\n\nBut it's probably useful only in very advanced use cases.\n\n## Getting the Context and the raw _CLI parameters_ [¶](https://typer.tiangolo.com/tutorial/options-autocompletion/\\#getting-the-context-and-the-raw-cli-parameters \"Permanent link\")\n\nOf course, you can declare everything if you need it, the context, the raw _CLI parameters_, and the incomplete `str`:\n\n[Python 3.8+](#__tabbed_17_1)\n\n```md-code__content\nfrom typing import List\n\nimport typer\nfrom rich.console import Console\nfrom typing_extensions import Annotated\n\nvalid_completion_items = [\\\n    (\"Camila\", \"The reader of books.\"),\\\n    (\"Carlos\", \"The writer of scripts.\"),\\\n    (\"Sebastian\", \"The type hints guy.\"),\\\n]\n\nerr_console = Console(stderr=True)\n\ndef complete_name(ctx: typer.Context, args: List[str], incomplete: str):\n    err_console.print(f\"{args}\")\n    names = ctx.params.get(\"name\") or []\n    for name, help_text in valid_completion_items:\n        if name.startswith(incomplete) and name not in names:\n            yield (name, help_text)\n\napp = typer.Typer()\n\n@app.command()\ndef main(\n    name: Annotated[\\\n        List[str],\\\n        typer.Option(help=\"The name to say hi to.\", autocompletion=complete_name),\\\n    ] = [\"World\"],\n):\n    for n in name:\n        print(f\"Hello {n}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_18_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nfrom typing import List\n\nimport typer\nfrom rich.console import Console\n\nvalid_completion_items = [\\\n    (\"Camila\", \"The reader of books.\"),\\\n    (\"Carlos\", \"The writer of scripts.\"),\\\n    (\"Sebastian\", \"The type hints guy.\"),\\\n]\n\nerr_console = Console(stderr=True)\n\ndef complete_name(ctx: typer.Context, args: List[str], incomplete: str):\n    err_console.print(f\"{args}\")\n    names = ctx.params.get(\"name\") or []\n    for name, help_text in valid_completion_items:\n        if name.startswith(incomplete) and name not in names:\n            yield (name, help_text)\n\napp = typer.Typer()\n\n@app.command()\ndef main(\n    name: List[str] = typer.Option(\n        [\"World\"], help=\"The name to say hi to.\", autocompletion=complete_name\n    ),\n):\n    for n in name:\n        print(f\"Hello {n}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nCheck it:\n\n```\n\nfast →typer ./main.py run --name [TAB][TAB]\n💬 First we see the raw CLI parameters['./main.py', 'run', '--name']\n\n💬 And then we see the actual completionCamila     -- The reader of books.\nCarlos     -- The writer of scripts.\nSebastian  -- The type hints guy.\n\ntyper ./main.py run --name Sebastian --name Ca[TAB][TAB]\n💬 Again, we see the raw CLI parameters['./main.py', 'run', '--name', 'Sebastian', '--name']\n\n💬 And then we see the rest of the valid completion itemsCamila     -- The reader of books.\nCarlos     -- The writer of scripts.\n\nrestart ↻\n```\n\n## Types, types everywhere [¶](https://typer.tiangolo.com/tutorial/options-autocompletion/\\#types-types-everywhere \"Permanent link\")\n\n**Typer** uses the type declarations to detect what it has to provide to your `autocompletion` function.\n\nYou can declare function parameters of these types:\n\n- `str`: for the incomplete value.\n- `typer.Context`: for the current context.\n- `List[str]`: for the raw _CLI parameters_.\n\nIt doesn't matter how you name them, in which order, or which ones of the 3 options you declare. It will all \" **just work**\" ✨\n\n## Comparison to Click functionality [¶](https://typer.tiangolo.com/tutorial/options-autocompletion/\\#comparison-to-click-functionality \"Permanent link\")\n\nNote that Click 7 had a similar [`autocompletion` function](https://click.palletsprojects.com/en/7.x/bashcomplete/), but it worked slightly differently.\n\nIt required the callback function to take exactly the 3 arguments `ctx`, `args` and `incomplete` in that exact order, instead of matching them dynamically based on types, as Typer does.\n\nSince Click 8, this functionality has been replaced by [`shell_complete`](https://click.palletsprojects.com/en/8.1.x/api/#click.ParamType.shell_complete), which still depends on the exact order of arguments for the callback function.\n\nHowever, Typer continues to use the `autocompletion` functionality as described on this page.\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/options-autocompletion/",
      "ogUrl": "https://typer.tiangolo.com/tutorial/options-autocompletion/",
      "title": "CLI Option autocompletion - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/options-autocompletion/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/options-autocompletion.png",
      "ogTitle": "CLI Option autocompletion - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/options-autocompletion.png",
      "og:title": "CLI Option autocompletion - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/options-autocompletion/",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/options-autocompletion.png",
      "twitter:title": "CLI Option autocompletion - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/arguments/?q=#cli-arguments)\n\n# CLI Arguments [¶](https://typer.tiangolo.com/tutorial/arguments/?q=\\#cli-arguments \"Permanent link\")\n\nIn the next few sections we'll see some ways to modify how _CLI arguments_ work.\n\nWe'll create optional _CLI arguments_, we'll add integrated help for _CLI arguments_, etc.\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/arguments/?q=",
      "ogUrl": "https://typer.tiangolo.com/tutorial/arguments/",
      "title": "CLI Arguments - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/arguments/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/arguments/index.png",
      "ogTitle": "CLI Arguments - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/arguments/index.png",
      "og:title": "CLI Arguments - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/arguments/?q=",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/arguments/index.png",
      "twitter:title": "CLI Arguments - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/arguments/other-uses/?q=#other-uses)\n\n# Other uses [¶](https://typer.tiangolo.com/tutorial/arguments/other-uses/?q=\\#other-uses \"Permanent link\")\n\n`typer.Argument()` has several other use cases. Such as for data validation, to enable other features, etc.\n\nYou will see about these use cases later in the docs.\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/arguments/other-uses/?q=",
      "ogUrl": "https://typer.tiangolo.com/tutorial/arguments/other-uses/",
      "title": "Other uses - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/arguments/other-uses/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/arguments/other-uses.png",
      "ogTitle": "Other uses - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/arguments/other-uses.png",
      "og:title": "Other uses - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/arguments/other-uses/?q=",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/arguments/other-uses.png",
      "twitter:title": "Other uses - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/options/?q=#cli-options)\n\n# CLI Options [¶](https://typer.tiangolo.com/tutorial/options/?q=\\#cli-options \"Permanent link\")\n\nIn the next short sections we will see how to modify _CLI options_ using `typer.Option()`.\n\n`typer.Option()` works very similarly to `typer.Argument()`, but has some extra features that we'll see next.\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/options/?q=",
      "ogUrl": "https://typer.tiangolo.com/tutorial/options/",
      "title": "CLI Options - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/options/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/options/index.png",
      "ogTitle": "CLI Options - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/options/index.png",
      "og:title": "CLI Options - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/options/?q=",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/options/index.png",
      "twitter:title": "CLI Options - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/multiple-values/options-with-multiple-values/?q=#cli-options-with-multiple-values)\n\n# CLI Options with Multiple Values [¶](https://typer.tiangolo.com/tutorial/multiple-values/options-with-multiple-values/?q=\\#cli-options-with-multiple-values \"Permanent link\")\n\nYou can also declare a _CLI option_ that takes several values of different types.\n\nYou can set the number of values and types to anything you want, but it has to be a fixed number of values.\n\nFor this, use the standard Python `typing.Tuple`:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nfrom typing import Tuple\n\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(user: Annotated[Tuple[str, int, bool], typer.Option()] = (None, None, None)):\n    username, coins, is_wizard = user\n    if not username:\n        print(\"No user provided\")\n        raise typer.Abort()\n    print(f\"The username {username} has {coins} coins\")\n    if is_wizard:\n        print(\"And this user is a wizard!\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_2_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nfrom typing import Tuple\n\nimport typer\n\ndef main(user: Tuple[str, int, bool] = typer.Option((None, None, None))):\n    username, coins, is_wizard = user\n    if not username:\n        print(\"No user provided\")\n        raise typer.Abort()\n    print(f\"The username {username} has {coins} coins\")\n    if is_wizard:\n        print(\"And this user is a wizard!\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nEach of the internal types defines the type of each value in the tuple.\n\nSo:\n\n```md-code__content\nuser: Tuple[str, int, bool]\n\n```\n\nmeans that the parameter `user` is a tuple of 3 values.\n\n- The first value is a `str`.\n- The second value is an `int`.\n- The third value is a `bool`.\n\nLater we do:\n\n```md-code__content\nusername, coins, is_wizard = user\n\n```\n\nIf you hadn't seen that, it means that `user` is a tuple with 3 values, and we are assigning each of the values to a new variable:\n\n- The first value in the tuple `user` (a `str`) goes to the variable `username`.\n- The second value in the tuple `user` (an `int`) goes to the variable `coins`.\n- The third value in the tuple `user` (a `bool`) goes to the variable `is_wizard`.\n\nSo, this:\n\n```md-code__content\nusername, coins, is_wizard = user\n\n```\n\nis equivalent to this:\n\n```md-code__content\nusername = user[0]\ncoins = user[1]\nis_wizard = user[2]\n\n```\n\nTip\n\nNotice that the default is a tuple with `(None, None, None)`.\n\nYou cannot simply use `None` here as the default because [Click doesn't support it](https://github.com/pallets/click/issues/472).\n\n## Check it [¶](https://typer.tiangolo.com/tutorial/multiple-values/options-with-multiple-values/?q=\\#check-it \"Permanent link\")\n\nNow let's see how this works in the terminal:\n\n```\n\nfast →💬 check the helppython main.py --help\n💬 Notice the <TEXT INTEGER BOOLEAN>Usage: main.py [OPTIONS]\n\nOptions:\n  --user <TEXT INTEGER BOOLEAN>...\n  --help                          Show this message and exit.\n\n💬 Now try itpython main.py --user Camila 50 yes\nThe username Camila has 50 coins\nAnd this user is a wizard!\n\n💬 With other valuespython main.py --user Morty 3 no\nThe username Morty has 3 coins\n\n💬 Try with invalid values (not enough)python main.py --user Camila 50\nError: Option '--user' requires 3 arguments\n\nrestart ↻\n```\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/multiple-values/options-with-multiple-values/?q=",
      "ogUrl": "https://typer.tiangolo.com/tutorial/multiple-values/options-with-multiple-values/",
      "title": "CLI Options with Multiple Values - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/multiple-values/options-with-multiple-values/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/multiple-values/options-with-multiple-values.png",
      "ogTitle": "CLI Options with Multiple Values - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/multiple-values/options-with-multiple-values.png",
      "og:title": "CLI Options with Multiple Values - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/multiple-values/options-with-multiple-values/?q=",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/multiple-values/options-with-multiple-values.png",
      "twitter:title": "CLI Options with Multiple Values - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/terminating/?q=#terminating)\n\n# Terminating [¶](https://typer.tiangolo.com/tutorial/terminating/?q=\\#terminating \"Permanent link\")\n\nThere are some cases where you might want to terminate a command at some point, and stop all subsequent execution.\n\nIt could be that your code determined that the program completed successfully, or it could be an operation aborted.\n\n## `Exit` a CLI program [¶](https://typer.tiangolo.com/tutorial/terminating/?q=\\#exit-a-cli-program \"Permanent link\")\n\nYou can normally just let the code of your CLI program finish its execution, but in some scenarios, you might want to terminate at some point in the middle of it. And prevent any subsequent code to run.\n\nThis doesn't have to mean that there's an error, just that nothing else needs to be executed.\n\nIn that case, you can raise a `typer.Exit()` exception:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nimport typer\n\nexisting_usernames = [\"rick\", \"morty\"]\n\ndef maybe_create_user(username: str):\n    if username in existing_usernames:\n        print(\"The user already exists\")\n        raise typer.Exit()\n    else:\n        print(f\"User created: {username}\")\n\ndef send_new_user_notification(username: str):\n    # Somehow send a notification here for the new user, maybe an email\n    print(f\"Notification sent for new user: {username}\")\n\ndef main(username: str):\n    maybe_create_user(username=username)\n    send_new_user_notification(username=username)\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nThere are several things to see in this example.\n\n- The CLI program is the function `main()`, not the others. This is the one that takes a _CLI argument_.\n- The function `maybe_create_user()` can terminate the program by raising `typer.Exit()`.\n- If the program is terminated by `maybe_create_user()` then `send_new_user_notification()` will never execute inside of `main()`.\n\nCheck it:\n\n```\n\nfast →python main.py Camila\nUser created: Camila\nNotification sent for new user: Camila\n\n💬 Try with an existing userpython main.py rick\nThe user already exists\n\n💬 Notice that the notification code was never run, the second message is not printed\nrestart ↻\n```\n\nTip\n\nEven though you are raising an exception, it doesn't necessarily mean there's an error.\n\nThis is done with an exception because it works as an \"error\" and stops all execution.\n\nBut then **Typer** (actually Click) catches it and just terminates the program normally.\n\n## Exit with an error [¶](https://typer.tiangolo.com/tutorial/terminating/?q=\\#exit-with-an-error \"Permanent link\")\n\n`typer.Exit()` takes an optional `code` parameter. By default, `code` is `0`, meaning there was no error.\n\nYou can pass a `code` with a number other than `0` to tell the terminal that there was an error in the execution of the program:\n\n[Python 3.8+](#__tabbed_2_1)\n\n```md-code__content\nimport typer\n\ndef main(username: str):\n    if username == \"root\":\n        print(\"The root user is reserved\")\n        raise typer.Exit(code=1)\n    print(f\"New user created: {username}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nCheck it:\n\n```\n\nfast →python main.py Camila\nNew user created: Camila\n\n💬 Print the result code of the last program executedecho $?\n0\n\n💬 Now make it exit with an errorpython main.py root\nThe root user is reserved\n\n💬 Print the result code of the last program executedecho $?\n1\n\n💬 1 means there was an error, 0 means no errors.\nrestart ↻\n```\n\nTip\n\nThe error code might be used by other programs (for example a Bash script) that execute your CLI program.\n\n## Abort [¶](https://typer.tiangolo.com/tutorial/terminating/?q=\\#abort \"Permanent link\")\n\nThere's a special exception that you can use to \"abort\" a program.\n\nIt works more or less the same as `typer.Exit()` but will print `\"Aborted!\"` to the screen and can be useful in certain cases later to make it explicit that the execution was aborted:\n\n[Python 3.8+](#__tabbed_3_1)\n\n```md-code__content\nimport typer\n\ndef main(username: str):\n    if username == \"root\":\n        print(\"The root user is reserved\")\n        raise typer.Abort()\n    print(f\"New user created: {username}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nCheck it:\n\n```\n\nfast →python main.py Camila\nNew user created: Camila\n\n💬 Now make it exit with an errorpython main.py root\nThe root user is reserved\nAborted!\n\nrestart ↻\n```\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/terminating/?q=",
      "ogUrl": "https://typer.tiangolo.com/tutorial/terminating/",
      "title": "Terminating - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/terminating/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/terminating.png",
      "ogTitle": "Terminating - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/terminating.png",
      "og:title": "Terminating - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/terminating/?q=",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/terminating.png",
      "twitter:title": "Terminating - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/commands/one-or-multiple/?q=#one-or-multiple-commands)\n\n# One or Multiple Commands [¶](https://typer.tiangolo.com/tutorial/commands/one-or-multiple/?q=\\#one-or-multiple-commands \"Permanent link\")\n\nYou might have noticed that if you create a single command, as in the first example:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\n\n@app.command()\ndef main(name: str):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\n**Typer** is smart enough to create a CLI application with that single function as the main CLI application, not as a command/subcommand:\n\n```\n\nfast →💬 Without a CLI argumentpython main.py\nUsage: main.py [OPTIONS] NAME\nTry \"main.py --help\" for help.\n\nError: Missing argument 'NAME'.\n\n💬 With the NAME CLI argumentpython main.py Camila\nHello Camila\n\n💬 Asking for helppython main.py\nUsage: main.py [OPTIONS] NAME\n\nOptions:\n  --install-completion  Install completion for the current shell.\n  --show-completion     Show completion for the current shell, to copy it or customize the installation.\n  --help                Show this message and exit.\n\nrestart ↻\n```\n\nTip\n\nNotice that it doesn't show a command `main`, even though the function name is `main`.\n\nBut if you add multiple commands, **Typer** will create one _CLI command_ for each one of them:\n\n[Python 3.8+](#__tabbed_2_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\n\n@app.command()\ndef create():\n    print(\"Creating user: Hiro Hamada\")\n\n@app.command()\ndef delete():\n    print(\"Deleting user: Hiro Hamada\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nHere we have 2 commands `create` and `delete`:\n\n```\n\nfast →💬 Check the helppython main.py --help\nUsage: main.py [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  --install-completion  Install completion for the current shell.\n  --show-completion     Show completion for the current shell, to copy it or customize the installation.\n  --help                Show this message and exit.\n\nCommands:\n  create\n  delete\n\n💬 Test the commandspython main.py create\nCreating user: Hiro Hamada\n\npython main.py delete\nDeleting user: Hiro Hamada\n\nrestart ↻\n```\n\n## One command and one callback [¶](https://typer.tiangolo.com/tutorial/commands/one-or-multiple/?q=\\#one-command-and-one-callback \"Permanent link\")\n\nIf you want to create a CLI app with one single command but you still want it to be a command/subcommand you can just add a callback:\n\n[Python 3.8+](#__tabbed_3_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\n\n@app.command()\ndef create():\n    print(\"Creating user: Hiro Hamada\")\n\n@app.callback()\ndef callback():\n    pass\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nAnd now your CLI program will have a single command.\n\nCheck it:\n\n```\n\nfast →💬 Check the helppython main.py --help\n💬 Notice the single command createUsage: main.py [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  --install-completion  Install completion for the current shell.\n  --show-completion     Show completion for the current shell, to copy it or customize the installation.\n  --help                Show this message and exit.\n\nCommands:\n  create\n\n💬 Try itpython main.py create\nCreating user: Hiro Hamada\n\nrestart ↻\n```\n\n## Using the callback to document [¶](https://typer.tiangolo.com/tutorial/commands/one-or-multiple/?q=\\#using-the-callback-to-document \"Permanent link\")\n\nNow that you are using a callback just to have a single command, you might as well use it to add documentation for your app:\n\n[Python 3.8+](#__tabbed_4_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\n\n@app.command()\ndef create():\n    print(\"Creating user: Hiro Hamada\")\n\n@app.callback()\ndef callback():\n    \"\"\"\n    Creates a single user Hiro Hamada.\n\n    In the next version it will create 5 more users.\n    \"\"\"\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nAnd now the docstring from the callback will be used as the help text:\n\n```\n\nfast →python main.py --help\n💬 Notice the help text from the docstringUsage: main.py [OPTIONS] COMMAND [ARGS]...\n\n  Creates a single user Hiro Hamada.\n\n  In the next version it will create 5 more users.\n\nOptions:\n  --install-completion  Install completion for the current shell.\n  --show-completion     Show completion for the current shell, to copy it or customize the installation.\n  --help                Show this message and exit.\n\nCommands:\n  create\n\n💬 And it still works the same, the callback does nothingpython main.py create\nCreating user: Hiro Hamada\n\nrestart ↻\n```\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/commands/one-or-multiple/?q=",
      "ogUrl": "https://typer.tiangolo.com/tutorial/commands/one-or-multiple/",
      "title": "One or Multiple Commands - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/commands/one-or-multiple/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/commands/one-or-multiple.png",
      "ogTitle": "One or Multiple Commands - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/commands/one-or-multiple.png",
      "og:title": "One or Multiple Commands - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/commands/one-or-multiple/?q=",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/commands/one-or-multiple.png",
      "twitter:title": "One or Multiple Commands - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/parameter-types/path/?q=#path)\n\n# Path [¶](https://typer.tiangolo.com/tutorial/parameter-types/path/?q=\\#path \"Permanent link\")\n\nYou can declare a _CLI parameter_ to be a standard Python [`pathlib.Path`](https://docs.python.org/3/library/pathlib.html#basic-use).\n\nThis is what you would do for directory paths, file paths, etc:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nfrom pathlib import Path\nfrom typing import Optional\n\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(config: Annotated[Optional[Path], typer.Option()] = None):\n    if config is None:\n        print(\"No config file\")\n        raise typer.Abort()\n    if config.is_file():\n        text = config.read_text()\n        print(f\"Config file contents: {text}\")\n    elif config.is_dir():\n        print(\"Config is a directory, will use all its config files\")\n    elif not config.exists():\n        print(\"The config doesn't exist\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_2_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nfrom pathlib import Path\nfrom typing import Optional\n\nimport typer\n\ndef main(config: Optional[Path] = typer.Option(None)):\n    if config is None:\n        print(\"No config file\")\n        raise typer.Abort()\n    if config.is_file():\n        text = config.read_text()\n        print(f\"Config file contents: {text}\")\n    elif config.is_dir():\n        print(\"Config is a directory, will use all its config files\")\n    elif not config.exists():\n        print(\"The config doesn't exist\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nAnd again, as you receive a standard Python `Path` object the same as the type annotation, your editor will give you autocompletion for all its attributes and methods.\n\nCheck it:\n\n```\n\nfast →💬 No configpython main.py\nNo config file\nAborted!\n\n💬 Pass a config that doesn't existpython main.py --config config.txt\nThe config doesn't exist\n\n💬 Now create a quick configecho \"some settings\" > config.txt\n💬 And try againpython main.py --config config.txt\nConfig file contents: some settings\n\n💬 And with a directorypython main.py --config ./\nConfig is a directory, will use all its config files\n\nrestart ↻\n```\n\n## Path validations [¶](https://typer.tiangolo.com/tutorial/parameter-types/path/?q=\\#path-validations \"Permanent link\")\n\nYou can perform several validations for `Path` _CLI parameters_:\n\n- `exists`: if set to true, the file or directory needs to exist for this value to be valid. If this is not required and a file does indeed not exist, then all further checks are silently skipped.\n- `file_okay`: controls if a file is a possible value.\n- `dir_okay`: controls if a directory is a possible value.\n- `writable`: if true, a writable check is performed.\n- `readable`: if true, a readable check is performed.\n- `resolve_path`: if this is true, then the path is fully resolved before the value is passed onwards. This means that it’s absolute and symlinks are resolved.\n\nTechnical Details\n\nIt will not expand a tilde-prefix (something with `~`, like `~/Documents/`), as this is supposed to be done by the shell only.\n\nTip\n\nAll these parameters come directly from [Click](https://click.palletsprojects.com/en/7.x/parameters/#parameter-types).\n\nFor example:\n\n[Python 3.8+](#__tabbed_3_1)\n\n```md-code__content\nfrom pathlib import Path\n\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(\n    config: Annotated[\\\n        Path,\\\n        typer.Option(\\\n            exists=True,\\\n            file_okay=True,\\\n            dir_okay=False,\\\n            writable=False,\\\n            readable=True,\\\n            resolve_path=True,\\\n        ),\\\n    ],\n):\n    text = config.read_text()\n    print(f\"Config file contents: {text}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_4_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nfrom pathlib import Path\n\nimport typer\n\ndef main(\n    config: Path = typer.Option(\n        ...,\n        exists=True,\n        file_okay=True,\n        dir_okay=False,\n        writable=False,\n        readable=True,\n        resolve_path=True,\n    ),\n):\n    text = config.read_text()\n    print(f\"Config file contents: {text}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nCheck it:\n\n```\n\nfast →python main.py --config config.txt\nUsage: main.py [OPTIONS]\nTry \"main.py --help\" for help.\n\nError: Invalid value for '--config': File 'config.txt' does not exist.\n\n💬 Now create a quick configecho \"some settings\" > config.txt\n💬 And try againpython main.py --config config.txt\nConfig file contents: some settings\n\n💬 And with a directorypython main.py --config ./\nUsage: main.py [OPTIONS]\nTry \"main.py --help\" for help.\n\nError: Invalid value for '--config': File './' is a directory.\n\nrestart ↻\n```\n\n### Advanced `Path` configurations [¶](https://typer.tiangolo.com/tutorial/parameter-types/path/?q=\\#advanced-path-configurations \"Permanent link\")\n\nAdvanced Details\n\nYou probably won't need these configurations at first, you may want to skip it.\n\nThey are used for more advanced use cases.\n\n- `allow_dash`: If this is set to True, a single dash to indicate standard streams is permitted.\n- `path_type`: optionally a string type that should be used to represent the path. The default is None which means the return value will be either bytes or unicode depending on what makes most sense given the input data Click deals with.\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/parameter-types/path/?q=",
      "ogUrl": "https://typer.tiangolo.com/tutorial/parameter-types/path/",
      "title": "Path - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/parameter-types/path/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/parameter-types/path.png",
      "ogTitle": "Path - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/parameter-types/path.png",
      "og:title": "Path - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/parameter-types/path/?q=",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/parameter-types/path.png",
      "twitter:title": "Path - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/parameter-types/?q=#cli-parameter-types)\n\n# CLI Parameter Types [¶](https://typer.tiangolo.com/tutorial/parameter-types/?q=\\#cli-parameter-types \"Permanent link\")\n\nYou can use several data types for the _CLI options_ and _CLI arguments_, and you can add data validation requirements too.\n\n## Data conversion [¶](https://typer.tiangolo.com/tutorial/parameter-types/?q=\\#data-conversion \"Permanent link\")\n\nWhen you declare a _CLI parameter_ with some type **Typer** will convert the data received in the command line to that data type.\n\nFor example:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nimport typer\n\ndef main(name: str, age: int = 20, height_meters: float = 1.89, female: bool = True):\n    print(f\"NAME is {name}, of type: {type(name)}\")\n    print(f\"--age is {age}, of type: {type(age)}\")\n    print(f\"--height-meters is {height_meters}, of type: {type(height_meters)}\")\n    print(f\"--female is {female}, of type: {type(female)}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nIn this example, the value received for the _CLI argument_ `NAME` will be treated as `str`.\n\nThe value for the _CLI option_ `--age` will be converted to an `int` and `--height-meters` will be converted to a `float`.\n\nAnd as `female` is a `bool` _CLI option_, **Typer** will convert it to a \"flag\" `--female` and the counterpart `--no-female`.\n\nAnd here's how it looks like:\n\n```\n\nfast →python main.py --help\n💬 Notice how --age is an INTEGER and --height-meters is a FLOATUsage: main.py [OPTIONS] NAME\n\nArguments:\n  NAME  [required]\n\nOptions:\n  --age INTEGER           [default: 20]\n  --height-meters FLOAT   [default: 1.89]\n  --female / --no-female  [default: True]\n  --help                  Show this message and exit.\n\n💬 Call it with CLI parameterspython main.py Camila --age 15 --height-meters 1.70 --female\n💬 All the data has the correct Python typeNAME is Camila, of type: class 'str'\n--age is 15, of type: class 'int'\n--height-meters is 1.7, of type: class 'float'\n--female is True, of type: class 'bool'\n\n💬 And if you pass an incorrect typepython main.py Camila --age 15.3\nUsage: main.py [OPTIONS] NAME\nTry \"main.py --help\" for help.\n\nError: Invalid value for '--age': '15.3' is not a valid integer\n\n💬 Because 15.3 is not an INTEGER (it's a float)\nrestart ↻\n```\n\n## Watch next [¶](https://typer.tiangolo.com/tutorial/parameter-types/?q=\\#watch-next \"Permanent link\")\n\nSee more about specific types and validations in the next sections...\n\nTechnical Details\n\nAll the types you will see in the next sections are handled underneath by [Click's Parameter Types](https://click.palletsprojects.com/en/7.x/parameters/#parameter-types).\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/parameter-types/?q=",
      "ogUrl": "https://typer.tiangolo.com/tutorial/parameter-types/",
      "title": "CLI Parameter Types - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/parameter-types/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/parameter-types/index.png",
      "ogTitle": "CLI Parameter Types - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/parameter-types/index.png",
      "og:title": "CLI Parameter Types - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/parameter-types/?q=",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/parameter-types/index.png",
      "twitter:title": "CLI Parameter Types - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/multiple-values/?q=#multiple-values)\n\n# Multiple Values [¶](https://typer.tiangolo.com/tutorial/multiple-values/?q=\\#multiple-values \"Permanent link\")\n\nThere are several ways to declare multiple values for _CLI options_ and _CLI arguments_.\n\nWe'll see them in the next short sections.\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/multiple-values/?q=",
      "ogUrl": "https://typer.tiangolo.com/tutorial/multiple-values/",
      "title": "Multiple Values - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/multiple-values/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/multiple-values/index.png",
      "ogTitle": "Multiple Values - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/multiple-values/index.png",
      "og:title": "Multiple Values - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/multiple-values/?q=",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/multiple-values/index.png",
      "twitter:title": "Multiple Values - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/?q=#learn)\n\n# Learn [¶](https://typer.tiangolo.com/tutorial/?q=\\#learn \"Permanent link\")\n\nLearn how to use **Typer** in this step-by-step **Tutorial** \\- **User Guide**.\n\nIt covers everything you need to know from the **simplest scripts** to **complex CLI applications**.\n\nYou could consider this a **book**, a **course**, the **official** and recommended way to learn **Typer**. 😎\n\n## Python Types [¶](https://typer.tiangolo.com/tutorial/?q=\\#python-types \"Permanent link\")\n\nIf you need a refresher about how to use Python type hints, check the first part of [FastAPI's Python types intro](https://fastapi.tiangolo.com/python-types/).\n\nYou can also check the [mypy cheat sheet](https://mypy.readthedocs.io/en/latest/cheat_sheet_py3.html).\n\nIn short (very short), you can declare a function with parameters like:\n\n```md-code__content\nfrom typing import Optional\n\ndef type_example(name: str, formal: bool = False, intro: Optional[str] = None):\n    pass\n\n```\n\nAnd your editor (and **Typer**) will know that:\n\n- `name` is of type `str` and is a required parameter.\n- `formal` is a `bool` and is by default `False`.\n- `intro` is an optional `str`, by default is `None`.\n\nThese type hints are what give you autocomplete in your editor and several other features.\n\n**Typer** is based on these type hints.\n\n## About this Tutorial [¶](https://typer.tiangolo.com/tutorial/?q=\\#about-this-tutorial \"Permanent link\")\n\nThis tutorial shows you how to use **Typer** with all its features, step by step.\n\nEach section gradually builds on the previous ones, but it's structured to separate topics, so that you can go directly to any specific one to solve your specific CLI needs.\n\nIt is also built to work as a future reference so you can come back and see exactly what you need.\n\n## Run the Code [¶](https://typer.tiangolo.com/tutorial/?q=\\#run-the-code \"Permanent link\")\n\nAll the code blocks can be copied and used directly (they are tested Python files).\n\nTo run any of the examples, copy the code to a file `main.py`, and run it:\n\n```\n\nfast →python main.py\n✨ The magic happens here ✨\n\nrestart ↻\n```\n\nIt is **HIGHLY encouraged** that you write or copy the code, edit it and run it locally.\n\nUsing it in your editor is what really shows you the benefits of **Typer**, seeing how little code you have to write, all the **inline errors**, **autocompletion**, etc.\n\nAnd running the examples is what will really help you **understand** what is going on.\n\nYou can learn a lot more by **running some examples** and **playing around** with them than by reading all the docs here.\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/?q=",
      "ogUrl": "https://typer.tiangolo.com/tutorial/",
      "title": "Learn - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/index.png",
      "ogTitle": "Learn - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/index.png",
      "og:title": "Learn - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/?q=",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/index.png",
      "twitter:title": "Learn - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/options/password/?q=#password-cli-option-and-confirmation-prompt)\n\n# Password CLI Option and Confirmation Prompt [¶](https://typer.tiangolo.com/tutorial/options/password/?q=\\#password-cli-option-and-confirmation-prompt \"Permanent link\")\n\nApart from having a prompt, you can make a _CLI option_ have a `confirmation_prompt=True`:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(\n    name: str,\n    email: Annotated[str, typer.Option(prompt=True, confirmation_prompt=True)],\n):\n    print(f\"Hello {name}, your email is {email}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_2_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(\n    name: str, email: str = typer.Option(..., prompt=True, confirmation_prompt=True)\n):\n    print(f\"Hello {name}, your email is {email}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nAnd the CLI program will ask for confirmation:\n\n```\n\nfast →python main.py Camila\n💬 It prompts for the emailcamila@example.comcamila@example.com\nHello Camila, your email is camila@example.com\n\nrestart ↻\n```\n\n## A Password prompt [¶](https://typer.tiangolo.com/tutorial/options/password/?q=\\#a-password-prompt \"Permanent link\")\n\nWhen receiving a password, it is very common (in most shells) to not show anything on the screen while typing the password.\n\nThe program will still receive the password, but nothing will be shown on screen, not even `****`.\n\nYou can achieve the same using `hide_input=True`.\n\nAnd if you combine it with `confirmation_prompt=True` you can easily receive a password with double confirmation:\n\n[Python 3.8+](#__tabbed_3_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(\n    name: str,\n    password: Annotated[\\\n        str, typer.Option(prompt=True, confirmation_prompt=True, hide_input=True)\\\n    ],\n):\n    print(f\"Hello {name}. Doing something very secure with password.\")\n    print(f\"...just kidding, here it is, very insecure: {password}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_4_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(\n    name: str,\n    password: str = typer.Option(\n        ..., prompt=True, confirmation_prompt=True, hide_input=True\n    ),\n):\n    print(f\"Hello {name}. Doing something very secure with password.\")\n    print(f\"...just kidding, here it is, very insecure: {password}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nCheck it:\n\n```\n\nfast →python main.py Camila\n💬 It prompts for the password, but doesn't show anything when you type Password: $ Repeat for confirmation: $\n💬 Let's imagine the password typed was \"typerrocks\"Hello Camila. Doing something very secure with password.\n...just kidding, here it is, very insecure: typerrocks\n\nrestart ↻\n```\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/options/password/?q=",
      "ogUrl": "https://typer.tiangolo.com/tutorial/options/password/",
      "title": "Password CLI Option and Confirmation Prompt - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/options/password/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/options/password.png",
      "ogTitle": "Password CLI Option and Confirmation Prompt - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/options/password.png",
      "og:title": "Password CLI Option and Confirmation Prompt - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/options/password/?q=",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/options/password.png",
      "twitter:title": "Password CLI Option and Confirmation Prompt - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/multiple-values/arguments-with-multiple-values/?q=#cli-arguments-with-multiple-values)\n\n# CLI Arguments with Multiple Values [¶](https://typer.tiangolo.com/tutorial/multiple-values/arguments-with-multiple-values/?q=\\#cli-arguments-with-multiple-values \"Permanent link\")\n\n_CLI arguments_ can also receive multiple values.\n\nYou can define the type of a _CLI argument_ using `typing.List`.\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nfrom pathlib import Path\nfrom typing import List\n\nimport typer\n\ndef main(files: List[Path], celebration: str):\n    for path in files:\n        if path.is_file():\n            print(f\"This file exists: {path.name}\")\n            print(celebration)\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nAnd then you can pass it as many _CLI arguments_ of that type as you want:\n\n```\n\nfast →python main.py ./index.md ./first-steps.md woohoo!\nThis file exists: index.md\nwoohoo!\nThis file exists: first-steps.md\nwoohoo!\n\nrestart ↻\n```\n\nTip\n\nWe also declared a final _CLI argument_ `celebration`, and it's correctly used even if we pass an arbitrary number of `files` first.\n\nInfo\n\nA `List` can only be used in the last command (if there are subcommands), as this will take anything to the right and assume it's part of the expected _CLI arguments_.\n\n## _CLI arguments_ with tuples [¶](https://typer.tiangolo.com/tutorial/multiple-values/arguments-with-multiple-values/?q=\\#cli-arguments-with-tuples \"Permanent link\")\n\nIf you want a specific number of values and types, you can use a tuple, and it can even have default values:\n\n[Python 3.8+](#__tabbed_2_1)\n\n```md-code__content\nfrom typing import Tuple\n\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(\n    names: Annotated[\\\n        Tuple[str, str, str], typer.Argument(help=\"Select 3 characters to play with\")\\\n    ] = (\"Harry\", \"Hermione\", \"Ron\"),\n):\n    for name in names:\n        print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_3_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nfrom typing import Tuple\n\nimport typer\n\ndef main(\n    names: Tuple[str, str, str] = typer.Argument(\n        (\"Harry\", \"Hermione\", \"Ron\"), help=\"Select 3 characters to play with\"\n    ),\n):\n    for name in names:\n        print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nCheck it:\n\n```\n\nfast →💬 Check the helppython main.py --help\nUsage: main.py [OPTIONS] [NAMES]...\n\nArguments:\n  [NAMES]...  Select 3 characters to play with  [default: Harry, Hermione, Ron]\n\nOptions:\n  --help                Show this message and exit.\n\n💬 Use it with its defaultspython main.py\nHello Harry\nHello Hermione\nHello Ron\n\n💬 If you pass an invalid number of arguments you will get an errorpython main.py Draco Hagrid\nError: Argument 'names' takes 3 values\n\n💬 And if you pass the exact number of values it will work correctlypython main.py Draco Hagrid Dobby\nHello Draco\nHello Hagrid\nHello Dobby\n\nrestart ↻\n```\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/multiple-values/arguments-with-multiple-values/?q=",
      "ogUrl": "https://typer.tiangolo.com/tutorial/multiple-values/arguments-with-multiple-values/",
      "title": "CLI Arguments with Multiple Values - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/multiple-values/arguments-with-multiple-values/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/multiple-values/arguments-with-multiple-values.png",
      "ogTitle": "CLI Arguments with Multiple Values - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/multiple-values/arguments-with-multiple-values.png",
      "og:title": "CLI Arguments with Multiple Values - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/multiple-values/arguments-with-multiple-values/?q=",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/multiple-values/arguments-with-multiple-values.png",
      "twitter:title": "CLI Arguments with Multiple Values - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/one-file-per-command/?q=#one-file-per-command)\n\n# One File Per Command [¶](https://typer.tiangolo.com/tutorial/one-file-per-command/?q=\\#one-file-per-command \"Permanent link\")\n\nWhen your CLI application grows, you can split it into multiple files and modules. This pattern helps maintain a clean and organized code structure. ✨\n\nThis tutorial will show you how to use `add_typer` to create sub commands and organize your commands in multiple files.\n\nWe will create a simple CLI with the following commands:\n\n- `version`\n- `users add NAME`\n- `users delete NAME`\n\n## CLI structure [¶](https://typer.tiangolo.com/tutorial/one-file-per-command/?q=\\#cli-structure \"Permanent link\")\n\nHere is the structure we'll be working with:\n\n```md-code__content\nmycli/\n├── __init__.py\n├── main.py\n├── users/\n│   ├── __init__.py\n│   ├── add.py\n│   └── delete.py\n└── version.py\n\n```\n\n`mycli` will be our package, and it will contain the following modules:\n\n- `main.py`: The main module that will import the `version` and `users` modules.\n- `version.py`: A module that will contain the `version` command.\n- `users/`: A package (inside of our `mycli` package) that will contain the `add` and `delete` commands.\n\n## Implementation [¶](https://typer.tiangolo.com/tutorial/one-file-per-command/?q=\\#implementation \"Permanent link\")\n\nLet's start implementing our CLI! 🚀\n\nWe'll create the `version` module, the `main` module, and the `users` package.\n\n### Version Module ( `version.py`) [¶](https://typer.tiangolo.com/tutorial/one-file-per-command/?q=\\#version-module-versionpy \"Permanent link\")\n\nLet's start by creating the `version` module. This module will contain the `version` command.\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\n\n@app.command()\ndef version():\n    print(\"My CLI Version 1.0\")\n\n```\n\nIn this file we are creating a new Typer app instance for the `version` command.\n\nThis is not required in single-file applications, but in the case of multi-file applications it will allow us to include this command in the main application using `app.add_typer()`.\n\nLet's see that next!\n\n### Main Module ( `main.py`) [¶](https://typer.tiangolo.com/tutorial/one-file-per-command/?q=\\#main-module-mainpy \"Permanent link\")\n\nThe main module will be the entry point of the application. It will import the version module and the users module.\n\nTip\n\nWe'll see how to implement the users module in the next section.\n\n[Python 3.8+](#__tabbed_2_1)\n\n```md-code__content\nimport typer\n\nfrom .users import app as users_app\nfrom .version import app as version_app\n\napp = typer.Typer()\n\napp.add_typer(version_app)\napp.add_typer(users_app, name=\"users\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nIn this module, we import the `version` and `users` modules and add them to the main app using `app.add_typer()`.\n\nFor the `users` module, we specify the name as `\"users\"` to group the commands under the `users` sub-command.\n\nNotice that we didn't add a name for the `version_app` Typer app. Because of this, Typer will add the commands (just one in this case) declared in the `version_app` directly at the top level. So, there will be a top-level `version` sub-command.\n\nBut for `users`, we add a name `\"users\"`, this way those commands will be under the sub-command `users` instead of at the top level. So, there will be a `users add` and `users delete` sub-sub-commands. 😅\n\nTip\n\nIf you want a command to group the included commands in a sub-app, add a name.\n\nIf you want to include the commands from a sub-app directly at the top level, don't add a name, or set it to `None`. 🤓\n\nLet's now create the `users` module with the `add` and `delete` commands.\n\n### Users Add Command ( `users/add.py`) [¶](https://typer.tiangolo.com/tutorial/one-file-per-command/?q=\\#users-add-command-usersaddpy \"Permanent link\")\n\n[Python 3.8+](#__tabbed_3_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\n\n@app.command()\ndef add(name: str):\n    print(f\"Adding user: {name}\")\n\n```\n\nLike the `version` module, we create a new Typer app instance for the `users/add` command. This allows us to include the `add` command in the users app.\n\n### Users Delete Command ( `users/delete.py`) [¶](https://typer.tiangolo.com/tutorial/one-file-per-command/?q=\\#users-delete-command-usersdeletepy \"Permanent link\")\n\n[Python 3.8+](#__tabbed_4_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\n\n@app.command()\ndef delete(name: str):\n    print(f\"Deleting user: {name}\")\n\n```\n\nAnd once again, we create a new Typer app instance for the `users/delete` command. This allows us to include the `delete` command in the users app.\n\n### Users' app ( `users/__init__.py`) [¶](https://typer.tiangolo.com/tutorial/one-file-per-command/?q=\\#users-app-users__init__py \"Permanent link\")\n\nFinally, we need to create an `__init__.py` file in the `users` directory to define the `users` app.\n\n[Python 3.8+](#__tabbed_5_1)\n\n```md-code__content\nimport typer\n\nfrom .add import app as add_app\nfrom .delete import app as delete_app\n\napp = typer.Typer()\n\napp.add_typer(add_app)\napp.add_typer(delete_app)\n\n```\n\nSimilarly to the `version` module, we create a new `Typer` app instance for the `users` module. This allows us to include the `add` and `delete` commands in the users app.\n\n## Running the Application [¶](https://typer.tiangolo.com/tutorial/one-file-per-command/?q=\\#running-the-application \"Permanent link\")\n\nNow we are ready to run the application! 😎\n\nTo run the application, you can execute it as a Python module:\n\n```\n\nfast →python -m mycli.main version\nMy CLI Version 1.0\n\npython -m mycli.main users add Camila\nAdding user: Camila\n\nrestart ↻\n```\n\nAnd if you built a package and installed your app, you can then use the `mycli` command:\n\n```\n\nfast →mycli version\nMy CLI Version 1.0\n\nmycli users add Camila\nAdding user: Camila\n\nrestart ↻\n```\n\n## Callbacks [¶](https://typer.tiangolo.com/tutorial/one-file-per-command/?q=\\#callbacks \"Permanent link\")\n\nHave in mind that if you include a sub-app with `app.add_typer()` **without a name**, the commands will be added to the top level, so **only the top level callback** (if there's any) will be used, the one declared in the main app.\n\nIf you **want to use a callback** for a sub-app, you need to include the sub-app **with a name**, which creates a sub-command grouping the commands in that sub-app. 🤓\n\nIn the example above, if the `users` sub-app had a callback, it would be used. But if the `version` sub-app had a callback, it would not be used, because the `version` sub-app was included without a name.\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/one-file-per-command/?q=",
      "ogUrl": "https://typer.tiangolo.com/tutorial/one-file-per-command/",
      "title": "One File Per Command - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/one-file-per-command/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/one-file-per-command.png",
      "ogTitle": "One File Per Command - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/one-file-per-command.png",
      "og:title": "One File Per Command - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/one-file-per-command/?q=",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/one-file-per-command.png",
      "twitter:title": "One File Per Command - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/commands/arguments/?q=#command-cli-arguments)\n\n# Command CLI Arguments [¶](https://typer.tiangolo.com/tutorial/commands/arguments/?q=\\#command-cli-arguments \"Permanent link\")\n\nThe same way as with a CLI application with a single command, subcommands (or just \"commands\") can also have their own _CLI arguments_:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\n\n@app.command()\ndef create(username: str):\n    print(f\"Creating user: {username}\")\n\n@app.command()\ndef delete(username: str):\n    print(f\"Deleting user: {username}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\n```\n\nfast →💬 Check the help for createpython main.py create --help\nUsage: main.py create [OPTIONS] USERNAME\n\nOptions:\n  --help  Show this message and exit.\n\n💬 Call it with a CLI argumentpython main.py create Camila\nCreating user: Camila\n\n💬 The same for deletepython main.py delete Camila\nDeleting user: Camila\n\nrestart ↻\n```\n\nTip\n\nEverything to the _right_ of the _command_ are _CLI parameters_ ( _CLI arguments_ and _CLI options_) for that command.\n\nTechnical Details\n\nActually, it's everything to the right of that command, _before any subcommand_.\n\nIt's possible to have groups of _subcommands_, it's like if one _command_ also had _subcommands_. And then those _subcommands_ could have their own _CLI parameters_, taking their own _CLI parameters_.\n\nYou will see about them later in another section.\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/commands/arguments/?q=",
      "ogUrl": "https://typer.tiangolo.com/tutorial/commands/arguments/",
      "title": "Command CLI Arguments - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/commands/arguments/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/commands/arguments.png",
      "ogTitle": "Command CLI Arguments - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/commands/arguments.png",
      "og:title": "Command CLI Arguments - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/commands/arguments/?q=",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/commands/arguments.png",
      "twitter:title": "Command CLI Arguments - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/first-steps/?q=#first-steps)\n\n# First Steps [¶](https://typer.tiangolo.com/tutorial/first-steps/?q=\\#first-steps \"Permanent link\")\n\n## The simplest example [¶](https://typer.tiangolo.com/tutorial/first-steps/?q=\\#the-simplest-example \"Permanent link\")\n\nThe simplest **Typer** file could look like this:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nimport typer\n\ndef main():\n    print(\"Hello World\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nCopy that to a file `main.py`.\n\nTest it:\n\n```\n\nfast →python main.py\nHello World\n\n💬 It just prints \"Hello World\".\n💬 Now check the --helppython main.py --help\n Usage: main.py [OPTIONS]\n\n╭─ Options ─────────────────────────────────────────╮\n│ --help                        Show this message   │\n│                               and exit.           │\n╰───────────────────────────────────────────────────╯\n\nrestart ↻\n```\n\n...but this program is still not very useful. Let's extend it.\n\n## What is a **CLI argument** [¶](https://typer.tiangolo.com/tutorial/first-steps/?q=\\#what-is-a-cli-argument \"Permanent link\")\n\nHere we will use the word **CLI argument** to refer to **CLI parameters** passed in some specific order to the CLI application. By default, they are _required_.\n\nIf you go to your terminal and type:\n\n```\n\nfast →ls ./myproject\nfirst-steps.md  intro.md\n\nrestart ↻\n```\n\n`ls` will show the contents of the directory `./myproject`.\n\n- `ls` is the _program_ (or \"command\", \"CLI app\").\n- `./myproject` is a _CLI argument_, in this case it refers to the path of a directory.\n\nThey are a bit different from **CLI options** that you will see later below.\n\n## Add a CLI argument [¶](https://typer.tiangolo.com/tutorial/first-steps/?q=\\#add-a-cli-argument \"Permanent link\")\n\nUpdate the previous example with an argument `name`:\n\n[Python 3.8+](#__tabbed_2_1)\n\n```md-code__content\nimport typer\n\ndef main(name: str):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n```\n\nfast →python main.py\n💬 If you run it without the argument, it shows a nice errorUsage: main.py [OPTIONS] NAME\nTry 'main.py --help' for help.\n╭─ Error ───────────────────────────────────────────╮\n│ Missing argument 'NAME'.                          │\n╰───────────────────────────────────────────────────╯\n\n💬 Now pass that NAME CLI argumentpython main.py Camila\nHello Camila\n\n💬 Here \"Camila\" is the CLI argument\n💬 To pass a name with spaces for the same CLI argument, use quotespython main.py \"Camila Gutiérrez\"\nHello Camila Gutiérrez\n\nrestart ↻\n```\n\nTip\n\nIf you need to pass a single value that contains spaces to a _CLI argument_, use quotes ( `\"`) around it.\n\n## Two CLI arguments [¶](https://typer.tiangolo.com/tutorial/first-steps/?q=\\#two-cli-arguments \"Permanent link\")\n\nNow let's say we want to have the name and last name separated.\n\nSo, extend that to have 2 arguments, `name` and `lastname`:\n\n[Python 3.8+](#__tabbed_3_1)\n\n```md-code__content\nimport typer\n\ndef main(name: str, lastname: str):\n    print(f\"Hello {name} {lastname}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n```\n\nfast →💬 Check the main --helppython main.py --help\nUsage: main.py [OPTIONS] NAME\nTry 'main.py --help' for help.\n╭─ Error ───────────────────────────────────────────╮\n│ Missing argument 'NAME'.                          │\n╰───────────────────────────────────────────────────╯\n\ntyper on  richify [»!?] via 🐍 v3.7.5 (env3.7)\n❯ python main.py\nUsage: main.py [OPTIONS] NAME LASTNAME\nTry 'main.py --help' for help.\n╭─ Error ───────────────────────────────────────────╮\n│ Missing argument 'NAME'.                          │\n╰───────────────────────────────────────────────────╯\n\n💬 There are now 2 CLI arguments, name and lastname\n💬 Now pass a single name argumentpython main.py Camila\nUsage: main.py [OPTIONS] NAME LASTNAME\nTry 'main.py --help' for help.\n╭─ Error ───────────────────────────────────────────╮\n│ Missing argument 'LASTNAME'.                      │\n╰───────────────────────────────────────────────────╯\n\n💬 These 2 arguments are required, so, pass both:python main.py Camila Gutiérrez\nHello Camila Gutiérrez\n\nrestart ↻\n```\n\nTip\n\nNotice that the order is important. The last name has to go after the first name.\n\nIf you called it with:\n\n```md-code__content\n$ python main.py Gutiérrez Camila\n\n```\n\nyour app wouldn't have a way to know which is the `name` and which the `lastname`. It expects the first _CLI argument_ to be the `name` and the second _CLI argument_ to be the `lastname`.\n\n## What is a **CLI option** [¶](https://typer.tiangolo.com/tutorial/first-steps/?q=\\#what-is-a-cli-option \"Permanent link\")\n\nHere we will use the word **CLI option** to refer to _CLI parameters_ passed to the CLI application with a specific name. For example, if you go to your terminal and type:\n\n```\n\nfast →ls ./myproject --size\n12 first-steps.md   4 intro.md\n\nrestart ↻\n```\n\n`ls` will show the contents of the directory `./myproject` with their `size`.\n\n- `ls` is the _program_ (or \"command\", \"CLI app\").\n- `./myproject` is a _CLI argument_.\n- `--size` is an optional _CLI option_.\n\nThe program knows it has to show the size because it sees `--size`, not because of the order.\n\nA _CLI option_ like `--size` doesn't depend on the order like a _CLI argument_.\n\nSo, if you put the `--size` _before_ the _CLI argument_, it still works (in fact, that's the most common way of doing it):\n\n```\n\nfast →ls --size ./myproject\n12 first-steps.md   4 intro.md\n\nrestart ↻\n```\n\nThe main visual difference between a _CLI option_ and a _CLI argument_ is that the _CLI option_ has `--` prepended to the name, like in \" `--size`\".\n\nA _CLI option_ doesn't depend on the order because it has a predefined name (here it's `--size`). This is because the CLI app is looking specifically for a literal `--size` parameter (also known as \"flag\" or \"switch\"), with that specific \"name\" (here the specific name is \" `--size`\"). The CLI app will check if you typed it or not, it will be actively looking for `--size` even if you didn't type it (to check if it's there or not).\n\nIn contrast, the CLI app is not actively looking for the _CLI argument_ with a text \" `./myproject`\", it has no way to know if you would type `./myproject` or `./my-super-awesome-project` or anything else. It's just waiting to get whatever you give it. The only way to know that you refer to a specific _CLI argument_ is because of the order. The same way that it knows that the first _CLI argument_ was the `name` and the second was the `lastname`, but if you mixed the order, it wouldn't be able to handle it.\n\nInstead, with a _CLI option_, the order doesn't matter.\n\nAlso, by default, a _CLI option_ is _optional_ (not _required_).\n\nSo, by default:\n\n- A _CLI argument_ is **required**\n- A _CLI option_ is **optional**\n\nBut the _required_ and _optional_ defaults can be changed.\n\nSo, the main and **most important** difference is that:\n\n- _CLI options_ **start with `--`** and don't depend on the order\n- _CLI arguments_ depend on the **sequence order**\n\nTip\n\nIn this example above the _CLI option_ `--size` is just a \"flag\" or \"switch\" that will contain a boolean value, `True` or `False`, depending on if it was added to the command or not.\n\nThis one doesn't receive any values. But _CLI options_ can also receive values like _CLI arguments_. You'll see how later.\n\n## Add one _CLI option_ [¶](https://typer.tiangolo.com/tutorial/first-steps/?q=\\#add-one-cli-option \"Permanent link\")\n\nNow add a `--formal` _CLI option_:\n\n[Python 3.8+](#__tabbed_4_1)\n\n```md-code__content\nimport typer\n\ndef main(name: str, lastname: str, formal: bool = False):\n    if formal:\n        print(f\"Good day Ms. {name} {lastname}.\")\n    else:\n        print(f\"Hello {name} {lastname}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nHere `formal` is a `bool` that is `False` by default.\n\n```\n\nfast →💬 Get the helppython main.py --help\n Usage: main.py [OPTIONS] NAME LASTNAME\n\n╭─ Arguments ─────────────────────────────────────────────────────╮\n│ *    name          TEXT  [default: None] [required]             │\n│ *    lastname      TEXT  [default: None] [required]             │\n╰─────────────────────────────────────────────────────────────────╯\n╭─ Options ───────────────────────────────────────────────────────╮\n│ --formal                --no-formal      [default: no-formal]   │\n│ --help                                   Show this message and  │\n│                                          exit.                  │\n╰─────────────────────────────────────────────────────────────────╯\n\nrestart ↻\n```\n\nTip\n\nNotice that it automatically creates a `--formal` and a `--no-formal` because it detected that `formal` is a `bool`.\n\nNow call it normally:\n\n```\n\nfast →python main.py Camila Gutiérrez\nHello Camila Gutiérrez\n\n💬 But if you pass --formalpython main.py Camila Gutiérrez --formal\nGood day Ms. Camila Gutiérrez.\n\n💬 And as --formal is a CLI option you can put it anywhere in this commandpython main.py Camila --formal Gutiérrez\nGood day Ms. Camila Gutiérrez.\n\npython main.py --formal Camila Gutiérrez\nGood day Ms. Camila Gutiérrez.\n\nrestart ↻\n```\n\n## A _CLI option_ with a value [¶](https://typer.tiangolo.com/tutorial/first-steps/?q=\\#a-cli-option-with-a-value \"Permanent link\")\n\nTo convert the `lastname` from a _CLI argument_ to a _CLI option_, give it a default value of `\"\"`:\n\n[Python 3.8+](#__tabbed_5_1)\n\n```md-code__content\nimport typer\n\ndef main(name: str, lastname: str = \"\", formal: bool = False):\n    if formal:\n        print(f\"Good day Ms. {name} {lastname}.\")\n    else:\n        print(f\"Hello {name} {lastname}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nAs `lastname` now has a default value of `\"\"` (an empty string) it is no longer required in the function, and **Typer** will now by default make it an optional _CLI option_.\n\n```\n\nfast →python main.py --help\n Usage: main.py [OPTIONS] NAME\n\n╭─ Arguments ───────────────────────────────────────────────────────╮\n│ *    name      TEXT  [default: None] [required]                   │\n╰───────────────────────────────────────────────────────────────────╯\n╭─ Options ─────────────────────────────────────────────────────────╮\n│ --lastname                             TEXT                       │\n│ --formal                --no-formal          [default: no-formal] │\n│ --help                                       Show this message    │\n│                                              and exit.            │\n╰───────────────────────────────────────────────────────────────────╯\n\nrestart ↻\n```\n\nTip\n\nNotice the `--lastname`, and notice that it takes a textual value.\n\nA _CLI option_ with a value like `--lastname` (contrary to a _CLI option_ without a value, a `bool` flag, like `--formal` or `--size`) takes as its value whatever is at the _right side_ of the _CLI option_.\n\n```\n\nfast →💬 Call it without a --lastnamepython main.py Camila\nHello Camila\n\n💬 Pass the --lastnamepython main.py Camila --lastname Gutiérrez\nHello Camila Gutiérrez\n\nrestart ↻\n```\n\nTip\n\nNotice that \" `Gutiérrez`\" is at the right side of `--lastname`. A _CLI option_ with a value takes as its value whatever is at the _right side_.\n\nAnd as `--lastname` is now a _CLI option_ that doesn't depend on the order, you can pass it before the name:\n\n```\n\nfast →python main.py --lastname Gutiérrez Camila\n💬 and it will still work normallyHello Camila Gutiérrez\n\nrestart ↻\n```\n\n## Document your CLI app [¶](https://typer.tiangolo.com/tutorial/first-steps/?q=\\#document-your-cli-app \"Permanent link\")\n\nIf you add a docstring to your function it will be used in the help text:\n\n[Python 3.8+](#__tabbed_6_1)\n\n```md-code__content\nimport typer\n\ndef main(name: str, lastname: str = \"\", formal: bool = False):\n    \"\"\"\n    Say hi to NAME, optionally with a --lastname.\n\n    If --formal is used, say hi very formally.\n    \"\"\"\n    if formal:\n        print(f\"Good day Ms. {name} {lastname}.\")\n    else:\n        print(f\"Hello {name} {lastname}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nNow see it with the `--help` option:\n\n```\n\nfast →python main.py --help\n Usage: main.py [OPTIONS] NAME\n\n Say hi to NAME, optionally with a --lastname.\n If --formal is used, say hi very formally.\n\n╭─ Arguments ───────────────────────────────────────────────────────╮\n│ *    name      TEXT  [default: None] [required]                   │\n╰───────────────────────────────────────────────────────────────────╯\n╭─ Options ─────────────────────────────────────────────────────────╮\n│ --lastname                             TEXT                       │\n│ --formal                --no-formal          [default: no-formal] │\n│ --help                                       Show this message    │\n│                                              and exit.            │\n╰───────────────────────────────────────────────────────────────────╯\n\nrestart ↻\n```\n\nTip\n\nThere is another place to document the specific _CLI options_ and _CLI arguments_ that will show up next to them in the help text as with `--install-completion` or `--help`, you will learn that later in the tutorial.\n\n## Arguments, options, parameters, optional, required [¶](https://typer.tiangolo.com/tutorial/first-steps/?q=\\#arguments-options-parameters-optional-required \"Permanent link\")\n\nBe aware that these terms refer to multiple things depending on the context, and sadly, those \"contexts\" mix frequently, so it's easy to get confused.\n\n### In Python [¶](https://typer.tiangolo.com/tutorial/first-steps/?q=\\#in-python \"Permanent link\")\n\nIn Python, the names of the variables in a function, like `name` and `lastname`:\n\n```md-code__content\ndef main(name: str, lastname: str = \"\"):\n    pass\n\n```\n\nare called \"Python function parameters\" or \"Python function arguments\".\n\nTechnical Details\n\nThere's actually a very small distinction in Python between \"parameter\" and \"argument\".\n\nIt's quite technical... and somewhat pedantic.\n\n_Parameter_ refers to the variable name in a function _declaration_. Like:\n\n```md-code__content\ndef bring_person(name: str, lastname: str = \"\"):\n    pass\n\n```\n\n_Argument_ refers to the value passed when _calling_ a function. Like:\n\n```md-code__content\nperson = bring_person(\"Camila\", lastname=\"Gutiérrez\")\n\n```\n\n...but you will probably see them used interchangeably in most of the places (including here).\n\n#### Python default values [¶](https://typer.tiangolo.com/tutorial/first-steps/?q=\\#python-default-values \"Permanent link\")\n\nIn Python, in a function, a parameter with a _default value_ like `lastname` in:\n\n```md-code__content\ndef main(name: str, lastname: str = \"\"):\n    pass\n\n```\n\nis considered an \"optional parameter\" (or \"optional argument\").\n\nThe default value can be anything, like `\"\"` or `None`.\n\nAnd a parameter like `name`, that doesn't have a default value, is considered _required_.\n\n### In CLIs [¶](https://typer.tiangolo.com/tutorial/first-steps/?q=\\#in-clis \"Permanent link\")\n\nWhen talking about command line interface applications, the words **\"argument\"** and **\"parameter\"** are commonly used to refer to that data passed to a CLI app, those parameters.\n\nBut those words **don't imply** anything about the data being required, needing to be passed in a certain order, nor having a flag like `--lastname`.\n\nThe parameters that come with a name like `--lastname` (and optionally a value) are commonly optional, not required. So, when talking about CLIs it's common to call them **optional arguments** or **optional parameters**. Sometimes these _optional parameters_ that start with `--` are also called a **flag** or a **switch**.\n\nIn reality, the parameters that require an order can be made _optional_ too. And the ones that come with a flag (like `--lastname`) can be _required_ too.\n\n### In **Typer** [¶](https://typer.tiangolo.com/tutorial/first-steps/?q=\\#in-typer \"Permanent link\")\n\nTo try and make it a bit easier, we'll normally use the words \"parameter\" or \"argument\" to refer to \"Python functions parameters\" or \"Python functions arguments\".\n\nWe'll use **_CLI argument_** to refer to those _CLI parameters_ that depend on the specific order. That are **required** by default.\n\nAnd we'll use **_CLI option_** to refer to those _CLI parameters_ that depend on a name that starts with `--` (like `--lastname`). That are **optional** by default.\n\nWe will use **_CLI parameter_** to refer to both, _CLI arguments_ and _CLI options_.\n\n## The `typer` Command [¶](https://typer.tiangolo.com/tutorial/first-steps/?q=\\#the-typer-command \"Permanent link\")\n\nWhen you install `typer`, by default it adds a `typer` command to your shell.\n\nThis `typer` command allows you to run your scripts with ✨ auto completion ✨ in your terminal.\n\nAs an alternative to running with Python:\n\n```\n\nfast →python main.py\nHello World\n\nrestart ↻\n```\n\nYou can run with the `typer` command:\n\n```\n\nfast →typer main.py run\nHello World\n\nrestart ↻\n```\n\n...and it will give you auto completion in your terminal when you hit `TAB` for all your code.\n\nSo you can use it to have auto completion for your own scripts as you continue with the tutorial.\n\nTip\n\nYour CLI application built with **Typer** won't need the `typer` command to have auto completion once you create a Python package.\n\nBut for short scripts and for learning, before creating a Python package, it might be useful.\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/first-steps/?q=",
      "ogUrl": "https://typer.tiangolo.com/tutorial/first-steps/",
      "title": "First Steps - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/first-steps/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/first-steps.png",
      "ogTitle": "First Steps - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/first-steps.png",
      "og:title": "First Steps - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/first-steps/?q=",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/first-steps.png",
      "twitter:title": "First Steps - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/prompt/?q=#ask-with-prompt)\n\n# Ask with Prompt [¶](https://typer.tiangolo.com/tutorial/prompt/?q=\\#ask-with-prompt \"Permanent link\")\n\nWhen you need to ask the user for info interactively you should normally use [\\*CLI Option\\*s with Prompt](https://typer.tiangolo.com/tutorial/options/prompt/), because they allow using the CLI program in a non-interactive way (for example, a Bash script could use it).\n\nBut if you absolutely need to ask for interactive information without using a _CLI option_, you can use `typer.prompt()`:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nimport typer\n\ndef main():\n    person_name = typer.prompt(\"What's your name?\")\n    print(f\"Hello {person_name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nCheck it:\n\n```\n\nfast →python main.py\nCamila\nHello Camila\n\nrestart ↻\n```\n\n## Confirm [¶](https://typer.tiangolo.com/tutorial/prompt/?q=\\#confirm \"Permanent link\")\n\nThere's also an alternative to ask for confirmation. Again, if possible, you should use a [_CLI Option_ with a confirmation prompt](https://typer.tiangolo.com/tutorial/options/prompt/):\n\n[Python 3.8+](#__tabbed_2_1)\n\n```md-code__content\nimport typer\n\ndef main():\n    delete = typer.confirm(\"Are you sure you want to delete it?\")\n    if not delete:\n        print(\"Not deleting\")\n        raise typer.Abort()\n    print(\"Deleting it!\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nCheck it:\n\n```\n\nfast →python main.py\ny\nDeleting it!\n\n💬 This time cancel itpython main.py\nn\nNot deleting\nAborted!\n\nrestart ↻\n```\n\n## Confirm or abort [¶](https://typer.tiangolo.com/tutorial/prompt/?q=\\#confirm-or-abort \"Permanent link\")\n\nAs it's very common to abort if the user doesn't confirm, there's an integrated parameter `abort` that does it automatically:\n\n[Python 3.8+](#__tabbed_3_1)\n\n```md-code__content\nimport typer\n\ndef main():\n    delete = typer.confirm(\"Are you sure you want to delete it?\", abort=True)\n    print(\"Deleting it!\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n```\n\nfast →python main.py\ny\nDeleting it!\n\n💬 This time cancel itpython main.py\nn\nAborted!\n\nrestart ↻\n```\n\n## Prompt with Rich [¶](https://typer.tiangolo.com/tutorial/prompt/?q=\\#prompt-with-rich \"Permanent link\")\n\nIf you installed Rich as described in [Printing and Colors](https://typer.tiangolo.com/tutorial/printing/), you can use Rich to prompt the user for input:\n\n[Python 3.8+](#__tabbed_4_1)\n\n```md-code__content\nimport typer\nfrom rich.prompt import Prompt\n\ndef main():\n    name = Prompt.ask(\"Enter your name :sunglasses:\")\n    print(f\"Hey there {name}!\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nAnd when you run it, it will look like:\n\n```\n\nfast →python main.py\nMorty\nHello Morty\n\nrestart ↻\n```\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/prompt/?q=",
      "ogUrl": "https://typer.tiangolo.com/tutorial/prompt/",
      "title": "Ask with Prompt - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/prompt/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/prompt.png",
      "ogTitle": "Ask with Prompt - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/prompt.png",
      "og:title": "Ask with Prompt - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/prompt/?q=",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/prompt.png",
      "twitter:title": "Ask with Prompt - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/arguments/default/?q=#cli-arguments-with-default)\n\n# CLI Arguments with Default [¶](https://typer.tiangolo.com/tutorial/arguments/default/?q=\\#cli-arguments-with-default \"Permanent link\")\n\nWe can also use the same `typer.Argument()` to set a default value.\n\nThat way the _CLI argument_ will be optional _and also_ have a default value.\n\n## An optional _CLI argument_ with a default [¶](https://typer.tiangolo.com/tutorial/arguments/default/?q=\\#an-optional-cli-argument-with-a-default \"Permanent link\")\n\nWe can also use `typer.Argument()` to make a _CLI argument_ have a default value other than `None`:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(name: Annotated[str, typer.Argument()] = \"Wade Wilson\"):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_2_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(name: str = typer.Argument(\"Wade Wilson\")):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nTip\n\nBecause now the value will be a `str` passed by the user or the default value of `\"Wade Wilson\"` which is also a `str`, we know the value will never be `None`, so we don't have to (and shouldn't) use `Optional[str]`.\n\nHave in mind that the `Optional[something]` tells Python that a value \"could be `None`\". But the use of `Optional` doesn't affect Typer in any way, e.g. it doesn't tell Typer if a value is required or not.\n\nCheck it:\n\n```\n\nfast →💬 Check the helppython main.py --help\n💬 Notice the [default: Wade Wilson] ✨Usage: main.py [OPTIONS] [NAME]\n\nArguments:\n  [NAME]  [default: Wade Wilson]\n\nOptions:\n  --help                Show this message and exit.\n\n💬 With no optional CLI argumentpython main.py\nHello Wade Wilson\n\n💬 With one CLI argumentpython main.py Camila\nHello Camila\n\nrestart ↻\n```\n\n## Dynamic default value [¶](https://typer.tiangolo.com/tutorial/arguments/default/?q=\\#dynamic-default-value \"Permanent link\")\n\nAnd we can even make the default value be dynamically generated by passing a function as the `default_factory` argument:\n\n[Python 3.8+](#__tabbed_3_1)\n\n```md-code__content\nimport random\n\nimport typer\nfrom typing_extensions import Annotated\n\ndef get_name():\n    return random.choice([\"Deadpool\", \"Rick\", \"Morty\", \"Hiro\"])\n\ndef main(name: Annotated[str, typer.Argument(default_factory=get_name)]):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_4_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport random\n\nimport typer\n\ndef get_name():\n    return random.choice([\"Deadpool\", \"Rick\", \"Morty\", \"Hiro\"])\n\ndef main(name: str = typer.Argument(default_factory=get_name)):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nIn this case, we created the function `get_name` that will just return a random `str` each time.\n\nAnd we pass it as the first function argument to `typer.Argument()`.\n\nTip\n\nThe word \"factory\" in `default_factory` is just a fancy way of saying \"function that will create the default value\".\n\nCheck it:\n\n```\n\nfast →💬 Check the helppython main.py --help\nUsage: main.py [OPTIONS] [NAME]\n\nArguments:\n  [NAME]  [default: (dynamic)]\n\nOptions:\n  --help                Show this message and exit.\n\n💬 Try it several times, it will use a random default each timepython main.py\nHello Deadpool\n\npython main.py\nHello Hiro\n\npython main.py\nHello Rick\n\n💬 Now pass a value for the CLI argumentpython main.py Camila\nHello Camila\n\nrestart ↻\n```\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/arguments/default/?q=",
      "ogUrl": "https://typer.tiangolo.com/tutorial/arguments/default/",
      "title": "CLI Arguments with Default - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/arguments/default/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/arguments/default.png",
      "ogTitle": "CLI Arguments with Default - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/arguments/default.png",
      "og:title": "CLI Arguments with Default - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/arguments/default/?q=",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/arguments/default.png",
      "twitter:title": "CLI Arguments with Default - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/progressbar/?q=#progress-bar)\n\n# Progress Bar [¶](https://typer.tiangolo.com/tutorial/progressbar/?q=\\#progress-bar \"Permanent link\")\n\nIf you are executing an operation that can take some time, you can inform it to the user. 🤓\n\n## Progress Bar [¶](https://typer.tiangolo.com/tutorial/progressbar/?q=\\#progress-bar_1 \"Permanent link\")\n\nYou can use [Rich's Progress Display](https://rich.readthedocs.io/en/stable/progress.html) to show a progress bar, for example:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nimport time\n\nimport typer\nfrom rich.progress import track\n\ndef main():\n    total = 0\n    for value in track(range(100), description=\"Processing...\"):\n        # Fake processing time\n        time.sleep(0.01)\n        total += 1\n    print(f\"Processed {total} things.\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nYou put the thing that you want to iterate over inside of Rich's `track()`, and then iterate over that.\n\nCheck it:\n\n```\n\nfast →python main.py\n\nProcessed 100 things.\n\nrestart ↻\n```\n\n...actually, it will look a lot prettier. ✨ But I can't show you the animation here in the docs. 😅\n\nThe colors and information will look something like this:\n\n```\n\nfast →python main.py\nProcessing... ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━╸━━━━━━━━━━  74% 0:00:01\n\nrestart ↻\n```\n\n## Spinner [¶](https://typer.tiangolo.com/tutorial/progressbar/?q=\\#spinner \"Permanent link\")\n\nWhen you don't know how long the operation will take, you can use a spinner instead.\n\nRich allows you to display many things in complex and advanced ways.\n\nFor example, this will show two spinners:\n\n[Python 3.8+](#__tabbed_2_1)\n\n```md-code__content\nimport time\n\nimport typer\nfrom rich.progress import Progress, SpinnerColumn, TextColumn\n\ndef main():\n    with Progress(\n        SpinnerColumn(),\n        TextColumn(\"[progress.description]{task.description}\"),\n        transient=True,\n    ) as progress:\n        progress.add_task(description=\"Processing...\", total=None)\n        progress.add_task(description=\"Preparing...\", total=None)\n        time.sleep(5)\n    print(\"Done!\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nI can't show you the beautiful animation here in the docs. 😅\n\nBut at some point in time it will look like this (imagine it's spinning). 🤓\n\n```\n\nfast →python main.py\n⠹ Processing...\n⠹ Preparing...\n\nrestart ↻\n```\n\nYou can learn more about it in the [Rich docs for Progress Display](https://rich.readthedocs.io/en/stable/progress.html).\n\n## Typer `progressbar` [¶](https://typer.tiangolo.com/tutorial/progressbar/?q=\\#typer-progressbar \"Permanent link\")\n\nIf you can, you should use **Rich** as explained above, it has more features, it's more advanced, and can display information more beautifully. ✨\n\nTip\n\nIf you can use Rich, use the information above, the Rich docs, and skip the rest of this page. 😎\n\nBut if you can't use Rich, Typer (actually Click) comes with a simple utility to show progress bars.\n\nInfo\n\n`typer.progressbar()` comes directly from Click, you can read more about it in [Click's docs](https://click.palletsprojects.com/en/8.1.x/utils/#showing-progress-bars).\n\n### Use `typer.progressbar` [¶](https://typer.tiangolo.com/tutorial/progressbar/?q=\\#use-typerprogressbar \"Permanent link\")\n\nTip\n\nRemember, you are much better off using [Rich](https://rich.readthedocs.io/) for this. 😎\n\nYou can use `typer.progressbar()` with a `with` statement, as in:\n\n```md-code__content\nwith typer.progressbar(something) as progress:\n    pass\n\n```\n\nAnd you pass as function argument to `typer.progressbar()` the thing that you would normally iterate over.\n\n[Python 3.8+](#__tabbed_3_1)\n\n```md-code__content\nimport time\n\nimport typer\n\ndef main():\n    total = 0\n    with typer.progressbar(range(100)) as progress:\n        for value in progress:\n            # Fake processing time\n            time.sleep(0.01)\n            total += 1\n    print(f\"Processed {total} things.\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nSo, if you have a list of users, this could be:\n\n```md-code__content\nusers = [\"Camila\", \"Rick\", \"Morty\"]\n\nwith typer.progressbar(users) as progress:\n    pass\n\n```\n\nAnd the `with` statement using `typer.progressbar()` gives you an object that you can iterate over, just like if it was the same thing that you would iterate over normally.\n\nBut by iterating over this object **Typer** (actually Click) will know to update the progress bar:\n\n```md-code__content\nusers = [\"Camila\", \"Rick\", \"Morty\"]\n\nwith typer.progressbar(users) as progress:\n    for user in progress:\n        typer.echo(user)\n\n```\n\nTip\n\nNotice that there are 2 levels of code blocks. One for the `with` statement and one for the `for` statement.\n\nInfo\n\nThis is mostly useful for operations that take some time.\n\nIn the example above we are faking it with `time.sleep()`.\n\nCheck it:\n\n```\n\nfast →python main.py\n\nProcessed 100 things.\n\nrestart ↻\n```\n\n### Setting a Progress Bar `length` [¶](https://typer.tiangolo.com/tutorial/progressbar/?q=\\#setting-a-progress-bar-length \"Permanent link\")\n\nTip\n\nRemember, you are much better off using [Rich](https://rich.readthedocs.io/) for this. 😎\n\nThe progress bar is generated from the length of the iterable (e.g. the list of users).\n\nBut if the length is not available (for example, with something that fetches a new user from a web API each time) you can pass an explicit `length` to `typer.progressbar()`.\n\n[Python 3.8+](#__tabbed_4_1)\n\n```md-code__content\nimport time\n\nimport typer\n\ndef iterate_user_ids():\n    # Let's imagine this is a web API, not a range()\n    for i in range(100):\n        yield i\n\ndef main():\n    total = 0\n    with typer.progressbar(iterate_user_ids(), length=100) as progress:\n        for value in progress:\n            # Fake processing time\n            time.sleep(0.01)\n            total += 1\n    print(f\"Processed {total} user IDs.\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nCheck it:\n\n```\n\nfast →python main.py\n\nProcessed 100 user IDs.\n\nrestart ↻\n```\n\n#### About the function with `yield` [¶](https://typer.tiangolo.com/tutorial/progressbar/?q=\\#about-the-function-with-yield \"Permanent link\")\n\nIf you hadn't seen something like that `yield` above, that's a \" [generator](https://docs.python.org/3/glossary.html#term-generator)\".\n\nYou can iterate over that function with a `for` and at each iteration it will give you the value at `yield`.\n\n`yield` is like a `return` that gives values multiple times and let's you use the function in a `for` loop.\n\nFor example:\n\n```md-code__content\ndef iterate_user_ids():\n    # Let's imagine this is a web API, not a range()\n    for i in range(100):\n        yield i\n\nfor i in iterate_user_ids():\n    print(i)\n\n```\n\nwould print each of the \"user IDs\" (here it's just the numbers from `0` to `99`).\n\n### Add a `label` [¶](https://typer.tiangolo.com/tutorial/progressbar/?q=\\#add-a-label \"Permanent link\")\n\nTip\n\nRemember, you are much better off using [Rich](https://rich.readthedocs.io/) for this. 😎\n\nYou can also set a `label`:\n\n[Python 3.8+](#__tabbed_5_1)\n\n```md-code__content\nimport time\n\nimport typer\n\ndef main():\n    total = 0\n    with typer.progressbar(range(100), label=\"Processing\") as progress:\n        for value in progress:\n            # Fake processing time\n            time.sleep(0.01)\n            total += 1\n    print(f\"Processed {total} things.\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nCheck it:\n\nfast →\n\n## Iterate manually [¶](https://typer.tiangolo.com/tutorial/progressbar/?q=\\#iterate-manually \"Permanent link\")\n\nIf you need to manually iterate over something and update the progress bar irregularly, you can do it by not passing an iterable but just a `length` to `typer.progressbar()`.\n\nAnd then calling the `.update()` method in the object from the `with` statement:\n\n[Python 3.8+](#__tabbed_6_1)\n\n```md-code__content\nimport time\n\nimport typer\n\ndef main():\n    total = 1000\n    with typer.progressbar(length=total) as progress:\n        for batch in range(4):\n            # Fake processing time\n            time.sleep(1)\n            # Increment by 250 on each loop iteration\n            # (it will take 4 seconds to reach 1000)\n            progress.update(250)\n    print(f\"Processed {total} things in batches.\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nCheck it:\n\nfast →\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/progressbar/?q=",
      "ogUrl": "https://typer.tiangolo.com/tutorial/progressbar/",
      "title": "Progress Bar - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/progressbar/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/progressbar.png",
      "ogTitle": "Progress Bar - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/progressbar.png",
      "og:title": "Progress Bar - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/progressbar/?q=",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/progressbar.png",
      "twitter:title": "Progress Bar - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/subcommands/add-typer/?q=#add-typer)\n\n# Add Typer [¶](https://typer.tiangolo.com/tutorial/subcommands/add-typer/?q=\\#add-typer \"Permanent link\")\n\nWe'll start with the core idea.\n\nTo add a `typer.Typer()` app inside of another.\n\n## Manage items [¶](https://typer.tiangolo.com/tutorial/subcommands/add-typer/?q=\\#manage-items \"Permanent link\")\n\nLet's imagine that you are creating a _CLI program_ to manage items in some distant land.\n\nIt could be in an `items.py` file with this:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\n\n@app.command()\ndef create(item: str):\n    print(f\"Creating item: {item}\")\n\n@app.command()\ndef delete(item: str):\n    print(f\"Deleting item: {item}\")\n\n@app.command()\ndef sell(item: str):\n    print(f\"Selling item: {item}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nAnd you would use it like:\n\n```\n\nfast →python items.py create Wand\nCreating item: Wand\n\nrestart ↻\n```\n\n## Manage users [¶](https://typer.tiangolo.com/tutorial/subcommands/add-typer/?q=\\#manage-users \"Permanent link\")\n\nBut then you realize that you also have to manage users from your _CLI app_.\n\nIt could be a file `users.py` with something like:\n\n[Python 3.8+](#__tabbed_2_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\n\n@app.command()\ndef create(user_name: str):\n    print(f\"Creating user: {user_name}\")\n\n@app.command()\ndef delete(user_name: str):\n    print(f\"Deleting user: {user_name}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nAnd you would use it like:\n\n```\n\nfast →python users.py create Camila\nCreating user: Camila\n\nrestart ↻\n```\n\n## Put them together [¶](https://typer.tiangolo.com/tutorial/subcommands/add-typer/?q=\\#put-them-together \"Permanent link\")\n\nBoth parts are similar. In fact, `items.py` and `users.py` both have commands `create` and `delete`.\n\nBut we need them to be part of the same _CLI program_.\n\nIn this case, as with `git remote`, we can put them together as subcommands in another `typer.Typer()` _CLI program_.\n\nNow create a `main.py` with:\n\n[Python 3.8+](#__tabbed_3_1)\n\n```md-code__content\nimport typer\n\nimport items\nimport users\n\napp = typer.Typer()\napp.add_typer(users.app, name=\"users\")\napp.add_typer(items.app, name=\"items\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nHere's what we do in `main.py`:\n\n- Import the other Python modules (the files `users.py` and `items.py`).\n- Create the main `typer.Typer()` application.\n- Use `app.add_typer()` to include the `app` from `items.py` and `users.py`, each of those 2 was also created with `typer.Typer()`.\n- Define a `name` with the command that will be used for each of these \"sub-Typers\" to group their own commands.\n\nAnd now your _CLI program_ has 2 commands:\n\n- `users`: with all of the commands (subcommands) in the `app` from `users.py`.\n- `items` with all the commands (subcommands) in the `app` from `items.py`.\n\nCheck it:\n\n```\n\nfast →💬 Check the helppython main.py --help\nUsage: main.py [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  --install-completion  Install completion for the current shell.\n  --show-completion     Show completion for the current shell, to copy it or customize the installation.\n  --help                Show this message and exit.\n\nCommands:\n  items\n  users\n\nrestart ↻\n```\n\nNow you have a _CLI program_ with commands `items` and `users`, and they in turn have their own commands (subcommands).\n\nLet's check the `items` command:\n\n```\n\nfast →💬 Check the help for itemspython main.py items --help\n💬 It shows its own commands (subcommands): create, delete, sellUsage: main.py items [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  create\n  delete\n  sell\n\n💬 Try itpython main.py items create Wand\nCreating item: Wand\n\npython main.py items sell Vase\nSelling item: Vase\n\nrestart ↻\n```\n\nTip\n\nNotice that we are still calling `$ python main.py` but now we are using the command `items`.\n\nAnd now check the command `users`, with all its subcommands:\n\n```\n\nfast →python main.py users --help\nUsage: main.py users [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  create\n  delete\n\n💬 Try itpython main.py users create Camila\nCreating user: Camila\n\nrestart ↻\n```\n\n## Recap [¶](https://typer.tiangolo.com/tutorial/subcommands/add-typer/?q=\\#recap \"Permanent link\")\n\nThat's the core idea.\n\nYou can just create `typer.Typer()` apps and add them inside one another.\n\nAnd you can do that with any levels of commands that you want.\n\nDo you need sub-sub-sub-subcommands? Go ahead, create all the `typer.Typer()` s you need and put them together with `app.add_typer()`.\n\nIn the next sections we'll update this with more features, but you already have the core idea.\n\nThis way, in the same spirit of Click, **Typer** applications are composable, each `typer.Typer()` can be a _CLI app_ by itself, but it can also be added as a command group to another Typer app.\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/subcommands/add-typer/?q=",
      "ogUrl": "https://typer.tiangolo.com/tutorial/subcommands/add-typer/",
      "title": "Add Typer - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/subcommands/add-typer/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/subcommands/add-typer.png",
      "ogTitle": "Add Typer - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/subcommands/add-typer.png",
      "og:title": "Add Typer - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/subcommands/add-typer/?q=",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/subcommands/add-typer.png",
      "twitter:title": "Add Typer - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/arguments/envvar/?q=#cli-arguments-with-environment-variables)\n\n# CLI Arguments with Environment Variables [¶](https://typer.tiangolo.com/tutorial/arguments/envvar/?q=\\#cli-arguments-with-environment-variables \"Permanent link\")\n\nYou can also configure a _CLI argument_ to read a value from an environment variable if it is not provided in the command line as a _CLI argument_.\n\nTip\n\nYou can learn more about environment variables in the [Environment Variables](https://typer.tiangolo.com/environment-variables/) page.\n\nTo do that, use the `envvar` parameter for `typer.Argument()`:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(name: Annotated[str, typer.Argument(envvar=\"AWESOME_NAME\")] = \"World\"):\n    print(f\"Hello Mr. {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_2_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(name: str = typer.Argument(\"World\", envvar=\"AWESOME_NAME\")):\n    print(f\"Hello Mr. {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nIn this case, the _CLI argument_ `name` will have a default value of `\"World\"`, but will also read any value passed to the environment variable `AWESOME_NAME` if no value is provided in the command line:\n\n```\n\nfast →💬 Check the helppython main.py --help\nUsage: main.py [OPTIONS] [NAME]\n\nArguments:\n  [NAME]  [env var: AWESOME_NAME;default: World]\n\nOptions:\n  --help                Show this message and exit.\n\n💬 Call it without a CLI argumentpython main.py\nHello Mr. World\n\n💬 Now pass a value for the CLI argumentpython main.py Czernobog\nHello Mr. Czernobog\n\n💬 And now use the environment variableAWESOME_NAME=Wednesday python main.py\nHello Mr. Wednesday\n\n💬 CLI arguments take precedence over env varsAWESOME_NAME=Wednesday python main.py Czernobog\nHello Mr. Czernobog\n\nrestart ↻\n```\n\n## Multiple environment variables [¶](https://typer.tiangolo.com/tutorial/arguments/envvar/?q=\\#multiple-environment-variables \"Permanent link\")\n\nYou are not restricted to a single environment variable, you can declare a list of environment variables that could be used to get a value if it was not passed in the command line:\n\n[Python 3.8+](#__tabbed_3_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(\n    name: Annotated[str, typer.Argument(envvar=[\"AWESOME_NAME\", \"GOD_NAME\"])] = \"World\",\n):\n    print(f\"Hello Mr. {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_4_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(name: str = typer.Argument(\"World\", envvar=[\"AWESOME_NAME\", \"GOD_NAME\"])):\n    print(f\"Hello Mr. {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nCheck it:\n\n```\n\nfast →💬 Check the helppython main.py --help\nUsage: main.py [OPTIONS] [NAME]\n\nArguments:\n  [NAME]  [env var: AWESOME_NAME, GOD_NAME;default: World]\n\nOptions:\n  --help                Show this message and exit.\n\n💬 Try the first env varAWESOME_NAME=Wednesday python main.py\nHello Mr. Wednesday\n\n💬 Try the second env varGOD_NAME=Anubis python main.py\nHello Mr. Anubis\n\nrestart ↻\n```\n\n## Hide an env var from the help text [¶](https://typer.tiangolo.com/tutorial/arguments/envvar/?q=\\#hide-an-env-var-from-the-help-text \"Permanent link\")\n\nBy default, environment variables used will be shown in the help text, but you can disable them with `show_envvar=False`:\n\n[Python 3.8+](#__tabbed_5_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(\n    name: Annotated[\\\n        str, typer.Argument(envvar=\"AWESOME_NAME\", show_envvar=False)\\\n    ] = \"World\",\n):\n    print(f\"Hello Mr. {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_6_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(name: str = typer.Argument(\"World\", envvar=\"AWESOME_NAME\", show_envvar=False)):\n    print(f\"Hello Mr. {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nCheck it:\n\n```\n\nfast →//Check the helppython main.py --help\n💬 It won't show the env varUsage: main.py [OPTIONS] [NAME]\n\nArguments:\n  [NAME]  [default: World]\n\nOptions:\n  --help                Show this message and exit.\n\n💬 But it will still be able to use itAWESOME_NAME=Wednesday python main.py\nHello Mr. Wednesday\n\nrestart ↻\n```\n\nTechnical Details\n\nIn Click applications the env vars are hidden by default. 🙈\n\nIn **Typer** these env vars are shown by default. 👀\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/arguments/envvar/?q=",
      "ogUrl": "https://typer.tiangolo.com/tutorial/arguments/envvar/",
      "title": "CLI Arguments with Environment Variables - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/arguments/envvar/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/arguments/envvar.png",
      "ogTitle": "CLI Arguments with Environment Variables - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/arguments/envvar.png",
      "og:title": "CLI Arguments with Environment Variables - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/arguments/envvar/?q=",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/arguments/envvar.png",
      "twitter:title": "CLI Arguments with Environment Variables - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/options/prompt/?q=#cli-option-prompt)\n\n# CLI Option Prompt [¶](https://typer.tiangolo.com/tutorial/options/prompt/?q=\\#cli-option-prompt \"Permanent link\")\n\nIt's also possible to, instead of just showing an error, ask for the missing value with `prompt=True`:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(name: str, lastname: Annotated[str, typer.Option(prompt=True)]):\n    print(f\"Hello {name} {lastname}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_2_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(name: str, lastname: str = typer.Option(..., prompt=True)):\n    print(f\"Hello {name} {lastname}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nAnd then your program will ask the user for it in the terminal:\n\n```\n\nfast →💬 Call it with the NAME CLI argumentpython main.py Camila\n💬 It asks for the missing CLI option --lastnameGutiérrez\nHello Camila Gutiérrez\n\nrestart ↻\n```\n\n## Customize the prompt [¶](https://typer.tiangolo.com/tutorial/options/prompt/?q=\\#customize-the-prompt \"Permanent link\")\n\nYou can also set a custom prompt, passing the string that you want to use instead of just `True`:\n\n[Python 3.8+](#__tabbed_3_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(\n    name: str,\n    lastname: Annotated[str, typer.Option(prompt=\"Please tell me your last name\")],\n):\n    print(f\"Hello {name} {lastname}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_4_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(\n    name: str, lastname: str = typer.Option(..., prompt=\"Please tell me your last name\")\n):\n    print(f\"Hello {name} {lastname}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nAnd then your program will ask for it using with your custom prompt:\n\n```\n\nfast →💬 Call it with the NAME CLI argumentpython main.py Camila\n💬 It uses the custom promptGutiérrez\nHello Camila Gutiérrez\n\nrestart ↻\n```\n\n## Confirmation prompt [¶](https://typer.tiangolo.com/tutorial/options/prompt/?q=\\#confirmation-prompt \"Permanent link\")\n\nIn some cases you could want to prompt for something and then ask the user to confirm it by typing it twice.\n\nYou can do it passing the parameter `confirmation_prompt=True`.\n\nLet's say it's a CLI app to delete a project:\n\n[Python 3.8+](#__tabbed_5_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(\n    project_name: Annotated[str, typer.Option(prompt=True, confirmation_prompt=True)],\n):\n    print(f\"Deleting project {project_name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_6_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(project_name: str = typer.Option(..., prompt=True, confirmation_prompt=True)):\n    print(f\"Deleting project {project_name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nAnd it will prompt the user for a value and then for the confirmation:\n\n```\n\nfast →python main.py\n💬 Your app will first prompt for the project name, and then for the confirmationOld ProjectOld Project\nDeleting project Old Project\n\n💬 If the user doesn't type the same, receives an error and a new promptpython main.py\nOld ProjectNew Spice\nError: The two entered values do not match\n\nOld ProjectOld Project\nDeleting project Old Project\n\n💬 Now it works 🎉\nrestart ↻\n```\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/options/prompt/?q=",
      "ogUrl": "https://typer.tiangolo.com/tutorial/options/prompt/",
      "title": "CLI Option Prompt - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/options/prompt/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/options/prompt.png",
      "ogTitle": "CLI Option Prompt - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/options/prompt.png",
      "og:title": "CLI Option Prompt - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/options/prompt/?q=",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/options/prompt.png",
      "twitter:title": "CLI Option Prompt - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/app-dir/?q=#cli-application-directory)\n\n# CLI Application Directory [¶](https://typer.tiangolo.com/tutorial/app-dir/?q=\\#cli-application-directory \"Permanent link\")\n\nYou can get the application directory where you can, for example, save configuration files with `typer.get_app_dir()`:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nfrom pathlib import Path\n\nimport typer\n\nAPP_NAME = \"my-super-cli-app\"\n\ndef main():\n    app_dir = typer.get_app_dir(APP_NAME)\n    config_path: Path = Path(app_dir) / \"config.json\"\n    if not config_path.is_file():\n        print(\"Config file doesn't exist yet\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nIt will give you a directory for storing configurations appropriate for your CLI program for the current user in each operating system.\n\nCheck it:\n\n```\n\nfast →python main.py\nConfig file doesn't exist yet\n\nrestart ↻\n```\n\n## About `Path` [¶](https://typer.tiangolo.com/tutorial/app-dir/?q=\\#about-path \"Permanent link\")\n\nIf you hadn't seen something like that:\n\n```md-code__content\nPath(app_dir) / \"config.json\"\n\n```\n\nA `Path` object can be used with `/` and it will convert it to the separator for the current system ( `/` for Unix systems and `\\` for Windows).\n\nIf the first element is a `Path` object the next ones (after the `/`) can be `str`.\n\nAnd it will create a new `Path` object from that.\n\nIf you want a quick guide on using `Path()` you can check [this post on Real Python](https://realpython.com/python-pathlib/) or [this post by Trey Hunner](https://treyhunner.com/2018/12/why-you-should-be-using-pathlib/).\n\nIn the code above, we are also explicitly declaring `config_path` as having type `Path` to help the editor provide completion and type checks:\n\n```md-code__content\nconfig_path: Path = Path(app_dir) / \"config.json\"\n\n```\n\nOtherwise it could think it's a sub-type (a `PurePath`) and stop providing completion for some methods.\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/app-dir/?q=",
      "ogUrl": "https://typer.tiangolo.com/tutorial/app-dir/",
      "title": "CLI Application Directory - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/app-dir/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/app-dir.png",
      "ogTitle": "CLI Application Directory - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/app-dir.png",
      "og:title": "CLI Application Directory - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/app-dir/?q=",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/app-dir.png",
      "twitter:title": "CLI Application Directory - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/commands/name/?q=#custom-command-name)\n\n# Custom Command Name [¶](https://typer.tiangolo.com/tutorial/commands/name/?q=\\#custom-command-name \"Permanent link\")\n\nBy default, the command names are generated from the function name.\n\nSo, if your function is something like:\n\n```md-code__content\ndef create(username: str):\n    ...\n\n```\n\nThen the command name will be `create`.\n\nBut if you already had a function called `create()` somewhere in your code, you would have to name your CLI function differently.\n\nAnd what if you wanted the command to still be named `create`?\n\nFor this, you can set the name of the command in the first parameter for the `@app.command()` decorator:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\n\n@app.command(\"create\")\ndef cli_create_user(username: str):\n    print(f\"Creating user: {username}\")\n\n@app.command(\"delete\")\ndef cli_delete_user(username: str):\n    print(f\"Deleting user: {username}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nNow, even though the functions are named `cli_create_user()` and `cli_delete_user()`, the commands will still be named `create` and `delete`:\n\n```\n\nfast →python main.py --help\nUsage: main.py [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  --install-completion  Install completion for the current shell.\n  --show-completion     Show completion for the current shell, to copy it or customize the installation.\n  --help                Show this message and exit.\n\nCommands:\n  create\n  delete\n\n💬 Test itpython main.py create Camila\nCreating user: Camila\n\nrestart ↻\n```\n\nNote that any underscores in the function name will be replaced with dashes.\n\nSo if your function is something like:\n\n```md-code__content\ndef create_user(username: str):\n    ...\n\n```\n\nThen the command name will be `create-user`.\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/commands/name/?q=",
      "ogUrl": "https://typer.tiangolo.com/tutorial/commands/name/",
      "title": "Custom Command Name - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/commands/name/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/commands/name.png",
      "ogTitle": "Custom Command Name - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/commands/name.png",
      "og:title": "Custom Command Name - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/commands/name/?q=",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/commands/name.png",
      "twitter:title": "Custom Command Name - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/testing/?q=#testing)\n\n# Testing [¶](https://typer.tiangolo.com/tutorial/testing/?q=\\#testing \"Permanent link\")\n\nTesting **Typer** applications is very easy with [pytest](https://docs.pytest.org/en/latest/).\n\nLet's say you have an application `app/main.py` with:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nfrom typing import Optional\n\nimport typer\n\napp = typer.Typer()\n\n@app.command()\ndef main(name: str, city: Optional[str] = None):\n    print(f\"Hello {name}\")\n    if city:\n        print(f\"Let's have a coffee in {city}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nSo, you would use it like:\n\n```\n\nfast →python main.py Camila --city Berlin\nHello Camila\nLet's have a coffee in Berlin\n\nrestart ↻\n```\n\nAnd the directory also has an empty `app/__init__.py` file.\n\nSo, the `app` is a \"Python package\".\n\n## Test the app [¶](https://typer.tiangolo.com/tutorial/testing/?q=\\#test-the-app \"Permanent link\")\n\n### Import and create a `CliRunner` [¶](https://typer.tiangolo.com/tutorial/testing/?q=\\#import-and-create-a-clirunner \"Permanent link\")\n\nCreate another file/module `app/test_main.py`.\n\nImport `CliRunner` and create a `runner` object.\n\nThis runner is what will \"invoke\" or \"call\" your command line application.\n\n[Python 3.8+](#__tabbed_2_1)\n\n```md-code__content\nfrom typer.testing import CliRunner\n\nfrom .main import app\n\nrunner = CliRunner()\n\ndef test_app():\n    result = runner.invoke(app, [\"Camila\", \"--city\", \"Berlin\"])\n    assert result.exit_code == 0\n    assert \"Hello Camila\" in result.stdout\n    assert \"Let's have a coffee in Berlin\" in result.stdout\n\n```\n\nTip\n\nIt's important that the name of the file starts with `test_`, that way pytest will be able to detect it and use it automatically.\n\n### Call the app [¶](https://typer.tiangolo.com/tutorial/testing/?q=\\#call-the-app \"Permanent link\")\n\nThen create a function `test_app()`.\n\nAnd inside of the function, use the `runner` to `invoke` the application.\n\nThe first parameter to `runner.invoke()` is a `Typer` app.\n\nThe second parameter is a `list` of `str`, with all the text you would pass in the command line, right as you would pass it:\n\n[Python 3.8+](#__tabbed_3_1)\n\n```md-code__content\nfrom typer.testing import CliRunner\n\nfrom .main import app\n\nrunner = CliRunner()\n\ndef test_app():\n    result = runner.invoke(app, [\"Camila\", \"--city\", \"Berlin\"])\n    assert result.exit_code == 0\n    assert \"Hello Camila\" in result.stdout\n    assert \"Let's have a coffee in Berlin\" in result.stdout\n\n```\n\nTip\n\nThe name of the function has to start with `test_`, that way pytest can detect it and use it automatically.\n\n### Check the result [¶](https://typer.tiangolo.com/tutorial/testing/?q=\\#check-the-result \"Permanent link\")\n\nThen, inside of the test function, add `assert` statements to ensure that everything in the result of the call is as it should be.\n\n[Python 3.8+](#__tabbed_4_1)\n\n```md-code__content\nfrom typer.testing import CliRunner\n\nfrom .main import app\n\nrunner = CliRunner()\n\ndef test_app():\n    result = runner.invoke(app, [\"Camila\", \"--city\", \"Berlin\"])\n    assert result.exit_code == 0\n    assert \"Hello Camila\" in result.stdout\n    assert \"Let's have a coffee in Berlin\" in result.stdout\n\n```\n\nHere we are checking that the exit code is 0, as it is for programs that exit without errors.\n\nThen we check that the text printed to \"standard output\" contains the text that our CLI program prints.\n\nTip\n\nYou could also check `result.stderr` for \"standard error\" independently from \"standard output\" if your `CliRunner` instance is created with the `mix_stderr=False` argument.\n\nInfo\n\nIf you need a refresher about what is \"standard output\" and \"standard error\" check the section in [Printing and Colors: \"Standard Output\" and \"Standard Error\"](https://typer.tiangolo.com/tutorial/printing/#standard-output-and-standard-error).\n\n### Call `pytest` [¶](https://typer.tiangolo.com/tutorial/testing/?q=\\#call-pytest \"Permanent link\")\n\nThen you can call `pytest` in your directory and it will run your tests:\n\n```\n\nfast →pytest\n================ test session starts ================\nplatform linux -- Python 3.10, pytest-5.3.5, py-1.8.1, pluggy-0.13.1\nrootdir: /home/user/code/superawesome-cli/app\nplugins: forked-1.1.3, xdist-1.31.0, cov-2.8.1\ncollected 1 item\n\ntest_main.py .                                 [100%]\n\n================= 1 passed in 0.03s =================\n\nrestart ↻\n```\n\n## Testing input [¶](https://typer.tiangolo.com/tutorial/testing/?q=\\#testing-input \"Permanent link\")\n\nIf you have a CLI with prompts, like:\n\n[Python 3.8+](#__tabbed_5_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\napp = typer.Typer()\n\n@app.command()\ndef main(name: str, email: Annotated[str, typer.Option(prompt=True)]):\n    print(f\"Hello {name}, your email is: {email}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nThat you would use like:\n\n```\n\nfast →python main.py Camila\ncamila@example.com\nHello Camila, your email is: camila@example.com\n\nrestart ↻\n```\n\nYou can test the input typed in the terminal using `input=\"camila@example.com\\n\"`.\n\nThis is because what you type in the terminal goes to \" **standard input**\" and is handled by the operating system as if it was a \"virtual file\".\n\nInfo\n\nIf you need a refresher about what is \"standard output\", \"standard error\", and \"standard input\" check the section in [Printing and Colors: \"Standard Output\" and \"Standard Error\"](https://typer.tiangolo.com/tutorial/printing/#standard-output-and-standard-error).\n\nWhen you hit the `ENTER` key after typing the email, that is just a \"new line character\". And in Python that is represented with `\"\\n\"`.\n\nSo, if you use `input=\"camila@example.com\\n\"` it means: \"type `camila@example.com` in the terminal, then hit the `ENTER` key\":\n\n[Python 3.8+](#__tabbed_6_1)\n\n```md-code__content\nfrom typer.testing import CliRunner\n\nfrom .main import app\n\nrunner = CliRunner()\n\ndef test_app():\n    result = runner.invoke(app, [\"Camila\"], input=\"camila@example.com\\n\")\n    assert result.exit_code == 0\n    assert \"Hello Camila, your email is: camila@example.com\" in result.stdout\n\n```\n\n## Test a function [¶](https://typer.tiangolo.com/tutorial/testing/?q=\\#test-a-function \"Permanent link\")\n\nIf you have a script and you never created an explicit `typer.Typer` app, like:\n\n[Python 3.8+](#__tabbed_7_1)\n\n```md-code__content\nimport typer\n\ndef main(name: str = \"World\"):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n...you can still test it, by creating an app during testing:\n\n[Python 3.8+](#__tabbed_8_1)\n\n```md-code__content\nimport typer\nfrom typer.testing import CliRunner\n\nfrom .main import main\n\napp = typer.Typer()\napp.command()(main)\n\nrunner = CliRunner()\n\ndef test_app():\n    result = runner.invoke(app, [\"--name\", \"Camila\"])\n    assert result.exit_code == 0\n    assert \"Hello Camila\" in result.stdout\n\n```\n\nOf course, if you are testing that script, it's probably easier/cleaner to just create the explicit `typer.Typer` app in `main.py` instead of creating it just during the test.\n\nBut if you want to keep it that way, e.g. because it's a simple example in documentation, then you can use that trick.\n\n### About the `app.command` decorator [¶](https://typer.tiangolo.com/tutorial/testing/?q=\\#about-the-appcommand-decorator \"Permanent link\")\n\nNotice the `app.command()(main)`.\n\nIf it's not obvious what it's doing, continue reading...\n\nYou would normally write something like:\n\n```md-code__content\n@app.command()\ndef main(name: str = \"World\"):\n    # Some code here\n\n```\n\nBut `@app.command()` is just a decorator.\n\nThat's equivalent to:\n\n```md-code__content\ndef main(name: str = \"World\"):\n    # Some code here\n\ndecorator = app.command()\n\nnew_main = decorator(main)\nmain = new_main\n\n```\n\n`app.command()` returns a function ( `decorator`) that takes another function as it's only parameter ( `main`).\n\nAnd by using the `@something` you normally tell Python to replace the thing below (the function `main`) with the return of the `decorator` function ( `new_main`).\n\nNow, in the specific case of **Typer**, the decorator doesn't change the original function. It registers it internally and returns it unmodified.\n\nSo, `new_main` is actually the same original `main`.\n\nSo, in the case of **Typer**, as it doesn't really modify the decorated function, that would be equivalent to:\n\n```md-code__content\ndef main(name: str = \"World\"):\n    # Some code here\n\ndecorator = app.command()\n\ndecorator(main)\n\n```\n\nBut then we don't need to create the variable `decorator` to use it below, we can just use it directly:\n\n```md-code__content\ndef main(name: str = \"World\"):\n    # Some code here\n\napp.command()(main)\n\n```\n\n...that's it. It's still probably simpler to just create the explicit `typer.Typer` in the `main.py` file 😅.\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/testing/?q=",
      "ogUrl": "https://typer.tiangolo.com/tutorial/testing/",
      "title": "Testing - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/testing/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/testing.png",
      "ogTitle": "Testing - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/testing.png",
      "og:title": "Testing - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/testing/?q=",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/testing.png",
      "twitter:title": "Testing - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/commands/options/?q=#command-cli-options)\n\n# Command CLI Options [¶](https://typer.tiangolo.com/tutorial/commands/options/?q=\\#command-cli-options \"Permanent link\")\n\nCommands can also have their own _CLI options_.\n\nIn fact, each command can have different _CLI arguments_ and _CLI options_:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\napp = typer.Typer()\n\n@app.command()\ndef create(username: str):\n    print(f\"Creating user: {username}\")\n\n@app.command()\ndef delete(\n    username: str,\n    force: Annotated[\\\n        bool, typer.Option(prompt=\"Are you sure you want to delete the user?\")\\\n    ],\n):\n    if force:\n        print(f\"Deleting user: {username}\")\n    else:\n        print(\"Operation cancelled\")\n\n@app.command()\ndef delete_all(\n    force: Annotated[\\\n        bool, typer.Option(prompt=\"Are you sure you want to delete ALL users?\")\\\n    ],\n):\n    if force:\n        print(\"Deleting all users\")\n    else:\n        print(\"Operation cancelled\")\n\n@app.command()\ndef init():\n    print(\"Initializing user database\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_2_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\n\n@app.command()\ndef create(username: str):\n    print(f\"Creating user: {username}\")\n\n@app.command()\ndef delete(\n    username: str,\n    force: bool = typer.Option(..., prompt=\"Are you sure you want to delete the user?\"),\n):\n    if force:\n        print(f\"Deleting user: {username}\")\n    else:\n        print(\"Operation cancelled\")\n\n@app.command()\ndef delete_all(\n    force: bool = typer.Option(\n        ..., prompt=\"Are you sure you want to delete ALL users?\"\n    ),\n):\n    if force:\n        print(\"Deleting all users\")\n    else:\n        print(\"Operation cancelled\")\n\n@app.command()\ndef init():\n    print(\"Initializing user database\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nHere we have multiple commands, with different _CLI parameters_:\n\n- `create`:\n  - `username`: a _CLI argument_.\n- `delete`:\n  - `username`: a _CLI argument_.\n  - `--force`: a _CLI option_, if not provided, it's prompted.\n- `delete-all`:\n  - `--force`: a _CLI option_, if not provided, it's prompted.\n- `init`:\n  - Doesn't take any _CLI parameters_.\n\n```\n\nfast →💬 Check the helppython main.py --help\n\nUsage: main.py [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  --install-completion  Install completion for the current shell.\n  --show-completion     Show completion for the current shell, to copy it or customize the installation.\n  --help                Show this message and exit.\n\nCommands:\n  create\n  delete\n  delete-all\n  init\n\nrestart ↻\n```\n\nTip\n\nCheck the command `delete-all`, by default command names are generated from the function name, replacing `_` with `-`.\n\nTest it:\n\n```\n\nfast →💬 Check the command createpython main.py create Camila\nCreating user: Camila\n\n💬 Now test the command deletepython main.py delete Camila\ny\nDeleting user: Camila\n\npython main.py delete Wade\nn\nOperation cancelled\n\n💬 And finally, the command delete-all💬 Notice it doesn't have CLI arguments, only a CLI option\npython main.py delete-all\ny\nDeleting all users\n\npython main.py delete-all\nn\nOperation cancelled\n\n💬 And if you pass the --force CLI option, it doesn't need to confirm\npython main.py delete-all --force\nDeleting all users\n\n💬 And init that doesn't take any CLI parameterpython main.py init\nInitializing user database\n\nrestart ↻\n```\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/commands/options/?q=",
      "ogUrl": "https://typer.tiangolo.com/tutorial/commands/options/",
      "title": "Command CLI Options - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/commands/options/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/commands/options.png",
      "ogTitle": "Command CLI Options - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/commands/options.png",
      "og:title": "Command CLI Options - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/commands/options/?q=",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/commands/options.png",
      "twitter:title": "Command CLI Options - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/parameter-types/file/?q=#file)\n\n# File [¶](https://typer.tiangolo.com/tutorial/parameter-types/file/?q=\\#file \"Permanent link\")\n\nApart from `Path` _CLI parameters_ you can also declare some types of \"files\".\n\nTip\n\nIn most of the cases you are probably fine just using `Path`.\n\nYou can read and write data with `Path` the same way.\n\nThe difference is that these types will give you a Python [file-like object](https://docs.python.org/3/glossary.html#term-file-object) instead of a Python [Path](https://docs.python.org/3/library/pathlib.html#basic-use).\n\nA \"file-like object\" is the same type of object returned by `open()` as in:\n\n```md-code__content\nwith open('file.txt') as f:\n    # Here f is the file-like object\n    read_data = f.read()\n    print(read_data)\n\n```\n\nBut in some special use cases you might want to use these special types. For example if you are migrating an existing application.\n\n## `FileText` reading [¶](https://typer.tiangolo.com/tutorial/parameter-types/file/?q=\\#filetext-reading \"Permanent link\")\n\n`typer.FileText` gives you a file-like object for reading text, you will get `str` data from it.\n\nThis means that even if your file has text written in a non-english language, e.g. a `text.txt` file with:\n\n```md-code__content\nla cigüeña trae al niño\n\n```\n\nYou will have a `str` with the text inside, e.g.:\n\n```md-code__content\ncontent = \"la cigüeña trae al niño\"\n\n```\n\ninstead of having `bytes`, e.g.:\n\n```md-code__content\ncontent = b\"la cig\\xc3\\xbce\\xc3\\xb1a trae al ni\\xc3\\xb1o\"\n\n```\n\nYou will get all the correct editor support, attributes, methods, etc for the file-like object:\\`\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(config: Annotated[typer.FileText, typer.Option()]):\n    for line in config:\n        print(f\"Config line: {line}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_2_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(config: typer.FileText = typer.Option(...)):\n    for line in config:\n        print(f\"Config line: {line}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nCheck it:\n\n```\n\nfast →💬 Create a quick text configecho \"some settings\" > config.txt\n💬 Add another line to the config to test itecho \"some more settings\" >> config.txt\n💬 Now run your programpython main.py --config config.txt\nConfig line: some settings\n\nConfig line: some more settings\n\nrestart ↻\n```\n\n## `FileTextWrite` [¶](https://typer.tiangolo.com/tutorial/parameter-types/file/?q=\\#filetextwrite \"Permanent link\")\n\nFor writing text, you can use `typer.FileTextWrite`:\n\n[Python 3.8+](#__tabbed_3_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(config: Annotated[typer.FileTextWrite, typer.Option()]):\n    config.write(\"Some config written by the app\")\n    print(\"Config written\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_4_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(config: typer.FileTextWrite = typer.Option(...)):\n    config.write(\"Some config written by the app\")\n    print(\"Config written\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nThis would be for writing human text, like:\n\n```md-code__content\nsome settings\nla cigüeña trae al niño\n\n```\n\n...not to write binary `bytes`.\n\nCheck it:\n\n```\n\nfast →python main.py --config text.txt\nConfig written\n\n💬 Check the contents of the filecat text.txt\nSome config written by the app\n\nrestart ↻\n```\n\nTechnical Details\n\n`typer.FileTextWrite` is a just a convenience class.\n\nIt's the same as using `typer.FileText` and setting `mode=\"w\"`. You will learn about `mode` later below.\n\n## `FileBinaryRead` [¶](https://typer.tiangolo.com/tutorial/parameter-types/file/?q=\\#filebinaryread \"Permanent link\")\n\nTo read binary data you can use `typer.FileBinaryRead`.\n\nYou will receive `bytes` from it.\n\nIt's useful for reading binary files like images:\n\n[Python 3.8+](#__tabbed_5_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(file: Annotated[typer.FileBinaryRead, typer.Option()]):\n    processed_total = 0\n    for bytes_chunk in file:\n        # Process the bytes in bytes_chunk\n        processed_total += len(bytes_chunk)\n        print(f\"Processed bytes total: {processed_total}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_6_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(file: typer.FileBinaryRead = typer.Option(...)):\n    processed_total = 0\n    for bytes_chunk in file:\n        # Process the bytes in bytes_chunk\n        processed_total += len(bytes_chunk)\n        print(f\"Processed bytes total: {processed_total}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nCheck it:\n\n```\n\nfast →python main.py --file lena.jpg\nProcessed bytes total: 512\nProcessed bytes total: 1024\nProcessed bytes total: 1536\nProcessed bytes total: 2048\n\nrestart ↻\n```\n\n## `FileBinaryWrite` [¶](https://typer.tiangolo.com/tutorial/parameter-types/file/?q=\\#filebinarywrite \"Permanent link\")\n\nTo write binary data you can use `typer.FileBinaryWrite`.\n\nYou would write `bytes` to it.\n\nIt's useful for writing binary files like images.\n\nHave in mind that you have to pass `bytes` to its `.write()` method, not `str`.\n\nIf you have a `str`, you have to encode it first to get `bytes`.\n\n[Python 3.8+](#__tabbed_7_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(file: Annotated[typer.FileBinaryWrite, typer.Option()]):\n    first_line_str = \"some settings\\n\"\n    # You cannot write str directly to a binary file, you have to encode it to get bytes\n    first_line_bytes = first_line_str.encode(\"utf-8\")\n    # Then you can write the bytes\n    file.write(first_line_bytes)\n    # This is already bytes, it starts with b\"\n    second_line = b\"la cig\\xc3\\xbce\\xc3\\xb1a trae al ni\\xc3\\xb1o\"\n    file.write(second_line)\n    print(\"Binary file written\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_8_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(file: typer.FileBinaryWrite = typer.Option(...)):\n    first_line_str = \"some settings\\n\"\n    # You cannot write str directly to a binary file, you have to encode it to get bytes\n    first_line_bytes = first_line_str.encode(\"utf-8\")\n    # Then you can write the bytes\n    file.write(first_line_bytes)\n    # This is already bytes, it starts with b\"\n    second_line = b\"la cig\\xc3\\xbce\\xc3\\xb1a trae al ni\\xc3\\xb1o\"\n    file.write(second_line)\n    print(\"Binary file written\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n```\n\nfast →python main.py --file binary.dat\nBinary file written\n\n💬 Check the binary file was createdls ./binary.dat\n./binary.dat\n\nrestart ↻\n```\n\n## File _CLI parameter_ configurations [¶](https://typer.tiangolo.com/tutorial/parameter-types/file/?q=\\#file-cli-parameter-configurations \"Permanent link\")\n\nYou can use several configuration parameters for these types (classes) in `typer.Option()` and `typer.Argument()`:\n\n- `mode`: controls the \" [mode](https://docs.python.org/3/library/functions.html#open)\" to open the file with.\n  - It's automatically set for you by using the classes above.\n  - Read more about it below.\n- `encoding`: to force a specific encoding, e.g. `\"utf-8\"`.\n- `lazy`: delay I/O operations. Automatic by default.\n  - By default, when writing files, Click will generate a file-like object that is not yet the actual file. Once you start writing, it will go, open the file and start writing to it, but not before. This is mainly useful to avoid creating the file until you start writing to it. It's normally safe to leave this automatic. But you can overwrite it setting `lazy=False`. By default, it's `lazy=True` for writing and `lazy=False` for reading.\n- `atomic`: if true, all writes will actually go to a temporal file and then moved to the final destination after completing. This is useful with files modified frequently by several users/programs.\n\n## Advanced `mode` [¶](https://typer.tiangolo.com/tutorial/parameter-types/file/?q=\\#advanced-mode \"Permanent link\")\n\nBy default, **Typer** will configure the [`mode`](https://docs.python.org/3/library/functions.html#open) for you:\n\n- `typer.FileText`: `mode=\"r\"`, to read text.\n- `typer.FileTextWrite`: `mode=\"w\"`, to write text.\n- `typer.FileBinaryRead`: `mode=\"rb\"`, to read binary data.\n- `typer.FileBinaryWrite`: `mode=\"wb\"`, to write binary data.\n\n### Note about `FileTextWrite` [¶](https://typer.tiangolo.com/tutorial/parameter-types/file/?q=\\#note-about-filetextwrite \"Permanent link\")\n\n`typer.FileTextWrite` is actually just a convenience class. It's the same as using `typer.FileText` with `mode=\"w\"`.\n\nBut it's probably shorter and more intuitive as you can get it with autocompletion in your editor by just starting to type `typer.File`... just like the other classes.\n\n### Customize `mode` [¶](https://typer.tiangolo.com/tutorial/parameter-types/file/?q=\\#customize-mode \"Permanent link\")\n\nYou can override the `mode` from the defaults above.\n\nFor example, you could use `mode=\"a\"` to write \"appending\" to the same file:\n\n[Python 3.8+](#__tabbed_9_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(config: Annotated[typer.FileText, typer.Option(mode=\"a\")]):\n    config.write(\"This is a single line\\n\")\n    print(\"Config line written\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_10_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(config: typer.FileText = typer.Option(..., mode=\"a\")):\n    config.write(\"This is a single line\\n\")\n    print(\"Config line written\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nTip\n\nAs you are manually setting `mode=\"a\"`, you can use `typer.FileText` or `typer.FileTextWrite`, both will work.\n\nCheck it:\n\n```\n\nfast →python main.py --config config.txt\nConfig line written\n\n💬 Run your program a couple more times to see how it appends instead of overwritingpython main.py --config config.txt\nConfig line written\n\npython main.py --config config.txt\nConfig line written\n\n💬 Check the contents of the file, it should have each of the 3 lines appendedcat config.txt\nThis is a single line\nThis is a single line\nThis is a single line\n\nrestart ↻\n```\n\n## About the different types [¶](https://typer.tiangolo.com/tutorial/parameter-types/file/?q=\\#about-the-different-types \"Permanent link\")\n\nInfo\n\nThese are technical details about why the different types/classes provided by **Typer**.\n\nBut you don't need this information to be able to use them. You can skip it.\n\n**Typer** provides you these different types (classes) because they inherit directly from the actual Python implementation that will be provided underneath for each case.\n\nThis way your editor will give you the right type checks and completion for each type.\n\nEven if you use `lazy`. When you use `lazy` Click creates a especial object to delay writes, and serves as a \"proxy\" to the actual file that will be written. But this especial proxy object doesn't expose the attributes and methods needed for type checks and completion in the editor. If you access those attributes or call the methods, the \"proxy\" lazy object will call them in the final object and it will all work. But you wouldn't get autocompletion for them.\n\nBut because these **Typer** classes inherit from the actual implementation that will be provided underneath (not the lazy object), you will get all the autocompletion and type checks in the editor.\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/parameter-types/file/?q=",
      "ogUrl": "https://typer.tiangolo.com/tutorial/parameter-types/file/",
      "title": "File - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/parameter-types/file/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/parameter-types/file.png",
      "ogTitle": "File - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/parameter-types/file.png",
      "og:title": "File - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/parameter-types/file/?q=",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/parameter-types/file.png",
      "twitter:title": "File - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/subcommands/callback-override/?q=#sub-typer-callback-override)\n\n# Sub-Typer Callback Override [¶](https://typer.tiangolo.com/tutorial/subcommands/callback-override/?q=\\#sub-typer-callback-override \"Permanent link\")\n\nWhen creating a **Typer** app you can define a callback function, it always executes and defines the _CLI arguments_ and _CLI options_ that go before a command.\n\nWhen adding a Typer app inside of another, the sub-Typer can also have its own callback.\n\nIt can handle any _CLI parameters_ that go before its own commands and execute any extra code:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\n\nusers_app = typer.Typer()\napp.add_typer(users_app, name=\"users\")\n\n@users_app.callback()\ndef users_callback():\n    print(\"Running a users command\")\n\n@users_app.command()\ndef create(name: str):\n    print(f\"Creating user: {name}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nIn this case it doesn't define any _CLI parameters_, it just writes a message.\n\nCheck it:\n\n```\n\nfast →python main.py users create Camila\n💬 Notice the first message is not created by the command function but by the callbackRunning a users command\nCreating user: Camila\n\nrestart ↻\n```\n\n## Add a callback on creation [¶](https://typer.tiangolo.com/tutorial/subcommands/callback-override/?q=\\#add-a-callback-on-creation \"Permanent link\")\n\nIt's also possible to add a callback when creating the `typer.Typer()` app that will be added to another Typer app:\n\n[Python 3.8+](#__tabbed_2_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\n\ndef users_callback():\n    print(\"Running a users command\")\n\nusers_app = typer.Typer(callback=users_callback)\napp.add_typer(users_app, name=\"users\")\n\n@users_app.command()\ndef create(name: str):\n    print(f\"Creating user: {name}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nThis achieves exactly the same as above, it's just another place to add the callback.\n\nCheck it:\n\n```\n\nfast →python main.py users create Camila\nRunning a users command\nCreating user: Camila\n\nrestart ↻\n```\n\n## Overriding the callback on creation [¶](https://typer.tiangolo.com/tutorial/subcommands/callback-override/?q=\\#overriding-the-callback-on-creation \"Permanent link\")\n\nIf a callback was added when creating the `typer.Typer()` app, it's possible to override it with a new one using `@app.callback()`.\n\nThis is the same information you saw on the section about [Commands - Typer Callback](https://typer.tiangolo.com/tutorial/commands/callback/), and it applies the same for sub-Typer apps:\n\n[Python 3.8+](#__tabbed_3_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\n\ndef default_callback():\n    print(\"Running a users command\")\n\nusers_app = typer.Typer(callback=default_callback)\napp.add_typer(users_app, name=\"users\")\n\n@users_app.callback()\ndef user_callback():\n    print(\"Callback override, running users command\")\n\n@users_app.command()\ndef create(name: str):\n    print(f\"Creating user: {name}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nHere we had defined a callback when creating the `typer.Typer()` sub-app, but then we override it with a new callback with the function `user_callback()`.\n\nAs `@app.callback()` takes precedence over `typer.Typer(callback=some_function)`, now our CLI app will use this new callback.\n\nCheck it:\n\n```\n\nfast →python main.py users create Camila\n💬 Notice the message from the new callbackCallback override, running users command\nCreating user: Camila\n\nrestart ↻\n```\n\n## Overriding the callback when adding a sub-Typer [¶](https://typer.tiangolo.com/tutorial/subcommands/callback-override/?q=\\#overriding-the-callback-when-adding-a-sub-typer \"Permanent link\")\n\nLastly, you can override the callback defined anywhere else when adding a sub-Typer with `app.add_typer()` using the `callback` parameter.\n\nThis has the highest priority:\n\n[Python 3.8+](#__tabbed_4_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\n\ndef default_callback():\n    print(\"Running a users command\")\n\nusers_app = typer.Typer(callback=default_callback)\n\ndef callback_for_add_typer():\n    print(\"I have the high land! Running users command\")\n\napp.add_typer(users_app, name=\"users\", callback=callback_for_add_typer)\n\n@users_app.callback()\ndef user_callback():\n    print(\"Callback override, running users command\")\n\n@users_app.command()\ndef create(name: str):\n    print(f\"Creating user: {name}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nNotice that the precedence goes to `app.add_typer()` and is not affected by the order of execution. There's another callback defined below, but the one from `app.add_typer()` wins.\n\nNow when you use the CLI program it will use the new callback function `callback_for_add_typer()`.\n\nCheck it:\n\n```\n\nfast →python users create Camila\n💬 Notice the message from the callback added in add_typer()I have the high land! Running users command\nCreating user: Camila\n\nrestart ↻\n```\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/subcommands/callback-override/?q=",
      "ogUrl": "https://typer.tiangolo.com/tutorial/subcommands/callback-override/",
      "title": "Sub-Typer Callback Override - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/subcommands/callback-override/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/subcommands/callback-override.png",
      "ogTitle": "Sub-Typer Callback Override - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/subcommands/callback-override.png",
      "og:title": "Sub-Typer Callback Override - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/subcommands/callback-override/?q=",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/subcommands/callback-override.png",
      "twitter:title": "Sub-Typer Callback Override - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/parameter-types/datetime/?q=#datetime)\n\n# DateTime [¶](https://typer.tiangolo.com/tutorial/parameter-types/datetime/?q=\\#datetime \"Permanent link\")\n\nYou can specify a _CLI parameter_ as a Python [`datetime`](https://docs.python.org/3/library/datetime.html).\n\nYour function will receive a standard Python `datetime` object, and again, your editor will give you completion, etc.\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nfrom datetime import datetime\n\nimport typer\n\ndef main(birth: datetime):\n    print(f\"Interesting day to be born: {birth}\")\n    print(f\"Birth hour: {birth.hour}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nTyper will accept any string from the following formats:\n\n- `%Y-%m-%d`\n- `%Y-%m-%dT%H:%M:%S`\n- `%Y-%m-%d %H:%M:%S`\n\nCheck it:\n\n```\n\nfast →python main.py --help\nUsage: main.py [OPTIONS] BIRTH:[%Y-%m-%d|%Y-%m-%dT%H:%M:%S|%Y-%m-%d %H:%M:%S]\n\nArguments:\n  BIRTH:[%Y-%m-%d|%Y-%m-%dT%H:%M:%S|%Y-%m-%d %H:%M:%S][required]\n\nOptions:\n  --help                Show this message and exit.\n\n💬 Pass a datetimepython main.py 1956-01-31T10:00:00\nInteresting day to be born: 1956-01-31 10:00:00\nBirth hour: 10\n\n💬 An invalid datepython main.py july-19-1989\nUsage: main.py [OPTIONS] [%Y-%m-%d|%Y-%m-%dT%H:%M:%S|%Y-%m-%d%H:%M:%S]\n\nError: Invalid value for 'BIRTH:[%Y-%m-%d|%Y-%m-%dT%H:%M:%S|%Y-%m-%d %H:%M:%S]': 'july-19-1989' does not match the formats '%Y-%m-%d', '%Y-%m-%dT%H:%M:%S', '%Y-%m-%d %H:%M:%S'.\n\nrestart ↻\n```\n\n## Custom date format [¶](https://typer.tiangolo.com/tutorial/parameter-types/datetime/?q=\\#custom-date-format \"Permanent link\")\n\nYou can also customize the formats received for the `datetime` with the `formats` parameter.\n\n`formats` receives a list of strings with the date formats that would be passed to [datetime.strptime()](https://docs.python.org/3/library/datetime.html#datetime.datetime.strptime).\n\nFor example, let's imagine that you want to accept an ISO formatted datetime, but for some strange reason, you also want to accept a format with:\n\n- first the month\n- then the day\n- then the year\n- separated with \" `/`\"\n\n...It's a crazy example, but let's say you also needed that strange format:\n\n[Python 3.8+](#__tabbed_2_1)\n\n```md-code__content\nfrom datetime import datetime\n\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(\n    launch_date: Annotated[\\\n        datetime,\\\n        typer.Argument(\\\n            formats=[\"%Y-%m-%d\", \"%Y-%m-%dT%H:%M:%S\", \"%Y-%m-%d %H:%M:%S\", \"%m/%d/%Y\"]\\\n        ),\\\n    ],\n):\n    print(f\"Launch will be at: {launch_date}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_3_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nfrom datetime import datetime\n\nimport typer\n\ndef main(\n    launch_date: datetime = typer.Argument(\n        ..., formats=[\"%Y-%m-%d\", \"%Y-%m-%dT%H:%M:%S\", \"%Y-%m-%d %H:%M:%S\", \"%m/%d/%Y\"]\n    ),\n):\n    print(f\"Launch will be at: {launch_date}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nTip\n\nNotice the last string in `formats`: `\"%m/%d/%Y\"`.\n\nCheck it:\n\n```\n\nfast →💬 ISO dates workpython main.py 1969-10-29\nLaunch will be at: 1969-10-29 00:00:00\n\n💬 But the strange custom format also workspython main.py 10/29/1969\nLaunch will be at: 1969-10-29 00:00:00\n\nrestart ↻\n```\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/parameter-types/datetime/?q=",
      "ogUrl": "https://typer.tiangolo.com/tutorial/parameter-types/datetime/",
      "title": "DateTime - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/parameter-types/datetime/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/parameter-types/datetime.png",
      "ogTitle": "DateTime - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/parameter-types/datetime.png",
      "og:title": "DateTime - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/parameter-types/datetime/?q=",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/parameter-types/datetime.png",
      "twitter:title": "DateTime - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/package/?q=#building-a-package)\n\n# Building a Package [¶](https://typer.tiangolo.com/tutorial/package/?q=\\#building-a-package \"Permanent link\")\n\nWhen you create a CLI program with **Typer** you probably want to create your own Python package.\n\nThat's what allows your users to install it and have it as an independent program that they can use in their terminal.\n\nAnd that's also required for shell auto completion to work (unless you use your program through `typer` command).\n\nNowadays, there are several ways and tools to create Python packages (what you install with `pip install something`).\n\nYou might even have your favorite already.\n\nHere's a very opinionated, short guide, showing one of the alternative ways of creating a Python package with a **Typer** app, from scratch.\n\nTip\n\nIf you already have a favorite way of creating Python packages, feel free to skip this.\n\n## Prerequisites [¶](https://typer.tiangolo.com/tutorial/package/?q=\\#prerequisites \"Permanent link\")\n\nFor this guide we'll use [Poetry](https://python-poetry.org/).\n\nPoetry's docs are great, so go ahead, check them and install it.\n\n## Create a project [¶](https://typer.tiangolo.com/tutorial/package/?q=\\#create-a-project \"Permanent link\")\n\nLet's say we want to create a CLI application called `portal-gun`.\n\nTo make sure your package doesn't collide with the package created by someone else, we'll name it with a prefix of your name.\n\nSo, if your name is Rick, we'll call it `rick-portal-gun`.\n\nCreate a project with Poetry:\n\n```\n\nfast →poetry new rick-portal-gun\nCreated package rick_portal_gun in rick-portal-gun\n\n💬 Enter the new project directorycd ./rick-portal-gun\n\nrestart ↻\n```\n\n## Dependencies and environment [¶](https://typer.tiangolo.com/tutorial/package/?q=\\#dependencies-and-environment \"Permanent link\")\n\nAdd `typer` to your dependencies:\n\n```\n\nfast →poetry add typer\n💬 It creates a virtual environment for your projectCreating virtualenv rick-portal-gun-w31dJa0b-py3.10 in /home/rick/.cache/pypoetry/virtualenvs\nUsing version ^0.12.0 for typer\n\nUpdating dependencies\nResolving dependencies... (1.2s)\n\nPackage operations: 8 installs, 0 updates, 0 removals\n\n  - Installing mdurl (0.1.2)\n  - Installing markdown-it-py (3.0.0)\n  - Installing pygments (2.17.2)\n  - Installing click (8.1.7)\n  - Installing rich (13.7.1)\n  - Installing shellingham (1.5.4)\n  - Installing typing-extensions (4.11.0)\n  - Installing typer (0.12.3)\n\nWriting lock file\n\n💬 Activate that new virtual environmentpoetry shell\nSpawning shell within /home/rick/.cache/pypoetry/virtualenvs/rick-portal-gun-w31dJa0b-py3.10\n\n💬 Open an editor using this new environment, for example VS Codecode ./\nrestart ↻\n```\n\nYou can see that you have a generated project structure that looks like:\n\n```md-code__content\n.\n├── poetry.lock\n├── pyproject.toml\n├── README.md\n├── rick_portal_gun\n│   └── __init__.py\n└── tests\n    └── __init__.py\n\n```\n\n## Create your app [¶](https://typer.tiangolo.com/tutorial/package/?q=\\#create-your-app \"Permanent link\")\n\nNow let's create an extremely simple **Typer** app.\n\nCreate a file `rick_portal_gun/main.py` with:\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\n\n@app.callback()\ndef callback():\n    \"\"\"\n    Awesome Portal Gun\n    \"\"\"\n\n@app.command()\ndef shoot():\n    \"\"\"\n    Shoot the portal gun\n    \"\"\"\n    typer.echo(\"Shooting portal gun\")\n\n@app.command()\ndef load():\n    \"\"\"\n    Load the portal gun\n    \"\"\"\n    typer.echo(\"Loading portal gun\")\n\n```\n\nTip\n\nAs we are creating an installable Python package, there's no need to add a section with `if __name__ == \"__main__\":`.\n\n## Modify the README [¶](https://typer.tiangolo.com/tutorial/package/?q=\\#modify-the-readme \"Permanent link\")\n\nLet's change the README to have something like:\n\n```md-code__content\n# Portal Gun\n\nThe awesome Portal Gun\n\n```\n\n## Add a \"script\" [¶](https://typer.tiangolo.com/tutorial/package/?q=\\#add-a-script \"Permanent link\")\n\nWe are creating a Python package that can be installed with `pip install`.\n\nBut we want it to provide a CLI program that can be executed in the shell.\n\nTo do that, we add a configuration to the `pyproject.toml` in the section `[tool.poetry.scripts]`:\n\n```md-code__content\n[tool.poetry]\nname = \"rick-portal-gun\"\nversion = \"0.1.0\"\ndescription = \"\"\nauthors = [\"Rick Sanchez <rick@example.com>\"]\nreadme = \"README.md\"\n\n[tool.poetry.scripts]\nrick-portal-gun = \"rick_portal_gun.main:app\"\n\n[tool.poetry.dependencies]\npython = \"^3.10\"\ntyper = \"^0.12.0\"\n\n[build-system]\nrequires = [\"poetry-core\"]\nbuild-backend = \"poetry.core.masonry.api\"\n\n```\n\nHere's what that line means:\n\n`rick-portal-gun`: will be the name of the CLI program. That's how we will call it in the terminal once it is installed. Like:\n\n```\n\nfast →rick-portal-gun\n💬 Something happens here ✨\nrestart ↻\n```\n\n`rick_portal_gun.main`, in the part `\"rick_portal_gun.main:app\"`, with underscores, refers to the Python module to import. That's what someone would use in a section like:\n\n```md-code__content\nfrom rick_portal_gun.main import # something goes here\n\n```\n\nThe `app` in `\"rick_portal_gun.main:app\"` is the thing to import from the module, and to call as a function, like:\n\n```md-code__content\nfrom rick_portal_gun.main import app\napp()\n\n```\n\nThat config section tells Poetry that when this package is installed we want it to create a command line program called `rick-portal-gun`.\n\nAnd that the object to call (like a function) is the one in the variable `app` inside of the module `rick_portal_gun.main`.\n\n## Install your package [¶](https://typer.tiangolo.com/tutorial/package/?q=\\#install-your-package \"Permanent link\")\n\nThat's what we need to create a package.\n\nYou can now install it:\n\n```\n\nfast →poetry install\nInstalling dependencies from lock file\n\nNo dependencies to install or update\n\n  - Installing the current project: rick-portal-gun (0.1.0)\n\nrestart ↻\n```\n\n## Try your CLI program [¶](https://typer.tiangolo.com/tutorial/package/?q=\\#try-your-cli-program \"Permanent link\")\n\nYour package is installed in the environment created by Poetry, but you can already use it.\n\n```\n\nfast →💬 You can use the which program to check which rick-portal-gun program is available (if any)which rick-portal-gun\n💬 You get the one from your environment/home/rick/.cache/pypoetry/virtualenvs/rick-portal-gun-w31dJa0b-py3.10/bin/rick-portal-gun\n\n💬 Try itrick-portal-gun --help\n💬 You get all the standard helpUsage: rick-portal-gun [OPTIONS] COMMAND [ARGS]...\n\n  Awesome Portal Gun\n\nOptions:\n  --install-completion  Install completion for the current shell.\n  --show-completion     Show completion for the current shell, to copy it or customize the installation.\n\n  --help                Show this message and exit.\n\nCommands:\n  load   Load the portal gun\n  shoot  Shoot the portal gun\n\nrestart ↻\n```\n\n## Create a wheel package [¶](https://typer.tiangolo.com/tutorial/package/?q=\\#create-a-wheel-package \"Permanent link\")\n\nPython packages have a standard format called a \"wheel\". It's a file that ends in `.whl`.\n\nYou can create a wheel with Poetry:\n\n```\n\nfast →poetry build\nBuilding rick-portal-gun (0.1.0)\n - Building sdist\n - Built rick-portal-gun-0.1.0.tar.gz\n - Building wheel\n - Built rick_portal_gun-0.1.0-py3-none-any.whl\n\nrestart ↻\n```\n\nAfter that, if you check in your project directory, you should now have a couple of extra files at `./dist/`:\n\n```md-code__content\n.\n├── dist\n│   ├── rick_portal_gun-0.1.0-py3-none-any.whl\n│   └── rick-portal-gun-0.1.0.tar.gz\n├── pyproject.toml\n├── README.md\n├── ...\n\n```\n\nThe `.whl` is the wheel file. You can send that wheel file to anyone and they can use it to install your program (we'll see how to upload it to PyPI in a bit).\n\n## Test your wheel package [¶](https://typer.tiangolo.com/tutorial/package/?q=\\#test-your-wheel-package \"Permanent link\")\n\nNow you can open another terminal and install that package from the file for your own user with:\n\n```\n\nfast →pip install --user /home/rick/rick-portal-gun/dist/rick_portal_gun-0.1.0-py3-none-any.whl\n\nrestart ↻\n```\n\nWarning\n\nThe `--user` is important, that ensures you install it in your user's directory and not in the global system.\n\nIf you installed it in the global system (e.g. with `sudo`) you could install a version of a library (e.g. a sub-dependency) that is incompatible with your system.\n\nTip\n\nBonus points if you use [`pipx`](https://github.com/pipxproject/pipx) to install it while keeping an isolated environment for your Python CLI programs 🚀\n\nNow you have your CLI program installed. And you can use it freely:\n\n```\n\nfast →rick-portal-gun shoot\n💬 It works 🎉Shooting portal gun\n\nrestart ↻\n```\n\nHaving it installed globally (and not in a single environment), you can now install completion globally for it:\n\n```\n\nfast →rick-portal-gun --install-completion\nzsh completion installed in /home/rick/.zshrc.\nCompletion will take effect once you restart the terminal.\n\nrestart ↻\n```\n\nTip\n\nIf you want to remove completion you can just delete the added line in that file.\n\nAnd after you restart the terminal you will get completion for your new CLI program:\n\n```\n\nfast →rick-portal-gun [TAB][TAB]\n💬 You get completion for your CLI program ✨load   -- Load the portal gun\nshoot  -- Shoot the portal gun\n\nrestart ↻\n```\n\n## Support `python -m` (optional) [¶](https://typer.tiangolo.com/tutorial/package/?q=\\#support-python-m-optional \"Permanent link\")\n\nYou may have seen that you can call many Python modules as scripts with `python -m some-module`.\n\nFor example, one way to call `pip` is:\n\n```\n\nfast →pip install fastapi\nrestart ↻\n```\n\nBut you can also call Python with the `-m` _CLI Option_ and pass a module for it to execute as if it was a script, like:\n\n```\n\nfast →python -m pip install fastapi\nrestart ↻\n```\n\nHere we pass `pip` as the value for `-m`, so, Python will execute the module `pip` as if it was a script. And then it will pass the rest of the _CLI Parameters_ ( `install fastapi`) to it.\n\nThese two are more or less equivalent, the `install fastapi` will be passed to `pip`.\n\nTip\n\nIn the case of `pip`, in many occasions it's actually recommended that you run it with `python -m`, because if you create a virtual environment with its own `python`, that will ensure that you use the `pip` from _that_ environment.\n\n### Add a `__main__.py` [¶](https://typer.tiangolo.com/tutorial/package/?q=\\#add-a-__main__py \"Permanent link\")\n\nYou can support that same style of calling the package/module for your own package, simply by adding a file `__main__.py`.\n\nPython will look for that file and execute it.\n\nThe file would live right beside `__init__.py`:\n\n```md-code__content\n.\n├── poetry.lock\n├── pyproject.toml\n├── README.md\n├── rick_portal_gun\n│   ├── __init__.py\n│   ├── __main__.py\n│   └── main.py\n└── tests\n    └── __init__.py\n\n```\n\nNo other file has to import it, you don't have to reference it in your `pyproject.toml` or anything else, it just works by default, as it is standard Python behavior.\n\nThen in that file you can execute your **Typer** program:\n\n```md-code__content\nfrom .main import app\napp()\n\n```\n\nNow, after installing your package, if you call it with `python -m` it will work (for the main part):\n\n```\n\nfast →python -m rick_portal_gun --help\nUsage: __main__.py [OPTIONS] COMMAND [ARGS]...\n\n  Awesome Portal Gun\n\nOptions:\n  --install-completion  Install completion for the current shell.\n  --show-completion     Show completion for the current shell, to copy it or customize the installation.\n\n  --help                Show this message and exit.\n\nCommands:\n  load   Load the portal gun\n  shoot  Shoot the portal gun\n\nrestart ↻\n```\n\nTip\n\nNotice that you have to pass the importable version of the package name, so `rick_portal_gun` instead of `rick-portal-gun`.\n\nThat works! 🚀 Sort of... 🤔\n\nSee the `__main__.py` in the help instead of `rick-portal-gun`? We'll fix that next.\n\n### Set a program name in `__main__.py` [¶](https://typer.tiangolo.com/tutorial/package/?q=\\#set-a-program-name-in-__main__py \"Permanent link\")\n\nWe are setting the program name in the file `pyproject.toml` in the line like:\n\n```md-code__content\n[tool.poetry.scripts]\nrick-portal-gun = \"rick_portal_gun.main:app\"\n\n```\n\nBut when Python runs our package as a script with `python -m`, it doesn't have the information of the program name.\n\nSo, to fix the help text to use the correct program name when called with `python -m`, we can pass it to the app in `__main__.py`:\n\n```md-code__content\nfrom .main import app\napp(prog_name=\"rick-portal-gun\")\n\n```\n\nTip\n\nYou can pass all the arguments and keyword arguments you could pass to a Click application, including `prog_name`.\n\n```\n\nfast →python -m rick_portal_gun --help\nUsage: rick-portal-gun [OPTIONS] COMMAND [ARGS]...\n\n  Awesome Portal Gun\n\nOptions:\n  --install-completion  Install completion for the current shell.\n  --show-completion     Show completion for the current shell, to copy it or customize the installation.\n\n  --help                Show this message and exit.\n\nCommands:\n  load   Load the portal gun\n  shoot  Shoot the portal gun\n\nrestart ↻\n```\n\nGreat! That works correctly! 🎉 ✅\n\nNotice that now it uses `rick-portal-gun` instead of `__main__.py` in the help.\n\n### Autocompletion and `python -m` [¶](https://typer.tiangolo.com/tutorial/package/?q=\\#autocompletion-and-python-m \"Permanent link\")\n\nHave in mind that TAB completion (shell auto-completion) won't work when using `python -m`.\n\nAuto-completion depends on the name of the program called, it's tied to each specific program name.\n\nSo, to have shell completion for `rick-portal-gun` you would have to call it directly:\n\n```\n\nfast →rick-portal-gun [TAB][TAB]\nrestart ↻\n```\n\nBut you can still support `python -m` for the cases where it's useful.\n\n## Publish to PyPI (optional) [¶](https://typer.tiangolo.com/tutorial/package/?q=\\#publish-to-pypi-optional \"Permanent link\")\n\nYou can publish that new package to [PyPI](https://pypi.org/) to make it public, so others can install it easily.\n\nSo, go ahead and create an account there (it's free).\n\n### PyPI API token [¶](https://typer.tiangolo.com/tutorial/package/?q=\\#pypi-api-token \"Permanent link\")\n\nTo do it, you first need to configure a PyPI auth token.\n\nLogin to [PyPI](https://pypi.org/).\n\nAnd then go to [https://pypi.org/manage/account/token/](https://pypi.org/manage/account/token/) to create a new token.\n\nLet's say your new API token is:\n\n```md-code__content\npypi-wubalubadubdub-deadbeef1234\n\n```\n\nNow configure Poetry to use this token with the command `poetry config pypi-token.pypi`:\n\n```\n\nfast →poetry config pypi-token.pypi pypi-wubalubadubdub-deadbeef1234💬 It won't show any output, but it's already configured\nrestart ↻\n```\n\n### Publish to PyPI [¶](https://typer.tiangolo.com/tutorial/package/?q=\\#publish-to-pypi \"Permanent link\")\n\nNow you can publish your package with Poetry.\n\nYou could build the package (as we did above) and then publish later, or you could tell poetry to build it before publishing in one go:\n\n```\n\nfast →poetry publish --build\nyes\n\nBuilding rick-portal-gun (0.1.0)\n - Building sdist\n - Built rick-portal-gun-0.1.0.tar.gz\n - Building wheel\n - Built rick_portal_gun-0.1.0-py3-none-any.whl\n\nPublishing rick-portal-gun (0.1.0) to PyPI\n - Uploading rick-portal-gun-0.1.0.tar.gz 100%\n - Uploading rick_portal_gun-0.1.0-py3-none-any.whl 100%\n\nrestart ↻\n```\n\nNow you can go to PyPI and check your projects at [https://pypi.org/manage/projects/](https://pypi.org/manage/projects/).\n\nYou should now see your new \"rick-portal-gun\" package.\n\n### Install from PyPI [¶](https://typer.tiangolo.com/tutorial/package/?q=\\#install-from-pypi \"Permanent link\")\n\nNow to see that we can install it form PyPI, open another terminal, and uninstall the currently installed package.\n\n```\n\nfast →pip uninstall rick-portal-gun\nFound existing installation: rick-portal-gun 0.1.0\nUninstalling rick-portal-gun-0.1.0:\n  Would remove:\n    /home/rick/.local/bin/rick-portal-gun\n    /home/rick/.local/lib/python3.10/site-packages/rick_portal_gun-0.1.0.dist-info/*\n    /home/rick/.local/lib/python3.10/site-packages/rick_portal_gun/*Y    Successfully uninstalled rick-portal-gun-0.1.0\n\nrestart ↻\n```\n\nAnd now install it again, but this time using just the name, so that `pip` pulls it from PyPI:\n\n```\n\nfast →pip install --user rick-portal-gun\n💬 Notice that it says \"Downloading\" 🚀Collecting rick-portal-gun\n  Downloading rick_portal_gun-0.1.0-py3-none-any.whl.metadata (435 bytes)\nRequirement already satisfied: typer<0.13.0,>=0.12.3 in ./.local/lib/python3.10/site-packages (from rick-portal-gun==0.1.0) (0.12.3)\nRequirement already satisfied: typing-extensions>=3.7.4.3 in ./.local/lib/python3.10/site-packages (from typer<0.13.0,>=0.12.3->rick-portal-gun==0.1.0) (4.11.0)\nRequirement already satisfied: click>=8.0.0 in ./.local/lib/python3.10/site-packages (from typer<0.13.0,>=0.12.3->rick-portal-gun==0.1.0) (8.1.7)\nRequirement already satisfied: shellingham>=1.3.0 in ./.local/lib/python3.10/site-packages (from typer<0.13.0,>=0.12.3->rick-portal-gun==0.1.0) (1.5.4)\nRequirement already satisfied: rich>=10.11.0 in ./.local/lib/python3.10/site-packages (from typer<0.13.0,>=0.12.3->rick-portal-gun==0.1.0) (13.7.1)\nRequirement already satisfied: pygments<3.0.0,>=2.13.0 in ./.local/lib/python3.10/site-packages (from rich>=10.11.0->typer<0.13.0,>=0.12.3->rick-portal-gun==0.1.0) (2.17.2)\nRequirement already satisfied: markdown-it-py>=2.2.0 in ./.local/lib/python3.10/site-packages (from rich>=10.11.0->typer<0.13.0,>=0.12.3->rick-portal-gun==0.1.0) (3.0.0)\nRequirement already satisfied: mdurl~=0.1 in ./.local/lib/python3.10/site-packages (from markdown-it-py>=2.2.0->rich>=10.11.0->typer<0.13.0,>=0.12.3->rick-portal-gun==0.1.0) (0.1.2)\nDownloading rick_portal_gun-0.1.0-py3-none-any.whl (1.8 kB)\nInstalling collected packages: rick-portal-gun\nSuccessfully installed rick-portal-gun-0.1.0\n\nrestart ↻\n```\n\nAnd now test the newly installed package from PyPI:\n\n```\n\nfast →rick-portal-gun load\n💬 It works! 🎉Loading portal gun\n\nrestart ↻\n```\n\n## Generate docs [¶](https://typer.tiangolo.com/tutorial/package/?q=\\#generate-docs \"Permanent link\")\n\nYou can use the `typer` command to generate docs for your package that you can put in your `README.md`:\n\n```\n\nfast →typer rick_portal_gun.main utils docs --output README.md --name rick-portal-gun\nDocs saved to: README.md\n\nrestart ↻\n```\n\nYou just have to pass it the module to import ( `rick_portal_gun.main`) and it will detect the `typer.Typer` app automatically.\n\nBy specifying the `--name` of the program it will be able to use it while generating the docs.\n\nTip\n\nIf you installed `typer-slim` and don't have the `typer` command, you can use `python -m typer` instead.\n\n### Publish a new version with the docs [¶](https://typer.tiangolo.com/tutorial/package/?q=\\#publish-a-new-version-with-the-docs \"Permanent link\")\n\nNow you can publish a new version with the updated docs.\n\nFor that you need to first increase the version in `pyproject.toml`:\n\n```md-code__content\n[tool.poetry]\nname = \"rick-portal-gun\"\nversion = \"0.2.0\"\ndescription = \"\"\nauthors = [\"Rick Sanchez <rick@example.com>\"]\nreadme = \"README.md\"\n\n[tool.poetry.scripts]\nrick-portal-gun = \"rick_portal_gun.main:app\"\n\n[tool.poetry.dependencies]\npython = \"^3.10\"\ntyper = \"^0.12.0\"\n\n[build-system]\nrequires = [\"poetry-core\"]\nbuild-backend = \"poetry.core.masonry.api\"\n\n```\n\nAnd in the file `rick_portal_gun/__init__.py`:\n\n```md-code__content\n__version__ = '0.2.0'\n\n```\n\nAnd then build and publish again:\n\n```\n\nfast →poetry publish --build\n\nBuilding rick-portal-gun (0.2.0)\n - Building sdist\n - Built rick-portal-gun-0.2.0.tar.gz\n - Building wheel\n - Built rick_portal_gun-0.2.0-py3-none-any.whl\n\nPublishing rick-portal-gun (0.2.0) to PyPI\n - Uploading rick-portal-gun-0.2.0.tar.gz 100%\n - Uploading rick_portal_gun-0.2.0-py3-none-any.whl 100%\n\nrestart ↻\n```\n\nAnd now you can go to PyPI, to the project page, and reload it, and it will now have your new generated docs.\n\n## What's next [¶](https://typer.tiangolo.com/tutorial/package/?q=\\#whats-next \"Permanent link\")\n\nThis is a very simple guide. You could add many more steps.\n\nFor example, you should use [Git](https://git-scm.com/), the version control system, to save your code.\n\nYou can add a lot of extra metadata to your `pyproject.toml`, check the docs for [Poetry: Libraries](https://python-poetry.org/docs/libraries/).\n\nYou could use [`pipx`](https://github.com/pipxproject/pipx) to manage your installed CLI Python programs in isolated environments.\n\nMaybe use automatic formatting with [Black](https://github.com/psf/black).\n\nYou'll probably want to publish your code as open source to [GitHub](https://github.com/).\n\nAnd then you could integrate a CI tool to run your tests and deploy your package automatically.\n\nAnd there's a long etc. But now you have the basics and you can continue on your own 🚀.\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/package/?q=",
      "ogUrl": "https://typer.tiangolo.com/tutorial/package/",
      "title": "Building a Package - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/package/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/package.png",
      "ogTitle": "Building a Package - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/package.png",
      "og:title": "Building a Package - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/package/?q=",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/package.png",
      "twitter:title": "Building a Package - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/options/name/?q=#cli-option-name)\n\n# CLI Option Name [¶](https://typer.tiangolo.com/tutorial/options/name/?q=\\#cli-option-name \"Permanent link\")\n\nBy default **Typer** will create a _CLI option_ name from the function parameter.\n\nSo, if you have a function with:\n\n```md-code__content\ndef main(user_name: Optional[str] = None):\n    pass\n\n```\n\nor\n\n```md-code__content\ndef main(user_name: Annotated[Optional[str], typer.Option()] = None):\n    pass\n\n```\n\n**Typer** will create a _CLI option_:\n\n```md-code__content\n--user-name\n\n```\n\nBut you can customize it if you want to.\n\nLet's say the function parameter name is `user_name` as above, but you want the _CLI option_ to be just `--name`.\n\nYou can pass the _CLI option_ name that you want to have in the following positional argument passed to `typer.Option()`:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(user_name: Annotated[str, typer.Option(\"--name\")]):\n    print(f\"Hello {user_name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_2_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(user_name: str = typer.Option(..., \"--name\")):\n    print(f\"Hello {user_name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nInfo\n\n\" [Positional](https://docs.python.org/3.8/glossary.html#term-argument)\" means that it's not a function argument with a keyword name.\n\nFor example `show_default=True` is a keyword argument. \" `show_default`\" is the keyword.\n\nBut in `\"--name\"` there's no `option_name=\"--name\"` or something similar, it's just the string value `\"--name\"` that goes in `typer.Option()`.\n\nThat's a \"positional argument\" in a function.\n\nCheck it:\n\n```\n\nfast →python main.py --help\n💬 Notice the --name instead of --user-nameUsage: main.py [OPTIONS]\n\nOptions:\n  --name TEXT           [required]\n  --help                Show this message and exit.\n\n💬 Try itpython main.py --name Camila\nHello Camila\n\nrestart ↻\n```\n\n## _CLI option_ short names [¶](https://typer.tiangolo.com/tutorial/options/name/?q=\\#cli-option-short-names \"Permanent link\")\n\nA short name is a _CLI option_ name with a single dash ( `-`) instead of 2 ( `--`) and a single letter, like `-n` instead of `--name`.\n\nFor example, the `ls` program has a _CLI option_ named `--size`, and the same _CLI option_ also has a short name `-s`:\n\n```\n\nfast →💬 With the long name --sizels ./myproject --size\n12 first-steps.md   4 intro.md\n\n💬 With the short name -sls ./myproject -s\n12 first-steps.md   4 intro.md\n\n💬 Both CLI option names do the same\nrestart ↻\n```\n\n### _CLI option_ short names together [¶](https://typer.tiangolo.com/tutorial/options/name/?q=\\#cli-option-short-names-together \"Permanent link\")\n\nShort names have another feature, when they have a single letter, as in `-s`, you can put several of these _CLI options_ together, with a single dash.\n\nFor example, the `ls` program has these 2 _CLI options_ (among others):\n\n- `--size`: show the sizes of the listed files.\n- `--human`: show a human-readable format, like `1MB` instead of just `1024`.\n\nAnd these 2 _CLI options_ have short versions too:\n\n- `--size`: short version `-s`.\n- `--human`: short version `-h`.\n\nSo, you can put them together with `-sh` or `-hs`:\n\n```\n\nfast →💬 Call ls with long CLI optionsls --size --human\n12K first-steps.md   4.0K intro.md\n\n💬 Now with short versionsls -s -h\n12K first-steps.md   4.0K intro.md\n\n💬 And with short versions togetherls -sh\n12K first-steps.md   4.0K intro.md\n\n💬 Order in short versions doesn't matterls -hs\n12K first-steps.md   4.0K intro.md\n\n💬 They all work the same 🎉\nrestart ↻\n```\n\n### _CLI option_ short names with values [¶](https://typer.tiangolo.com/tutorial/options/name/?q=\\#cli-option-short-names-with-values \"Permanent link\")\n\nWhen you use _CLI options_ with short names, you can put them together if they are just boolean flags, like `--size` or `--human`.\n\nBut if you have a _CLI option_ `--file` with a short name `-f` that takes a value, if you put it with other short names for _CLI options_, you have to put it as the last letter, so that it can receive the value that comes right after.\n\nFor example, let's say you are decompressing/extracting a file `myproject.tar.gz` with the program `tar`.\n\nYou can pass these _CLI option_ short names to `tar`:\n\n- `-x`: means \"e `X` tract\", to decompress and extract the contents.\n- `-v`: means \" `V` erbose\", to print on the screen what it is doing, so you can know that it's decompressing each file and can entertain yourself while you wait.\n- `-f`: means \" `F` ile\", this one requires a value, the compressed file to extract (in our example, this is `myproject.tar.gz`).\n  - So if you use all the short names together, this `-f` has to come last, to receive the value that comes next to it.\n\nFor example:\n\n```\n\nfast →tar -xvf myproject.tar.gz\nmyproject/\nmyproject/first-steps.md\nmyproject/intro.md\n\n💬 But if you put the -f beforetar -fxv myproject.tar.gz\n💬 You get an ugly errortar: You must specify one of the blah, blah, error, error\n\nrestart ↻\n```\n\n### Defining _CLI option_ short names [¶](https://typer.tiangolo.com/tutorial/options/name/?q=\\#defining-cli-option-short-names \"Permanent link\")\n\nIn **Typer** you can also define _CLI option_ short names the same way you can customize the long names.\n\nYou can pass _positional_ arguments to `typer.Option()` to define the _CLI option_ name(s).\n\nTip\n\nRemember the _positional_ function arguments are those that don't have a keyword.\n\nAll the other function arguments/parameters you pass to `typer.Option()` like `prompt=True` and `help=\"This option blah, blah\"` require the keyword.\n\nYou can overwrite the _CLI option_ name to use as in the previous example, but you can also declare extra alternatives, including short names.\n\nFor example, extending the previous example, let's add a _CLI option_ short name `-n`:\n\n[Python 3.8+](#__tabbed_3_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(user_name: Annotated[str, typer.Option(\"--name\", \"-n\")]):\n    print(f\"Hello {user_name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_4_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(user_name: str = typer.Option(..., \"--name\", \"-n\")):\n    print(f\"Hello {user_name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nHere we are overwriting the _CLI option_ name that by default would be `--user-name`, and we are defining it to be `--name`. And we are also declaring a _CLI option_ short name of `-n`.\n\nCheck it:\n\n```\n\nfast →💬 Check the helppython main.py --help\n💬 Notice the two CLI option names -n and --nameUsage: main.py [OPTIONS]\n\nOptions:\n  -n, --name TEXT       [required]\n  --help                Show this message and exit.\n\n💬 Try the short versionpython main.py -n Camila\nHello Camila\n\nrestart ↻\n```\n\n### _CLI option_ only short name [¶](https://typer.tiangolo.com/tutorial/options/name/?q=\\#cli-option-only-short-name \"Permanent link\")\n\nIf you only declare a short name like `-n` then that will be the only _CLI option_ name. And neither `--name` nor `--user-name` will be available.\n\n[Python 3.8+](#__tabbed_5_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(user_name: Annotated[str, typer.Option(\"-n\")]):\n    print(f\"Hello {user_name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_6_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(user_name: str = typer.Option(..., \"-n\")):\n    print(f\"Hello {user_name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nCheck it:\n\n```\n\nfast →python main.py --help\n💬 Notice there's no --name nor --user-name, only -nUsage: main.py [OPTIONS]\n\nOptions:\n  -n TEXT               [required]\n  --help                Show this message and exit.\n\n💬 Try itpython main.py -n Camila\nHello Camila\n\nrestart ↻\n```\n\n### _CLI option_ short name and default [¶](https://typer.tiangolo.com/tutorial/options/name/?q=\\#cli-option-short-name-and-default \"Permanent link\")\n\nContinuing with the example above, as **Typer** allows you to declare a _CLI option_ as having only a short name, if you want to have the default long name plus a short name, you have to declare both explicitly:\n\n[Python 3.8+](#__tabbed_7_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(user_name: Annotated[str, typer.Option(\"--user-name\", \"-n\")]):\n    print(f\"Hello {user_name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_8_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(user_name: str = typer.Option(..., \"--user-name\", \"-n\")):\n    print(f\"Hello {user_name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nCheck it:\n\n```\n\nfast →python main.py --help\n💬 Notice that we have the long version --user-name back💬 and we also have the short version -nUsage: main.py [OPTIONS]\n\nOptions:\n  -n, --user-name TEXT  [required]\n  --help                Show this message and exit.\n\n💬 Try itpython main.py --user-name Camila\nHello Camila\n\n💬 And try the short versionpython main.py -n Camila\nrestart ↻\n```\n\n### _CLI option_ short names together [¶](https://typer.tiangolo.com/tutorial/options/name/?q=\\#cli-option-short-names-together_1 \"Permanent link\")\n\nYou can create multiple short names and use them together.\n\nYou don't have to do anything special for it to work (apart from declaring those short versions):\n\n[Python 3.8+](#__tabbed_9_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(\n    name: Annotated[str, typer.Option(\"--name\", \"-n\")],\n    formal: Annotated[bool, typer.Option(\"--formal\", \"-f\")] = False,\n):\n    if formal:\n        print(f\"Good day Ms. {name}.\")\n    else:\n        print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_10_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(\n    name: str = typer.Option(..., \"--name\", \"-n\"),\n    formal: bool = typer.Option(False, \"--formal\", \"-f\"),\n):\n    if formal:\n        print(f\"Good day Ms. {name}.\")\n    else:\n        print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nTip\n\nNotice that, again, we are declaring the long and short version of the _CLI option_ names.\n\nCheck it:\n\n```\n\nfast →python main.py --help\n💬 We now have short versions -n and -f💬 And also long versions --name and --formalUsage: main.py [OPTIONS]\n\nOptions:\n  -n, --name TEXT       [required]\n  -f, --formal\n  --help                Show this message and exit.\n\n💬 Try the short versionspython main.py -n Camila -f\nGood day Ms. Camila.\n\n💬 And try the 2 short versions together💬 See how -n has to go last, to be able to get the valuepython main.py -fn Camila\nGood day Ms. Camila.\n\nrestart ↻\n```\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/options/name/?q=",
      "ogUrl": "https://typer.tiangolo.com/tutorial/options/name/",
      "title": "CLI Option Name - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/options/name/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/options/name.png",
      "ogTitle": "CLI Option Name - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/options/name.png",
      "og:title": "CLI Option Name - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/options/name/?q=",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/options/name.png",
      "twitter:title": "CLI Option Name - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/subcommands/single-file/?q=#subcommands-in-a-single-file)\n\n# SubCommands in a Single File [¶](https://typer.tiangolo.com/tutorial/subcommands/single-file/?q=\\#subcommands-in-a-single-file \"Permanent link\")\n\nIn some cases, it's possible that your application code needs to live on a single file.\n\nYou can still use the same ideas:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\nitems_app = typer.Typer()\napp.add_typer(items_app, name=\"items\")\nusers_app = typer.Typer()\napp.add_typer(users_app, name=\"users\")\n\n@items_app.command(\"create\")\ndef items_create(item: str):\n    print(f\"Creating item: {item}\")\n\n@items_app.command(\"delete\")\ndef items_delete(item: str):\n    print(f\"Deleting item: {item}\")\n\n@items_app.command(\"sell\")\ndef items_sell(item: str):\n    print(f\"Selling item: {item}\")\n\n@users_app.command(\"create\")\ndef users_create(user_name: str):\n    print(f\"Creating user: {user_name}\")\n\n@users_app.command(\"delete\")\ndef users_delete(user_name: str):\n    print(f\"Deleting user: {user_name}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nThere are several things to notice here...\n\n## Apps at the top [¶](https://typer.tiangolo.com/tutorial/subcommands/single-file/?q=\\#apps-at-the-top \"Permanent link\")\n\nFirst, you can create `typer.Typer()` objects and add them to another one at the top.\n\nIt doesn't have to be done after creating the subcommands:\n\n[Python 3.8+](#__tabbed_2_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\nitems_app = typer.Typer()\napp.add_typer(items_app, name=\"items\")\nusers_app = typer.Typer()\napp.add_typer(users_app, name=\"users\")\n\n@items_app.command(\"create\")\ndef items_create(item: str):\n    print(f\"Creating item: {item}\")\n\n@items_app.command(\"delete\")\ndef items_delete(item: str):\n    print(f\"Deleting item: {item}\")\n\n@items_app.command(\"sell\")\ndef items_sell(item: str):\n    print(f\"Selling item: {item}\")\n\n@users_app.command(\"create\")\ndef users_create(user_name: str):\n    print(f\"Creating user: {user_name}\")\n\n@users_app.command(\"delete\")\ndef users_delete(user_name: str):\n    print(f\"Deleting user: {user_name}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nYou can add the commands (subcommands) to each `typer.Typer()` app later and it will still work.\n\n## Function names [¶](https://typer.tiangolo.com/tutorial/subcommands/single-file/?q=\\#function-names \"Permanent link\")\n\nAs you now have subcommands like `create` for `users` and for `items`, you can no longer call the functions with just the name, like `def create()`, because they would overwrite each other.\n\nSo we use longer names:\n\n[Python 3.8+](#__tabbed_3_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\nitems_app = typer.Typer()\napp.add_typer(items_app, name=\"items\")\nusers_app = typer.Typer()\napp.add_typer(users_app, name=\"users\")\n\n@items_app.command(\"create\")\ndef items_create(item: str):\n    print(f\"Creating item: {item}\")\n\n@items_app.command(\"delete\")\ndef items_delete(item: str):\n    print(f\"Deleting item: {item}\")\n\n@items_app.command(\"sell\")\ndef items_sell(item: str):\n    print(f\"Selling item: {item}\")\n\n@users_app.command(\"create\")\ndef users_create(user_name: str):\n    print(f\"Creating user: {user_name}\")\n\n@users_app.command(\"delete\")\ndef users_delete(user_name: str):\n    print(f\"Deleting user: {user_name}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\n## Command name [¶](https://typer.tiangolo.com/tutorial/subcommands/single-file/?q=\\#command-name \"Permanent link\")\n\nWe are naming the functions with longer names so that they don't overwrite each other.\n\nBut we still want the subcommands to be `create`, `delete`, etc.\n\nTo call them like:\n\n```\n\nfast →💬 We want this ✔️python main.py items create\nrestart ↻\n```\n\ninstead of:\n\n```\n\nfast →💬 We don't want this ⛔️python main.py items items-create\nrestart ↻\n```\n\nSo we pass the name we want to use for each subcommand as the function argument to the decorator:\n\n[Python 3.8+](#__tabbed_4_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\nitems_app = typer.Typer()\napp.add_typer(items_app, name=\"items\")\nusers_app = typer.Typer()\napp.add_typer(users_app, name=\"users\")\n\n@items_app.command(\"create\")\ndef items_create(item: str):\n    print(f\"Creating item: {item}\")\n\n@items_app.command(\"delete\")\ndef items_delete(item: str):\n    print(f\"Deleting item: {item}\")\n\n@items_app.command(\"sell\")\ndef items_sell(item: str):\n    print(f\"Selling item: {item}\")\n\n@users_app.command(\"create\")\ndef users_create(user_name: str):\n    print(f\"Creating user: {user_name}\")\n\n@users_app.command(\"delete\")\ndef users_delete(user_name: str):\n    print(f\"Deleting user: {user_name}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\n## Check it [¶](https://typer.tiangolo.com/tutorial/subcommands/single-file/?q=\\#check-it \"Permanent link\")\n\nIt still works the same:\n\n```\n\nfast →💬 Check the helppython main.py --help\nUsage: main.py [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  --install-completion  Install completion for the current shell.\n  --show-completion     Show completion for the current shell, to copy it or\n                        customize the installation.\n  --help                Show this message and exit.\n\nCommands:\n  items\n  users\n\nrestart ↻\n```\n\nCheck the `items` command:\n\n```\n\nfast →💬 Check the help for itemspython main.py items --help\n💬 It shows its own commands (subcommands): create, delete, sellUsage: main.py items [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  create\n  delete\n  sell\n\n💬 Try itpython main.py items create Wand\nCreating item: Wand\n\npython main.py items sell Vase\nSelling item: Vase\n\nrestart ↻\n```\n\nAnd the same for the `users` command:\n\n```\n\nfast →python main.py users --help\nUsage: main.py users [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  create\n  delete\n\n💬 Try itpython main.py users create Camila\nCreating user: Camila\n\nrestart ↻\n```\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/subcommands/single-file/?q=",
      "ogUrl": "https://typer.tiangolo.com/tutorial/subcommands/single-file/",
      "title": "SubCommands in a Single File - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/subcommands/single-file/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/subcommands/single-file.png",
      "ogTitle": "SubCommands in a Single File - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/subcommands/single-file.png",
      "og:title": "SubCommands in a Single File - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/subcommands/single-file/?q=",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/subcommands/single-file.png",
      "twitter:title": "SubCommands in a Single File - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/parameter-types/number/?q=#number)\n\n# Number [¶](https://typer.tiangolo.com/tutorial/parameter-types/number/?q=\\#number \"Permanent link\")\n\nYou can define numeric validations with `max` and `min` values for `int` and `float` _CLI parameters_:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(\n    id: Annotated[int, typer.Argument(min=0, max=1000)],\n    age: Annotated[int, typer.Option(min=18)] = 20,\n    score: Annotated[float, typer.Option(max=100)] = 0,\n):\n    print(f\"ID is {id}\")\n    print(f\"--age is {age}\")\n    print(f\"--score is {score}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_2_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(\n    id: int = typer.Argument(..., min=0, max=1000),\n    age: int = typer.Option(20, min=18),\n    score: float = typer.Option(0, max=100),\n):\n    print(f\"ID is {id}\")\n    print(f\"--age is {age}\")\n    print(f\"--score is {score}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n_CLI arguments_ and _CLI options_ can both use these validations.\n\nYou can specify `min`, `max` or both.\n\nCheck it:\n\n```\n\nfast →python main.py --help\n💬 Notice the extra RANGE in the help text for --age and --scoreUsage: main.py [OPTIONS] ID\n\nArguments:\n  ID  [required]\n\nOptions:\n  --age INTEGER RANGE   [default: 20]\n  --score FLOAT RANGE   [default: 0]\n  --help                Show this message and exit.\n\n💬 Pass all the CLI parameterspython main.py 5 --age 20 --score 90\nID is 5\n--age is 20\n--score is 90.0\n\n💬 Pass an invalid IDpython main.py 1002\nUsage: main.py [OPTIONS] ID\nTry \"main.py --help\" for help.\n\nError: Invalid value for 'ID': 1002 is not in the range 0<=x<=1000.\n\n💬 Pass an invalid agepython main.py 5 --age 15\nUsage: main.py [OPTIONS] ID\nTry \"main.py --help\" for help.\n\nError: Invalid value for '--age': 15 is not in the range x>=18.\n\n💬 Pass an invalid scorepython main.py 5 --age 20 --score 100.5\nUsage: main.py [OPTIONS] ID\nTry \"main.py --help\" for help.\n\nError: Invalid value for '--score': 100.5 is not in the range x<=100.\n\n💬 But as we didn't specify a minimum score, this is acceptedpython main.py 5 --age 20 --score -5\nID is 5\n--age is 20\n--score is -5.0\n\nrestart ↻\n```\n\n## Clamping numbers [¶](https://typer.tiangolo.com/tutorial/parameter-types/number/?q=\\#clamping-numbers \"Permanent link\")\n\nYou might want to, instead of showing an error, use the closest minimum or maximum valid values.\n\nYou can do it with the `clamp` parameter:\n\n[Python 3.8+](#__tabbed_3_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(\n    id: Annotated[int, typer.Argument(min=0, max=1000)],\n    rank: Annotated[int, typer.Option(max=10, clamp=True)] = 0,\n    score: Annotated[float, typer.Option(min=0, max=100, clamp=True)] = 0,\n):\n    print(f\"ID is {id}\")\n    print(f\"--rank is {rank}\")\n    print(f\"--score is {score}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_4_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(\n    id: int = typer.Argument(..., min=0, max=1000),\n    rank: int = typer.Option(0, max=10, clamp=True),\n    score: float = typer.Option(0, min=0, max=100, clamp=True),\n):\n    print(f\"ID is {id}\")\n    print(f\"--rank is {rank}\")\n    print(f\"--score is {score}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nAnd then, when you pass data that is out of the valid range, it will be \"clamped\", the closest valid value will be used:\n\n```\n\nfast →💬 ID doesn't have clamp, so it shows an errorpython main.py 1002\nUsage: main.py [OPTIONS] ID\nTry \"main.py --help\" for help.\n\nError: Invalid value for 'ID': 1002 is not in the range 0<=x<=1000.\n\n💬 But --rank and --score use clamppython main.py 5 --rank 11 --score -5\nID is 5\n--rank is 10\n--score is 0\n\nrestart ↻\n```\n\n## Counter _CLI options_ [¶](https://typer.tiangolo.com/tutorial/parameter-types/number/?q=\\#counter-cli-options \"Permanent link\")\n\nYou can make a _CLI option_ work as a counter with the `counter` parameter:\n\n[Python 3.8+](#__tabbed_5_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(verbose: Annotated[int, typer.Option(\"--verbose\", \"-v\", count=True)] = 0):\n    print(f\"Verbose level is {verbose}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_6_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(verbose: int = typer.Option(0, \"--verbose\", \"-v\", count=True)):\n    print(f\"Verbose level is {verbose}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nIt means that the _CLI option_ will be like a boolean flag, e.g. `--verbose`.\n\nAnd the value you receive in the function will be the amount of times that `--verbose` was added:\n\n```\n\nfast →💬 Check itpython main.py\nVerbose level is 0\n\n💬 Now use one --verbosepython main.py --verbose\nVerbose level is 1\n\n💬 Now 3 --verbosepython main.py --verbose --verbose --verbose\nVerbose level is 3\n\n💬 And with the short namepython main.py -v\nVerbose level is 1\n\n💬 And with the short name 3 timespython main.py -v -v -v\nVerbose level is 3\n\n💬 As short names can be put together, this also workspython main.py -vvv\nVerbose level is 3\n\nrestart ↻\n```\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/parameter-types/number/?q=",
      "ogUrl": "https://typer.tiangolo.com/tutorial/parameter-types/number/",
      "title": "Number - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/parameter-types/number/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/parameter-types/number.png",
      "ogTitle": "Number - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/parameter-types/number.png",
      "og:title": "Number - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/parameter-types/number/?q=",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/parameter-types/number.png",
      "twitter:title": "Number - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/arguments/help/?q=#cli-arguments-with-help)\n\n# CLI Arguments with Help [¶](https://typer.tiangolo.com/tutorial/arguments/help/?q=\\#cli-arguments-with-help \"Permanent link\")\n\nIn the _First Steps_ section you saw how to add help for a CLI app/command by adding it to a function's docstring.\n\nHere's how that last example looked like:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nimport typer\n\ndef main(name: str, lastname: str = \"\", formal: bool = False):\n    \"\"\"\n    Say hi to NAME, optionally with a --lastname.\n\n    If --formal is used, say hi very formally.\n    \"\"\"\n    if formal:\n        print(f\"Good day Ms. {name} {lastname}.\")\n    else:\n        print(f\"Hello {name} {lastname}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nNow that you also know how to use `typer.Argument()`, let's use it to add documentation specific for a _CLI argument_.\n\n## Add a `help` text for a _CLI argument_ [¶](https://typer.tiangolo.com/tutorial/arguments/help/?q=\\#add-a-help-text-for-a-cli-argument \"Permanent link\")\n\nYou can use the `help` parameter to add a help text for a _CLI argument_:\n\n[Python 3.8+](#__tabbed_2_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(name: Annotated[str, typer.Argument(help=\"The name of the user to greet\")]):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_3_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(name: str = typer.Argument(..., help=\"The name of the user to greet\")):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nAnd it will be used in the automatic `--help` option:\n\n```\n\nfast →python main.py --help\n💬 Check the section with Arguments below 🚀Usage: main.py [OPTIONS] NAME\n\nArguments:\n  NAME  The name of the user to greet  [required]\n\nOptions:\n  --help                Show this message and exit.\n\nrestart ↻\n```\n\n## Combine help text and docstrings [¶](https://typer.tiangolo.com/tutorial/arguments/help/?q=\\#combine-help-text-and-docstrings \"Permanent link\")\n\nAnd of course, you can also combine that `help` with the docstring:\n\n[Python 3.8+](#__tabbed_4_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(name: Annotated[str, typer.Argument(help=\"The name of the user to greet\")]):\n    \"\"\"\n    Say hi to NAME very gently, like Dirk.\n    \"\"\"\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_5_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(name: str = typer.Argument(..., help=\"The name of the user to greet\")):\n    \"\"\"\n    Say hi to NAME very gently, like Dirk.\n    \"\"\"\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nAnd the `--help` option will combine all the information:\n\n```\n\nfast →python main.py --help\n💬 Notice that we have the help text from the docstring and also the Arguments 📝Usage: main.py [OPTIONS] NAME\n\n  Say hi to NAME very gently, like Dirk.\n\nArguments:\n  NAME  The name of the user to greet  [required]\n\nOptions:\n  --help                Show this message and exit.\n\nrestart ↻\n```\n\n## Help with defaults [¶](https://typer.tiangolo.com/tutorial/arguments/help/?q=\\#help-with-defaults \"Permanent link\")\n\nIf you have a _CLI argument_ with a default value, like `\"World\"`:\n\n[Python 3.8+](#__tabbed_6_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(name: Annotated[str, typer.Argument(help=\"Who to greet\")] = \"World\"):\n    \"\"\"\n    Say hi to NAME very gently, like Dirk.\n    \"\"\"\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_7_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(name: str = typer.Argument(\"World\", help=\"Who to greet\")):\n    \"\"\"\n    Say hi to NAME very gently, like Dirk.\n    \"\"\"\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nIt will show that default value in the help text:\n\n```\n\nfast →python main.py --help\n💬 Notice the [default: World] 🔍Usage: main.py [OPTIONS] [NAME]\n\n  Say hi to NAME very gently, like Dirk.\n\nArguments:\n  [NAME]  Who to greet  [default: World]\n\nOptions:\n  --help                Show this message and exit.\n\nrestart ↻\n```\n\nBut you can disable that if you want to, with `show_default=False`:\n\n[Python 3.8+](#__tabbed_8_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(\n    name: Annotated[\\\n        str, typer.Argument(help=\"Who to greet\", show_default=False)\\\n    ] = \"World\",\n):\n    \"\"\"\n    Say hi to NAME very gently, like Dirk.\n    \"\"\"\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_9_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(name: str = typer.Argument(\"World\", help=\"Who to greet\", show_default=False)):\n    \"\"\"\n    Say hi to NAME very gently, like Dirk.\n    \"\"\"\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nAnd then it won't show the default value:\n\n```\n\nfast →python main.py --help\n💬 Notice the there's no [default: World] now 🔥Usage: main.py [OPTIONS] [NAME]\n\n  Say hi to NAME very gently, like Dirk.\n\nArguments:\n  [NAME]  Who to greet\n\nOptions:\n  --help                Show this message and exit.\n\nrestart ↻\n```\n\nTechnical Details\n\nIn Click applications the default values are hidden by default. 🙈\n\nIn **Typer** these default values are shown by default. 👀\n\n## Custom default string [¶](https://typer.tiangolo.com/tutorial/arguments/help/?q=\\#custom-default-string \"Permanent link\")\n\nYou can use the same `show_default` to pass a custom string (instead of a `bool`) to customize the default value to be shown in the help text:\n\n[Python 3.8+](#__tabbed_10_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(\n    name: Annotated[\\\n        str,\\\n        typer.Argument(\\\n            help=\"Who to greet\", show_default=\"Deadpoolio the amazing's name\"\\\n        ),\\\n    ] = \"Wade Wilson\",\n):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_11_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(\n    name: str = typer.Argument(\n        \"Wade Wilson\", help=\"Who to greet\", show_default=\"Deadpoolio the amazing's name\"\n    ),\n):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nAnd it will be used in the help text:\n\n```\n\nfast →python main.py --help\nUsage: main.py [OPTIONS] [NAME]\n\nArguments:\n  [NAME]  Who to greet  [default: (Deadpoolio the amazing's name)]\n\nOptions:\n  --help                Show this message and exit.\n\n💬 See it shows \"(Deadpoolio the amazing's name)\" instead of the actual default of \"Wade Wilson\"\nrestart ↻\n```\n\n## Custom help name ( `metavar`) [¶](https://typer.tiangolo.com/tutorial/arguments/help/?q=\\#custom-help-name-metavar \"Permanent link\")\n\nYou can also customize the text used in the generated help text to represent a _CLI argument_.\n\nBy default, it will be the same name you declared, in uppercase letters.\n\nSo, if you declare it as:\n\n```md-code__content\nname: str\n\n```\n\nIt will be shown as:\n\n```md-code__content\nNAME\n\n```\n\nBut you can customize it with the `metavar` parameter for `typer.Argument()`.\n\nFor example, let's say you don't want to have the default of `NAME`, you want to have `username`, in lowercase, and you really want ✨ emojis ✨ everywhere:\n\n[Python 3.8+](#__tabbed_12_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(name: Annotated[str, typer.Argument(metavar=\"✨username✨\")] = \"World\"):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_13_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(name: str = typer.Argument(\"World\", metavar=\"✨username✨\")):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nNow the generated help text will have `✨username✨` instead of `NAME`:\n\n```\n\nfast →python main.py --help\nUsage: main.py [OPTIONS] ✨username✨\n\nArguments:\n  ✨username✨  [default: World]\n\nOptions:\n  --help                Show this message and exit.\n\nrestart ↻\n```\n\n## _CLI Argument_ help panels [¶](https://typer.tiangolo.com/tutorial/arguments/help/?q=\\#cli-argument-help-panels \"Permanent link\")\n\nYou might want to show the help information for _CLI arguments_ in different panels when using the `--help` option.\n\nIf you have installed Rich as described in the docs for [Printing and Colors](https://typer.tiangolo.com/tutorial/printing/), you can set the `rich_help_panel` parameter to the name of the panel where you want this _CLI argument_ to be shown:\n\n[Python 3.8+](#__tabbed_14_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(\n    name: Annotated[str, typer.Argument(help=\"Who to greet\")],\n    lastname: Annotated[\\\n        str, typer.Argument(help=\"The last name\", rich_help_panel=\"Secondary Arguments\")\\\n    ] = \"\",\n    age: Annotated[\\\n        str,\\\n        typer.Argument(help=\"The user's age\", rich_help_panel=\"Secondary Arguments\"),\\\n    ] = \"\",\n):\n    \"\"\"\n    Say hi to NAME very gently, like Dirk.\n    \"\"\"\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_15_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(\n    name: str = typer.Argument(..., help=\"Who to greet\"),\n    lastname: str = typer.Argument(\n        \"\", help=\"The last name\", rich_help_panel=\"Secondary Arguments\"\n    ),\n    age: str = typer.Argument(\n        \"\", help=\"The user's age\", rich_help_panel=\"Secondary Arguments\"\n    ),\n):\n    \"\"\"\n    Say hi to NAME very gently, like Dirk.\n    \"\"\"\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nThen, if you check the `--help` option, you will see a default panel named \" `Arguments`\" for the _CLI arguments_ that don't have a custom `rich_help_panel`.\n\nAnd next you will see other panels for the _CLI arguments_ that have a custom panel set in the `rich_help_panel` parameter:\n\n```\n\nfast →python main.py --help\n Usage: main.py [OPTIONS] NAME [LASTNAME] [AGE]\n\n Say hi to NAME very gently, like Dirk.\n\n╭─ Arguments ───────────────────────────────────────────────────────╮\n│ *    name      TEXT  Who to greet [default: None] [required]      │\n╰───────────────────────────────────────────────────────────────────╯\n╭─ Secondary Arguments ─────────────────────────────────────────────╮\n│   lastname      [LASTNAME]  The last name                         │\n│   age           [AGE]       The user's age                        │\n╰───────────────────────────────────────────────────────────────────╯\n╭─ Options ─────────────────────────────────────────────────────────╮\n│ --help                        Show this message and exit.         │\n╰───────────────────────────────────────────────────────────────────╯\n\nrestart ↻\n```\n\nIn this example we have a custom _CLI arguments_ panel named \" `Secondary Arguments`\".\n\n## Help with style using Rich [¶](https://typer.tiangolo.com/tutorial/arguments/help/?q=\\#help-with-style-using-rich \"Permanent link\")\n\nIn a future section you will see how to use custom markup in the `help` for _CLI arguments_ when reading about [Commands - Command Help](https://typer.tiangolo.com/tutorial/commands/help/#rich-markdown-and-markup).\n\nIf you are in a hurry you can jump there, but otherwise, it would be better to continue reading here and following the tutorial in order.\n\n## Hide a _CLI argument_ from the help text [¶](https://typer.tiangolo.com/tutorial/arguments/help/?q=\\#hide-a-cli-argument-from-the-help-text \"Permanent link\")\n\nIf you want, you can make a _CLI argument_ **not** show up in the `Arguments` section in the help text.\n\nYou will probably not want to do this normally, but it's possible:\n\n[Python 3.8+](#__tabbed_16_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(name: Annotated[str, typer.Argument(hidden=True)] = \"World\"):\n    \"\"\"\n    Say hi to NAME very gently, like Dirk.\n    \"\"\"\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_17_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nimport typer\n\ndef main(name: str = typer.Argument(\"World\", hidden=True)):\n    \"\"\"\n    Say hi to NAME very gently, like Dirk.\n    \"\"\"\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nCheck it:\n\n```\n\nfast →python main.py --help\n💬 Notice there's no Arguments section at all 🔥Usage: main.py [OPTIONS] [NAME]\n\n  Say hi to NAME very gently, like Dirk.\n\nOptions:\n  --help                Show this message and exit.\n\nrestart ↻\n```\n\nInfo\n\nHave in mind that the _CLI argument_ will still show up in the first line with `Usage`.\n\nBut it won't show up in the main help text under the `Arguments` section.\n\n### Help text for _CLI arguments_ in Click [¶](https://typer.tiangolo.com/tutorial/arguments/help/?q=\\#help-text-for-cli-arguments-in-click \"Permanent link\")\n\nClick itself doesn't support adding help for _CLI arguments_, and it doesn't generate help for them as in the \" `Arguments:`\" sections in the examples above.\n\nNot supporting `help` in _CLI arguments_ is an intentional [design decision in Click](https://click.palletsprojects.com/en/7.x/documentation/#documenting-arguments):\n\n> This is to follow the general convention of Unix tools of using arguments for only the most necessary things, and to document them in the command help text by referring to them by name.\n\nSo, in Click applications, you are expected to write all the documentation for _CLI arguments_ by hand in the docstring.\n\n* * *\n\nNevertheless, **Typer supports `help` for _CLI arguments_**. ✨ 🤷‍♂\n\n**Typer** doesn't follow that convention and instead supports `help` to make it easier to have consistent help texts with a consistent format for your CLI programs. 🎨\n\nThis is also to help you create CLI programs that are ✨ awesome ✨ _by default_. With very little code.\n\nIf you want to keep Click's convention in a **Typer** app, you can do it with the `hidden` parameter as described above.\n\nTechnical Details\n\nTo support `help` in _CLI arguments_ **Typer** does a lot of internal work in its own sub-classes of Click's internal classes.\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/arguments/help/?q=",
      "ogUrl": "https://typer.tiangolo.com/tutorial/arguments/help/",
      "title": "CLI Arguments with Help - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/arguments/help/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/arguments/help.png",
      "ogTitle": "CLI Arguments with Help - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/arguments/help.png",
      "og:title": "CLI Arguments with Help - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/arguments/help/?q=",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/arguments/help.png",
      "twitter:title": "CLI Arguments with Help - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/install/?q=#install-typer)\n\n# Install **Typer** [¶](https://typer.tiangolo.com/tutorial/install/?q=\\#install-typer \"Permanent link\")\n\nThe first step is to install **Typer**.\n\nFirst, make sure you create your [virtual environment](https://typer.tiangolo.com/virtual-environments/), activate it, and then install it, for example with:\n\n```\n\nfast →pip install typerSuccessfully installed typer click shellingham rich\n\nrestart ↻\n```\n\nBy default, `typer` comes with `rich` and `shellingham`.\n\nNote\n\nIf you are an advanced user and want to opt out of these default extra dependencies, you can instead install `typer-slim`.\n\n```md-code__content\npip install typer\n\n```\n\n...includes the same optional dependencies as:\n\n```md-code__content\npip install \"typer-slim[standard]\"\n\n```\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/install/?q=",
      "ogUrl": "https://typer.tiangolo.com/tutorial/install/",
      "title": "Install Typer - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/install/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/install.png",
      "ogTitle": "Install Typer - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/install.png",
      "og:title": "Install Typer - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/install/?q=",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/install.png",
      "twitter:title": "Install Typer - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/commands/context/?q=#using-the-context)\n\n# Using the Context [¶](https://typer.tiangolo.com/tutorial/commands/context/?q=\\#using-the-context \"Permanent link\")\n\nWhen you create a **Typer** application it uses Click underneath. And every Click application has a special object called a [\"Context\"](https://click.palletsprojects.com/en/8.1.x/commands/#nested-handling-and-contexts) that is normally hidden.\n\nBut you can access the context by declaring a function parameter of type `typer.Context`.\n\nYou might have read it in [CLI Option Callback and Context](https://typer.tiangolo.com/tutorial/options/callback-and-context/).\n\nThe same way, in commands or in the main `Typer` callback you can access the context by declaring a function parameter of type `typer.Context`.\n\n## Getting the context [¶](https://typer.tiangolo.com/tutorial/commands/context/?q=\\#getting-the-context \"Permanent link\")\n\nFor example, let's say that you want to execute some logic in a `Typer` callback depending on the subcommand that is being called.\n\nYou can get the name of the subcommand from the context:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\n\n@app.command()\ndef create(username: str):\n    print(f\"Creating user: {username}\")\n\n@app.command()\ndef delete(username: str):\n    print(f\"Deleting user: {username}\")\n\n@app.callback()\ndef main(ctx: typer.Context):\n    \"\"\"\n    Manage users in the awesome CLI app.\n    \"\"\"\n    print(f\"About to execute command: {ctx.invoked_subcommand}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nCheck it:\n\n```\n\nfast →python main.py create Camila\n💬 We get the message from the callbackAbout to execute command: create\nCreating user: Camila\n\npython main.py delete Camila\n💬 We get the message from the callback, this time with deleteAbout to execute command: delete\nDeleting user: Camila\n\nrestart ↻\n```\n\n## Executable callback [¶](https://typer.tiangolo.com/tutorial/commands/context/?q=\\#executable-callback \"Permanent link\")\n\nBy default, the callback is only executed right before executing a command.\n\nAnd if no command is provided, the help message is shown.\n\nBut we could make it run even without a subcommand with `invoke_without_command=True`:\n\n[Python 3.8+](#__tabbed_2_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\n\n@app.command()\ndef create(username: str):\n    print(f\"Creating user: {username}\")\n\n@app.command()\ndef delete(username: str):\n    print(f\"Deleting user: {username}\")\n\n@app.callback(invoke_without_command=True)\ndef main():\n    \"\"\"\n    Manage users in the awesome CLI app.\n    \"\"\"\n    print(\"Initializing database\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nCheck it:\n\n```\n\nfast →python main.py\n💬 The callback is executed, we don't get the default help messageInitializing database\n\n💬 Try with a commandpython main.py create Camila\n💬 The callback is still executedInitializing database\nCreating user: Camila\n\nrestart ↻\n```\n\n## Exclusive executable callback [¶](https://typer.tiangolo.com/tutorial/commands/context/?q=\\#exclusive-executable-callback \"Permanent link\")\n\nWe might not want the callback to be executed if there's already other command that will be executed.\n\nFor that, we can get the `typer.Context` and check if there's an invoked command in `ctx.invoked_subcommand`.\n\nIf it's `None`, it means that we are not calling a subcommand but the main program (the callback) directly:\n\n[Python 3.8+](#__tabbed_3_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\n\n@app.command()\ndef create(username: str):\n    print(f\"Creating user: {username}\")\n\n@app.command()\ndef delete(username: str):\n    print(f\"Deleting user: {username}\")\n\n@app.callback(invoke_without_command=True)\ndef main(ctx: typer.Context):\n    \"\"\"\n    Manage users in the awesome CLI app.\n    \"\"\"\n    if ctx.invoked_subcommand is None:\n        print(\"Initializing database\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nCheck it:\n\n```\n\nfast →python main.py\n💬 The callback is executedInitializing database\n\n💬 Check it with a subcommandpython main.py create Camila\n💬 This time the callback is not executedCreating user: Camila\n\nrestart ↻\n```\n\n## Configuring the context [¶](https://typer.tiangolo.com/tutorial/commands/context/?q=\\#configuring-the-context \"Permanent link\")\n\nYou can pass configurations for the context when creating a command or callback.\n\nTo read more about the available configurations check the docs for [Click's `Context`](https://click.palletsprojects.com/en/7.x/api/#context).\n\nFor example, you could keep additional _CLI parameters_ not declared in your CLI program with `ignore_unknown_options` and `allow_extra_args`.\n\nThen you can access those extra raw _CLI parameters_ as a `list` of `str` in `ctx.args`:\n\n[Python 3.8+](#__tabbed_4_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer()\n\n@app.command(\n    context_settings={\"allow_extra_args\": True, \"ignore_unknown_options\": True}\n)\ndef main(ctx: typer.Context):\n    for extra_arg in ctx.args:\n        print(f\"Got extra arg: {extra_arg}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\n```\n\nfast →python main.py --name Camila --city Berlin\nGot extra arg: --name\nGot extra arg: Camila\nGot extra arg: --city\nGot extra arg: Berlin\n\nrestart ↻\n```\n\nTip\n\nNotice that it saves all the extra _CLI parameters_ as a raw `list` of `str`, including the _CLI option_ names and values, everything together.\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/commands/context/?q=",
      "ogUrl": "https://typer.tiangolo.com/tutorial/commands/context/",
      "title": "Using the Context - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/commands/context/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/commands/context.png",
      "ogTitle": "Using the Context - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/commands/context.png",
      "og:title": "Using the Context - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/commands/context/?q=",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/commands/context.png",
      "twitter:title": "Using the Context - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/typer-command/?q=#typer-command)\n\n# `typer` command [¶](https://typer.tiangolo.com/tutorial/typer-command/?q=\\#typer-command \"Permanent link\")\n\nThe `typer` command provides ✨ completion ✨ in the Terminal for your own small scripts. Even if they don't use Typer internally. Of course, it works better if you use **Typer** in your script.\n\nIt's probably most useful if you have a small custom Python script using **Typer** (maybe as part of some project), for some small tasks, and it's not complex/important enough to create a whole installable Python package for it (something to be installed with `pip`).\n\nIn that case, you can run your program with the `typer` command in your Terminal, and it will provide completion for your script.\n\nThe `typer` command also has functionality to generate Markdown documentation for your own **Typer** programs 📝.\n\n## Install [¶](https://typer.tiangolo.com/tutorial/typer-command/?q=\\#install \"Permanent link\")\n\nWhen you install **Typer** with:\n\n```md-code__content\npip install typer\n\n```\n\n...it includes the `typer` command.\n\nIf you don't want to have the `typer` command, you can install instead:\n\n```md-code__content\npip install typer-slim\n\n```\n\nYou can still use it by calling the Typer library as a module with:\n\n```md-code__content\npython -m typer\n\n```\n\n## Install completion [¶](https://typer.tiangolo.com/tutorial/typer-command/?q=\\#install-completion \"Permanent link\")\n\nYou can then install completion for the `typer` command with:\n\n```\n\nfast →typer --install-completion\nbash completion installed in /home/user/.bashrc.\nCompletion will take effect once you restart the terminal.\n\nrestart ↻\n```\n\n### Sample script [¶](https://typer.tiangolo.com/tutorial/typer-command/?q=\\#sample-script \"Permanent link\")\n\nLet's say you have a script that uses **Typer** in `my_custom_script.py`:\n\n```md-code__content\nfrom typing import Optional\n\nimport typer\n\napp = typer.Typer()\n\n@app.command()\ndef hello(name: Optional[str] = None):\n    if name:\n        typer.echo(f\"Hello {name}\")\n    else:\n        typer.echo(\"Hello World!\")\n\n@app.command()\ndef bye(name: Optional[str] = None):\n    if name:\n        typer.echo(f\"Bye {name}\")\n    else:\n        typer.echo(\"Goodbye!\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\nFor it to work, you would also install **Typer**:\n\n```\n\nfast →python -m pip install typerSuccessfully installed typer\n\nrestart ↻\n```\n\n### Run with Python [¶](https://typer.tiangolo.com/tutorial/typer-command/?q=\\#run-with-python \"Permanent link\")\n\nThen you could run your script with normal Python:\n\n```\n\nfast →python my_custom_script.py hello\nHello World!\n\npython my_custom_script.py hello --name Camila\nHello Camila!\n\npython my_custom_script.py bye --name Camila\nBye Camila\n\nrestart ↻\n```\n\nThere's nothing wrong with using Python directly to run it. And, in fact, if some other code or program uses your script, that would probably be the best way to do it.\n\n⛔️ But in your terminal, you won't get completion when hitting `TAB` for any of the subcommands or options, like `hello`, `bye`, and `--name`.\n\n### Run with the `typer` command. [¶](https://typer.tiangolo.com/tutorial/typer-command/?q=\\#run-with-the-typer-command \"Permanent link\")\n\nYou can also run the same script with the `typer` command:\n\n```\n\nfast →typer my_custom_script.py run hello\nHello World!\n\ntyper my_custom_script.py run hello --name Camila\nHello Camila!\n\ntyper my_custom_script.py run bye --name Camila\nBye Camila\n\nrestart ↻\n```\n\n- Instead of using `python` directly you use the `typer` command.\n- After the name of the file, add the subcommand `run`.\n\n✔️ If you installed completion for the `typer` command as described above, when you hit `TAB` you will have ✨ completion for everything ✨, including all the subcommands and options of your script, like `hello`, `bye`, and `--name` 🚀.\n\n## If main [¶](https://typer.tiangolo.com/tutorial/typer-command/?q=\\#if-main \"Permanent link\")\n\nBecause the `typer` command won't use the block with:\n\n```md-code__content\nif __name__ == \"__main__\":\n    app()\n\n```\n\n...you can also remove it if you are calling that script only with the `typer` command.\n\n## Run other files [¶](https://typer.tiangolo.com/tutorial/typer-command/?q=\\#run-other-files \"Permanent link\")\n\nThe `typer` command can run any script with **Typer**, but the script doesn't even have to use **Typer** at all.\n\nYou could even run a file with a function that could be used with `typer.run()`, even if the script doesn't use `typer.run()` or anything else.\n\nFor example, a file `main.py` like this will still work:\n\n```md-code__content\ndef main(name: str = \"World\"):\n    \"\"\"\n    Say hi to someone, by default to the World.\n    \"\"\"\n    print(f\"Hello {name}\")\n\n```\n\nThen you can call it with:\n\n```\n\nfast →typer main.py run --helpUsage: typer run [OPTIONS]\n\n  Say hi to someone, by default to the World.\n\nOptions:\n  --name TEXT\n  --help       Show this message and exit.\n\ntyper main.py run --name Camila\nHello Camila\n\nrestart ↻\n```\n\nAnd it will also have completion for things like the `--name` _CLI Option_.\n\n## Run a package or module [¶](https://typer.tiangolo.com/tutorial/typer-command/?q=\\#run-a-package-or-module \"Permanent link\")\n\nInstead of a file path you can pass a module (possibly in a package) to import.\n\nFor example:\n\n```\n\nfast →typer my_package.main run --helpUsage: typer run [OPTIONS]\n\nOptions:\n  --name TEXT\n  --help       Show this message and exit.\n\ntyper my_package.main run --name Camila\nHello Camila\n\nrestart ↻\n```\n\n## Options [¶](https://typer.tiangolo.com/tutorial/typer-command/?q=\\#options \"Permanent link\")\n\nYou can specify one of the following **CLI options**:\n\n- `--app`: the name of the variable with a `Typer()` object to run as the main app.\n- `--func`: the name of the variable with a function that would be used with `typer.run()`.\n\n### Defaults [¶](https://typer.tiangolo.com/tutorial/typer-command/?q=\\#defaults \"Permanent link\")\n\nWhen your run a script with the `typer` command it will use the app from the following priority:\n\n- An app object from the `--app` _CLI Option_.\n- A function to convert to a **Typer** app from `--func` _CLI Option_ (like when using `typer.run()`).\n- A **Typer** app in a variable with a name of `app`, `cli`, or `main`.\n- The first **Typer** app available in the file, with any name.\n- A function in a variable with a name of `main`, `cli`, or `app`.\n- The first function in the file, with any name.\n\n## Generate docs [¶](https://typer.tiangolo.com/tutorial/typer-command/?q=\\#generate-docs \"Permanent link\")\n\nYou can also use the `typer` command to generate Markdown documentation for your **Typer** application.\n\n### Sample script with docs [¶](https://typer.tiangolo.com/tutorial/typer-command/?q=\\#sample-script-with-docs \"Permanent link\")\n\nFor example, you could have a script like:\n\n[Python 3.8+ - non-Annotated](#__tabbed_1_1)\n\n```md-code__content\nimport typer\n\napp = typer.Typer(help=\"Awesome CLI user manager.\")\n\n@app.command()\ndef create(username: str):\n    \"\"\"\n    Create a new user with USERNAME.\n    \"\"\"\n    print(f\"Creating user: {username}\")\n\n@app.command()\ndef delete(\n    username: str,\n    force: bool = typer.Option(\n        ...,\n        prompt=\"Are you sure you want to delete the user?\",\n        help=\"Force deletion without confirmation.\",\n    ),\n):\n    \"\"\"\n    Delete a user with USERNAME.\n\n    If --force is not used, will ask for confirmation.\n    \"\"\"\n    if force:\n        print(f\"Deleting user: {username}\")\n    else:\n        print(\"Operation cancelled\")\n\n@app.command()\ndef delete_all(\n    force: bool = typer.Option(\n        ...,\n        prompt=\"Are you sure you want to delete ALL users?\",\n        help=\"Force deletion without confirmation.\",\n    ),\n):\n    \"\"\"\n    Delete ALL users in the database.\n\n    If --force is not used, will ask for confirmation.\n    \"\"\"\n    if force:\n        print(\"Deleting all users\")\n    else:\n        print(\"Operation cancelled\")\n\n@app.command()\ndef init():\n    \"\"\"\n    Initialize the users database.\n    \"\"\"\n    print(\"Initializing user database\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+](#__tabbed_2_1)\n\n```md-code__content\nimport typer\nfrom typing_extensions import Annotated\n\napp = typer.Typer(help=\"Awesome CLI user manager.\")\n\n@app.command()\ndef create(username: str):\n    \"\"\"\n    Create a new user with USERNAME.\n    \"\"\"\n    print(f\"Creating user: {username}\")\n\n@app.command()\ndef delete(\n    username: str,\n    force: Annotated[\\\n        bool,\\\n        typer.Option(\\\n            prompt=\"Are you sure you want to delete the user?\",\\\n            help=\"Force deletion without confirmation.\",\\\n        ),\\\n    ],\n):\n    \"\"\"\n    Delete a user with USERNAME.\n\n    If --force is not used, will ask for confirmation.\n    \"\"\"\n    if force:\n        print(f\"Deleting user: {username}\")\n    else:\n        print(\"Operation cancelled\")\n\n@app.command()\ndef delete_all(\n    force: Annotated[\\\n        bool,\\\n        typer.Option(\\\n            prompt=\"Are you sure you want to delete ALL users?\",\\\n            help=\"Force deletion without confirmation.\",\\\n        ),\\\n    ],\n):\n    \"\"\"\n    Delete ALL users in the database.\n\n    If --force is not used, will ask for confirmation.\n    \"\"\"\n    if force:\n        print(\"Deleting all users\")\n    else:\n        print(\"Operation cancelled\")\n\n@app.command()\ndef init():\n    \"\"\"\n    Initialize the users database.\n    \"\"\"\n    print(\"Initializing user database\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\n### Generate docs with the `typer` command [¶](https://typer.tiangolo.com/tutorial/typer-command/?q=\\#generate-docs-with-the-typer-command \"Permanent link\")\n\nThen you could generate docs for it with the `typer` command.\n\nYou can use the subcommand `utils`.\n\nAnd then the subcommand `docs`.\n\n```\n\nfast →typer some_script.py utils docs\nrestart ↻\n```\n\nTip\n\nIf you installed only `typer-slim` and you don't have the `typer` command, you can still generate docs with:\n\n```md-code__content\n$ python -m typer some_script.py utils docs\n\n```\n\n**Options**:\n\n- `--name TEXT`: The name of the CLI program to use in docs.\n- `--output FILE`: An output file to write docs to, like README.md.\n- `--title TEXT`: A title to use in the docs, by default the name of the command.\n\nFor example:\n\n```\n\nfast →typer my_package.main utils docs --name awesome-cli --output README.md\nDocs saved to: README.md\n\nrestart ↻\n```\n\n### Sample docs output [¶](https://typer.tiangolo.com/tutorial/typer-command/?q=\\#sample-docs-output \"Permanent link\")\n\nFor example, for the previous script, the generated docs would look like:\n\n* * *\n\n## `awesome-cli` [¶](https://typer.tiangolo.com/tutorial/typer-command/?q=\\#awesome-cli \"Permanent link\")\n\nAwesome CLI user manager.\n\n**Usage**:\n\n```md-code__content\n$ awesome-cli [OPTIONS] COMMAND [ARGS]...\n\n```\n\n**Options**:\n\n- `--install-completion`: Install completion for the current shell.\n- `--show-completion`: Show completion for the current shell, to copy it or customize the installation.\n- `--help`: Show this message and exit.\n\n**Commands**:\n\n- `create`: Create a new user with USERNAME.\n- `delete`: Delete a user with USERNAME.\n- `delete-all`: Delete ALL users in the database.\n- `init`: Initialize the users database.\n\n## `awesome-cli create` [¶](https://typer.tiangolo.com/tutorial/typer-command/?q=\\#awesome-cli-create \"Permanent link\")\n\nCreate a new user with USERNAME.\n\n**Usage**:\n\n```md-code__content\n$ awesome-cli create [OPTIONS] USERNAME\n\n```\n\n**Options**:\n\n- `--help`: Show this message and exit.\n\n## `awesome-cli delete` [¶](https://typer.tiangolo.com/tutorial/typer-command/?q=\\#awesome-cli-delete \"Permanent link\")\n\nDelete a user with USERNAME.\n\nIf --force is not used, will ask for confirmation.\n\n**Usage**:\n\n```md-code__content\n$ awesome-cli delete [OPTIONS] USERNAME\n\n```\n\n**Options**:\n\n- `--force / --no-force`: Force deletion without confirmation. \\[required\\]\n- `--help`: Show this message and exit.\n\n## `awesome-cli delete-all` [¶](https://typer.tiangolo.com/tutorial/typer-command/?q=\\#awesome-cli-delete-all \"Permanent link\")\n\nDelete ALL users in the database.\n\nIf --force is not used, will ask for confirmation.\n\n**Usage**:\n\n```md-code__content\n$ awesome-cli delete-all [OPTIONS]\n\n```\n\n**Options**:\n\n- `--force / --no-force`: Force deletion without confirmation. \\[required\\]\n- `--help`: Show this message and exit.\n\n## `awesome-cli init` [¶](https://typer.tiangolo.com/tutorial/typer-command/?q=\\#awesome-cli-init \"Permanent link\")\n\nInitialize the users database.\n\n**Usage**:\n\n```md-code__content\n$ awesome-cli init [OPTIONS]\n\n```\n\n**Options**:\n\n- `--help`: Show this message and exit.\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/typer-command/?q=",
      "ogUrl": "https://typer.tiangolo.com/tutorial/typer-command/",
      "title": "typer command - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/typer-command/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/typer-command.png",
      "ogTitle": "typer command - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/typer-command.png",
      "og:title": "typer command - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/typer-command/?q=",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/typer-command.png",
      "twitter:title": "typer command - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/options/version/?q=#version-cli-option-is_eager)\n\n# Version CLI Option, `is_eager` [¶](https://typer.tiangolo.com/tutorial/options/version/?q=\\#version-cli-option-is_eager \"Permanent link\")\n\nYou could use a callback to implement a `--version` _CLI option_.\n\nIt would show the version of your CLI program and then it would terminate it. Even before any other _CLI parameter_ is processed.\n\n## First version of `--version` [¶](https://typer.tiangolo.com/tutorial/options/version/?q=\\#first-version-of-version \"Permanent link\")\n\nLet's see a first version of how it could look like:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nfrom typing import Optional\n\nimport typer\nfrom typing_extensions import Annotated\n\n__version__ = \"0.1.0\"\n\ndef version_callback(value: bool):\n    if value:\n        print(f\"Awesome CLI Version: {__version__}\")\n        raise typer.Exit()\n\ndef main(\n    name: Annotated[str, typer.Option()] = \"World\",\n    version: Annotated[\\\n        Optional[bool], typer.Option(\"--version\", callback=version_callback)\\\n    ] = None,\n):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_2_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nfrom typing import Optional\n\nimport typer\n\n__version__ = \"0.1.0\"\n\ndef version_callback(value: bool):\n    if value:\n        print(f\"Awesome CLI Version: {__version__}\")\n        raise typer.Exit()\n\ndef main(\n    name: str = typer.Option(\"World\"),\n    version: Optional[bool] = typer.Option(\n        None, \"--version\", callback=version_callback\n    ),\n):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nTip\n\nNotice that we don't have to get the `typer.Context` and check for `ctx.resilient_parsing` for completion to work, because we only print and modify the program when `--version` is passed, otherwise, nothing is printed or changed from the callback.\n\nIf the `--version` _CLI option_ is passed, we get a value `True` in the callback.\n\nThen we can print the version and raise `typer.Exit()` to make sure the program is terminated before anything else is executed.\n\nWe also declare the explicit _CLI option_ name `--version`, because we don't want an automatic `--no-version`, it would look awkward.\n\nCheck it:\n\n```\n\nfast →python main.py --help\n💬 We get a --version, and don't get an awkward --no-version 🎉Usage: main.py [OPTIONS]\n\nOptions:\n  --version\n  --name TEXT\n  --help                Show this message and exit.\n\n💬 We can call it normallypython main.py --name Camila\nHello Camila\n\n💬 And we can get the versionpython main.py --version\nAwesome CLI Version: 0.1.0\n\n💬 Because we exit in the callback, we don't get a \"Hello World\" message after the version 🚀\nrestart ↻\n```\n\n## Previous parameters and `is_eager` [¶](https://typer.tiangolo.com/tutorial/options/version/?q=\\#previous-parameters-and-is_eager \"Permanent link\")\n\nBut now let's say that the `--name` _CLI option_ that we declared before `--version` is required, and it has a callback that could exit the program:\n\n[Python 3.8+](#__tabbed_3_1)\n\n```md-code__content\nfrom typing import Optional\n\nimport typer\nfrom typing_extensions import Annotated\n\n__version__ = \"0.1.0\"\n\ndef version_callback(value: bool):\n    if value:\n        print(f\"Awesome CLI Version: {__version__}\")\n        raise typer.Exit()\n\ndef name_callback(name: str):\n    if name != \"Camila\":\n        raise typer.BadParameter(\"Only Camila is allowed\")\n\ndef main(\n    name: Annotated[str, typer.Option(callback=name_callback)],\n    version: Annotated[\\\n        Optional[bool], typer.Option(\"--version\", callback=version_callback)\\\n    ] = None,\n):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_4_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nfrom typing import Optional\n\nimport typer\n\n__version__ = \"0.1.0\"\n\ndef version_callback(value: bool):\n    if value:\n        print(f\"Awesome CLI Version: {__version__}\")\n        raise typer.Exit()\n\ndef name_callback(name: str):\n    if name != \"Camila\":\n        raise typer.BadParameter(\"Only Camila is allowed\")\n\ndef main(\n    name: str = typer.Option(..., callback=name_callback),\n    version: Optional[bool] = typer.Option(\n        None, \"--version\", callback=version_callback\n    ),\n):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nThen our CLI program could not work as expected in some cases as it is _right now_, because if we use `--version` after `--name` then the callback for `--name` will be processed before and we can get its error:\n\n```\n\nfast →python main.py --name Rick --version\nOnly Camila is allowed\nAborted!\n\nrestart ↻\n```\n\nTip\n\nWe don't have to check for `ctx.resilient_parsing` in the `name_callback()` for completion to work, because we are not using `typer.echo()`, instead we are raising a `typer.BadParameter`.\n\nTechnical Details\n\n`typer.BadParameter` prints the error to \"standard error\", not to \"standard output\", and because the completion system only reads from \"standard output\", it won't break completion.\n\nInfo\n\nIf you need a refresher about what is \"standard output\" and \"standard error\" check the section in [Printing and Colors: \"Standard Output\" and \"Standard Error\"](https://typer.tiangolo.com/tutorial/printing/#standard-output-and-standard-error).\n\n### Fix with `is_eager` [¶](https://typer.tiangolo.com/tutorial/options/version/?q=\\#fix-with-is_eager \"Permanent link\")\n\nFor those cases, we can mark a _CLI parameter_ (a _CLI option_ or _CLI argument_) with `is_eager=True`.\n\nThat will tell **Typer** (actually Click) that it should process this _CLI parameter_ before the others:\n\n[Python 3.8+](#__tabbed_5_1)\n\n```md-code__content\nfrom typing import Optional\n\nimport typer\nfrom typing_extensions import Annotated\n\n__version__ = \"0.1.0\"\n\ndef version_callback(value: bool):\n    if value:\n        print(f\"Awesome CLI Version: {__version__}\")\n        raise typer.Exit()\n\ndef name_callback(name: str):\n    if name != \"Camila\":\n        raise typer.BadParameter(\"Only Camila is allowed\")\n    return name\n\ndef main(\n    name: Annotated[str, typer.Option(callback=name_callback)],\n    version: Annotated[\\\n        Optional[bool],\\\n        typer.Option(\"--version\", callback=version_callback, is_eager=True),\\\n    ] = None,\n):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_6_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nfrom typing import Optional\n\nimport typer\n\n__version__ = \"0.1.0\"\n\ndef version_callback(value: bool):\n    if value:\n        print(f\"Awesome CLI Version: {__version__}\")\n        raise typer.Exit()\n\ndef name_callback(name: str):\n    if name != \"Camila\":\n        raise typer.BadParameter(\"Only Camila is allowed\")\n    return name\n\ndef main(\n    name: str = typer.Option(..., callback=name_callback),\n    version: Optional[bool] = typer.Option(\n        None, \"--version\", callback=version_callback, is_eager=True\n    ),\n):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nCheck it:\n\n```\n\nfast →python main.py --name Rick --version\n💬 Now we only get the version, and the name is not usedAwesome CLI Version: 0.1.0\n\nrestart ↻\n```\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/options/version/?q=",
      "ogUrl": "https://typer.tiangolo.com/tutorial/options/version/",
      "title": "Version CLI Option, is_eager - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/options/version/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/options/version.png",
      "ogTitle": "Version CLI Option, is_eager - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/options/version.png",
      "og:title": "Version CLI Option, is_eager - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/options/version/?q=",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/options/version.png",
      "twitter:title": "Version CLI Option, is_eager - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/multiple-values/multiple-options/?q=#multiple-cli-options)\n\n# Multiple CLI Options [¶](https://typer.tiangolo.com/tutorial/multiple-values/multiple-options/?q=\\#multiple-cli-options \"Permanent link\")\n\nYou can declare a _CLI option_ that can be used multiple times, and then get all the values.\n\nFor example, let's say you want to accept several users in a single execution.\n\nFor this, use the standard Python `typing.List` to declare it as a `list` of `str`:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nfrom typing import List, Optional\n\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(user: Annotated[Optional[List[str]], typer.Option()] = None):\n    if not user:\n        print(f\"No provided users (raw input = {user})\")\n        raise typer.Abort()\n    for u in user:\n        print(f\"Processing user: {u}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_2_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nfrom typing import List, Optional\n\nimport typer\n\ndef main(user: Optional[List[str]] = typer.Option(None)):\n    if not user:\n        print(f\"No provided users (raw input = {user})\")\n        raise typer.Abort()\n    for u in user:\n        print(f\"Processing user: {u}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nYou will receive the values as you declared them, as a `list` of `str`.\n\nCheck it:\n\n```\n\nfast →💬 The default value is 'None'python main.py\nNo provided users (raw input = None)\nAborted!\n\n💬 Now pass a userpython main.py --user Camila\nProcessing user: Camila\n\n💬 And now try with several userspython main.py --user Camila --user Rick --user Morty\nProcessing user: Camila\nProcessing user: Rick\nProcessing user: Morty\n\nrestart ↻\n```\n\n## Multiple `float` [¶](https://typer.tiangolo.com/tutorial/multiple-values/multiple-options/?q=\\#multiple-float \"Permanent link\")\n\nThe same way, you can use other types and they will be converted by **Typer** to their declared type:\n\n[Python 3.8+](#__tabbed_3_1)\n\n```md-code__content\nfrom typing import List\n\nimport typer\nfrom typing_extensions import Annotated\n\ndef main(number: Annotated[List[float], typer.Option()] = []):\n    print(f\"The sum is {sum(number)}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_4_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nfrom typing import List\n\nimport typer\n\ndef main(number: List[float] = typer.Option([])):\n    print(f\"The sum is {sum(number)}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nCheck it:\n\n```\n\nfast →python main.py\nThe sum is 0\n\n💬 Try with some numberspython main.py --number 2\nThe sum is 2.0\n\n💬 Try with some numberspython main.py --number 2 --number 3 --number 4.5\nThe sum is 9.5\n\nrestart ↻\n```\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/multiple-values/multiple-options/?q=",
      "ogUrl": "https://typer.tiangolo.com/tutorial/multiple-values/multiple-options/",
      "title": "Multiple CLI Options - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/multiple-values/multiple-options/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/multiple-values/multiple-options.png",
      "ogTitle": "Multiple CLI Options - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/multiple-values/multiple-options.png",
      "og:title": "Multiple CLI Options - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/multiple-values/multiple-options/?q=",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/multiple-values/multiple-options.png",
      "twitter:title": "Multiple CLI Options - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/options/callback-and-context/?q=#cli-option-callback-and-context)\n\n# CLI Option Callback and Context [¶](https://typer.tiangolo.com/tutorial/options/callback-and-context/?q=\\#cli-option-callback-and-context \"Permanent link\")\n\nIn some occasions you might want to have some custom logic for a specific _CLI parameter_ (for a _CLI option_ or _CLI argument_) that is executed with the value received from the terminal.\n\nIn those cases you can use a _CLI parameter_ callback function.\n\n## Validate _CLI parameters_ [¶](https://typer.tiangolo.com/tutorial/options/callback-and-context/?q=\\#validate-cli-parameters \"Permanent link\")\n\nFor example, you could do some validation before the rest of the code is executed.\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nfrom typing import Optional\n\nimport typer\nfrom typing_extensions import Annotated\n\ndef name_callback(value: str):\n    if value != \"Camila\":\n        raise typer.BadParameter(\"Only Camila is allowed\")\n    return value\n\ndef main(name: Annotated[Optional[str], typer.Option(callback=name_callback)] = None):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_2_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nfrom typing import Optional\n\nimport typer\n\ndef name_callback(value: str):\n    if value != \"Camila\":\n        raise typer.BadParameter(\"Only Camila is allowed\")\n    return value\n\ndef main(name: Optional[str] = typer.Option(default=None, callback=name_callback)):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nHere you pass a function to `typer.Option()` or `typer.Argument()` with the keyword argument `callback`.\n\nThe function receives the value from the command line. It can do anything with it, and then return the value.\n\nIn this case, if the `--name` is not `Camila` we raise a `typer.BadParameter()` exception.\n\nThe `BadParameter` exception is special, it shows the error with the parameter that generated it.\n\nCheck it:\n\n```\n\nfast →python main.py --name Camila\nHello Camila\n\npython main.py --name Rick\nUsage: main.py [OPTIONS]\n\n💬 We get the error from the callbackError: Invalid value for '--name': Only Camila is allowed\n\nrestart ↻\n```\n\n## Handling completion [¶](https://typer.tiangolo.com/tutorial/options/callback-and-context/?q=\\#handling-completion \"Permanent link\")\n\nThere's something to be aware of with callbacks and completion that requires some small special handling.\n\nBut first let's just use completion in your shell (Bash, Zsh, Fish, or PowerShell).\n\nAfter installing completion (for your own Python package), when you use your CLI program and start adding a _CLI option_ with `--` an then hit `TAB`, your shell will show you the available _CLI options_ (the same for _CLI arguments_, etc).\n\nTo check it quickly with the previous script use the `typer` command:\n\n```\n\nfast →💬 Hit the TAB key in your keyboard below where you see the: [TAB]typer ./main.py [TAB][TAB]\n💬 Depending on your terminal/shell you will get some completion like this ✨run    -- Run the provided Typer app.\nutils  -- Extra utility commands for Typer apps.\n\n💬 Then try with \"run\" and --helptyper ./main.py run --help\n💬 You get a help text with your CLI options as you normally wouldUsage: typer run [OPTIONS]\n\n  Run the provided Typer app.\n\nOptions:\n  --name TEXT  [required]\n  --help       Show this message and exit.\n\n💬 Then try completion with your programtyper ./main.py run --[TAB][TAB]\n💬 You get completion for CLI options--help  -- Show this message and exit.\n--name\n\n💬 And you can run it as if it was with Python directlytyper ./main.py run --name Camila\nHello Camila\n\nrestart ↻\n```\n\n### How shell completion works [¶](https://typer.tiangolo.com/tutorial/options/callback-and-context/?q=\\#how-shell-completion-works \"Permanent link\")\n\nThe way it works internally is that the shell/terminal will call your CLI program with some special environment variables (that hold the current _CLI parameters_, etc) and your CLI program will print some special values that the shell will use to present completion. All this is handled for you by **Typer** behind the scenes.\n\nBut the main **important point** is that it is all based on values printed by your program that the shell reads.\n\n### Breaking completion in a callback [¶](https://typer.tiangolo.com/tutorial/options/callback-and-context/?q=\\#breaking-completion-in-a-callback \"Permanent link\")\n\nLet's say that when the callback is running, we want to show a message saying that it's validating the name:\n\n[Python 3.8+](#__tabbed_3_1)\n\n```md-code__content\nfrom typing import Optional\n\nimport typer\nfrom typing_extensions import Annotated\n\ndef name_callback(value: str):\n    print(\"Validating name\")\n    if value != \"Camila\":\n        raise typer.BadParameter(\"Only Camila is allowed\")\n    return value\n\ndef main(name: Annotated[Optional[str], typer.Option(callback=name_callback)] = None):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_4_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nfrom typing import Optional\n\nimport typer\n\ndef name_callback(value: str):\n    print(\"Validating name\")\n    if value != \"Camila\":\n        raise typer.BadParameter(\"Only Camila is allowed\")\n    return value\n\ndef main(name: Optional[str] = typer.Option(default=None, callback=name_callback)):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nAnd because the callback will be called when the shell calls your program asking for completion, that message `\"Validating name\"` will be printed and it will break completion.\n\nIt will look something like:\n\n```\n\nfast →💬 Run it normallytyper ./main.py run --name Camila\n💬 See the extra message \"Validating name\"Validating name\nHello Camila\n\ntyper ./main.py run --[TAB][TAB]\n💬 Some weird broken error message ⛔️(eval):1: command not found: Validating\nrutyper ./main.pyed Typer app.\n\nrestart ↻\n```\n\n### Fix completion - using the `Context` [¶](https://typer.tiangolo.com/tutorial/options/callback-and-context/?q=\\#fix-completion-using-the-context \"Permanent link\")\n\nWhen you create a **Typer** application it uses Click underneath.\n\nAnd every Click application has a special object called a [\"Context\"](https://click.palletsprojects.com/en/7.x/commands/#nested-handling-and-contexts) that is normally hidden.\n\nBut you can access the context by declaring a function parameter of type `typer.Context`.\n\nThe \"context\" has some additional data about the current execution of your program:\n\n[Python 3.8+](#__tabbed_5_1)\n\n```md-code__content\nfrom typing import Optional\n\nimport typer\nfrom typing_extensions import Annotated\n\ndef name_callback(ctx: typer.Context, value: str):\n    if ctx.resilient_parsing:\n        return\n    print(\"Validating name\")\n    if value != \"Camila\":\n        raise typer.BadParameter(\"Only Camila is allowed\")\n    return value\n\ndef main(name: Annotated[Optional[str], typer.Option(callback=name_callback)] = None):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_6_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nfrom typing import Optional\n\nimport typer\n\ndef name_callback(ctx: typer.Context, value: str):\n    if ctx.resilient_parsing:\n        return\n    print(\"Validating name\")\n    if value != \"Camila\":\n        raise typer.BadParameter(\"Only Camila is allowed\")\n    return value\n\ndef main(name: Optional[str] = typer.Option(default=None, callback=name_callback)):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nThe `ctx.resilient_parsing` will be `True` when handling completion, so you can just return without printing anything else.\n\nBut it will be `False` when calling the program normally. So you can continue the execution of your previous code.\n\nThat's all is needed to fix completion. 🚀\n\nCheck it:\n\n```\n\nfast →typer ./main.py run --[TAB][TAB]\n💬 Now it works correctly 🎉--help  -- Show this message and exit.\n--name\n\n💬 And you can call it normallytyper ./main.py run --name Camila\nValidating name\nHello Camila\n\nrestart ↻\n```\n\n## Using the `CallbackParam` object [¶](https://typer.tiangolo.com/tutorial/options/callback-and-context/?q=\\#using-the-callbackparam-object \"Permanent link\")\n\nThe same way you can access the `typer.Context` by declaring a function parameter with its value, you can declare another function parameter with type `typer.CallbackParam` to get the specific Click `Parameter` object.\n\n[Python 3.8+](#__tabbed_7_1)\n\n```md-code__content\nfrom typing import Optional\n\nimport typer\nfrom typing_extensions import Annotated\n\ndef name_callback(ctx: typer.Context, param: typer.CallbackParam, value: str):\n    if ctx.resilient_parsing:\n        return\n    print(f\"Validating param: {param.name}\")\n    if value != \"Camila\":\n        raise typer.BadParameter(\"Only Camila is allowed\")\n    return value\n\ndef main(name: Annotated[Optional[str], typer.Option(callback=name_callback)] = None):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n🤓 Other versions and variants\n\n[Python 3.8+ - non-Annotated](#__tabbed_8_1)\n\nTip\n\nPrefer to use the `Annotated` version if possible.\n\n```md-code__content\nfrom typing import Optional\n\nimport typer\n\ndef name_callback(ctx: typer.Context, param: typer.CallbackParam, value: str):\n    if ctx.resilient_parsing:\n        return\n    print(f\"Validating param: {param.name}\")\n    if value != \"Camila\":\n        raise typer.BadParameter(\"Only Camila is allowed\")\n    return value\n\ndef main(name: Optional[str] = typer.Option(default=None, callback=name_callback)):\n    print(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nIt's probably not very common, but you could do it if you need it.\n\nFor example if you had a callback that could be used by several _CLI parameters_, that way the callback could know which parameter is each time.\n\nCheck it:\n\n```\n\nfast →python main.py --name Camila\nValidating param: name\nHello Camila\n\nrestart ↻\n```\n\n## Technical Details [¶](https://typer.tiangolo.com/tutorial/options/callback-and-context/?q=\\#technical-details \"Permanent link\")\n\nBecause you get the relevant data in the callback function based on standard Python type annotations, you get type checks and autocompletion in your editor for free.\n\nAnd **Typer** will make sure you get the function parameters you want.\n\nYou don't have to worry about their names, their order, etc.\n\nAs it's based on standard Python types, it \" **just works**\". ✨\n\n### Click's `Parameter` [¶](https://typer.tiangolo.com/tutorial/options/callback-and-context/?q=\\#clicks-parameter \"Permanent link\")\n\nThe `typer.CallbackParam` is actually just a sub-class of Click's [`Parameter`](https://click.palletsprojects.com/en/7.x/api/#click.Parameter), so you get all the right completion in your editor.\n\n### Callback with type annotations [¶](https://typer.tiangolo.com/tutorial/options/callback-and-context/?q=\\#callback-with-type-annotations \"Permanent link\")\n\nYou can get the `typer.Context` and the `typer.CallbackParam` simply by declaring a function parameter of each type.\n\nThe order doesn't matter, the name of the function parameters doesn't matter.\n\nYou could also get only the `typer.CallbackParam` and not the `typer.Context`, or vice versa, it will still work.\n\n### `value` function parameter [¶](https://typer.tiangolo.com/tutorial/options/callback-and-context/?q=\\#value-function-parameter \"Permanent link\")\n\nThe `value` function parameter in the callback can also have any name (e.g. `lastname`) and any type, but it should have the same type annotation as in the main function, because that's what it will receive.\n\nIt's also possible to not declare its type. It will still work.\n\nAnd it's possible to not declare the `value` parameter at all, and, for example, only get the `typer.Context`. That will also work.\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/options/callback-and-context/?q=",
      "ogUrl": "https://typer.tiangolo.com/tutorial/options/callback-and-context/",
      "title": "CLI Option Callback and Context - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/options/callback-and-context/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/options/callback-and-context.png",
      "ogTitle": "CLI Option Callback and Context - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/options/callback-and-context.png",
      "og:title": "CLI Option Callback and Context - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/options/callback-and-context/?q=",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/options/callback-and-context.png",
      "twitter:title": "CLI Option Callback and Context - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/using-click/?q=#using-click)\n\n# Using Click [¶](https://typer.tiangolo.com/tutorial/using-click/?q=\\#using-click \"Permanent link\")\n\nWarning\n\nThis is a more advanced topic, if you are starting with **Typer**, feel free to skip it.\n\nIt will be mostly useful for people that already work with Click and have questions around it.\n\n**Typer** is powered by [Click](https://click.palletsprojects.com). It does all the work underneath.\n\nHere is some more information related to using both together.\n\n## A single app with both Click and **Typer** [¶](https://typer.tiangolo.com/tutorial/using-click/?q=\\#a-single-app-with-both-click-and-typer \"Permanent link\")\n\nIf you already have a Click application and want to migrate to **Typer**, or to add some Typer components, you can get a Click `Command` from your Typer application and then use Click directly.\n\n### How Click works [¶](https://typer.tiangolo.com/tutorial/using-click/?q=\\#how-click-works \"Permanent link\")\n\nBefore knowing how to combine Click and **Typer**, let's first check a little about how Click works.\n\n#### Click `Command` [¶](https://typer.tiangolo.com/tutorial/using-click/?q=\\#click-command \"Permanent link\")\n\nAny Click application has an object of class `Command`. That's, more or less, the most basic Click object.\n\nA `Command` can have its own _CLI arguments_ and _CLI options_, and it has a function that it calls.\n\nFor example, in this Click app:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nimport click\n\n@click.command()\n@click.option(\"--count\", default=1, help=\"Number of greetings.\")\n@click.option(\"--name\", prompt=\"Your name\", help=\"The person to greet.\")\ndef hello(count, name):\n    \"\"\"Simple program that greets NAME for a total of COUNT times.\"\"\"\n    for x in range(count):\n        click.echo(f\"Hello {name}!\")\n\nif __name__ == \"__main__\":\n    hello()\n\n```\n\nThe original `hello` variable is converted by Click from a function to a `Command` object. And the original `hello` function is used by that `Command` internally, but it is no longer named `hello` (as `hello` is now a Click `Command`).\n\n#### Click `Group` [¶](https://typer.tiangolo.com/tutorial/using-click/?q=\\#click-group \"Permanent link\")\n\nThen Click also has a `Group` class, it **inherits from `Command`**. So, a `Group` object is _also_ a `Command`.\n\nA `Group` can also have its own _CLI arguments_ and _CLI options_.\n\nA `Group` can have subcommands of class `Command` or sub groups of class `Group` as well.\n\nAnd a `Group` can also have a function that it calls, right before calling the function for any specific subcommand.\n\nFor example:\n\n[Python 3.8+](#__tabbed_2_1)\n\n```md-code__content\nimport click\n\n@click.group()\ndef cli():\n    pass\n\n@click.command()\ndef initdb():\n    click.echo(\"Initialized the database\")\n\n@click.command()\ndef dropdb():\n    click.echo(\"Dropped the database\")\n\ncli.add_command(initdb)\ncli.add_command(dropdb)\n\nif __name__ == \"__main__\":\n    cli()\n\n```\n\nThe `cli` variable is converted by Click from a function to a `Group` object. And the original `cli` function is used by that `Group` internally.\n\nTip\n\nThe original `cli` function would be the equivalent of a [Typer Callback](https://typer.tiangolo.com/tutorial/commands/callback/).\n\nThen the `cli` variable, that now is a `Group` object, is used to add sub-commands.\n\n### How **Typer** works [¶](https://typer.tiangolo.com/tutorial/using-click/?q=\\#how-typer-works \"Permanent link\")\n\nTyper doesn't modify the functions. You create an explicit variable of class `typer.Typer` and use it to _register_ those functions.\n\nAnd then, when you call the app, Typer goes and creates a Click `Command` (or `Group`), and then calls it.\n\nIf your app only has one command, then when you call it, **Typer** creates a single Click `Command` object and calls it.\n\nBut **Typer** creates a Click `Group` object if your app has any of:\n\n- More than one command.\n- A callback.\n- Sub-Typer apps (sub commands).\n\nTip\n\nIf you want to learn more about this check the section [One or Multiple Commands](https://typer.tiangolo.com/tutorial/commands/one-or-multiple/).\n\n### Combine Click and **Typer** [¶](https://typer.tiangolo.com/tutorial/using-click/?q=\\#combine-click-and-typer \"Permanent link\")\n\n**Typer** uses an internal function `typer.main.get_command()` to generate a Click `Command` (or `Group`) from a `typer.Typer` object.\n\nYou can use it directly, and use the Click object with other Click applications.\n\n### Including a Click app in a **Typer** app [¶](https://typer.tiangolo.com/tutorial/using-click/?q=\\#including-a-click-app-in-a-typer-app \"Permanent link\")\n\nFor example, you could have a **Typer** app, generate a Click `Group` from it, and then include other Click apps in it:\n\n[Python 3.8+](#__tabbed_3_1)\n\n```md-code__content\nimport click\nimport typer\n\napp = typer.Typer()\n\n@app.command()\ndef top():\n    \"\"\"\n    Top level command, form Typer\n    \"\"\"\n    print(\"The Typer app is at the top level\")\n\n@app.callback()\ndef callback():\n    \"\"\"\n    Typer app, including Click subapp\n    \"\"\"\n\n@click.command()\n@click.option(\"--name\", prompt=\"Your name\", help=\"The person to greet.\")\ndef hello(name):\n    \"\"\"Simple program that greets NAME for a total of COUNT times.\"\"\"\n    click.echo(f\"Hello {name}!\")\n\ntyper_click_object = typer.main.get_command(app)\n\ntyper_click_object.add_command(hello, \"hello\")\n\nif __name__ == \"__main__\":\n    typer_click_object()\n\n```\n\nNotice that we add a callback that does nothing (only document the CLI program), to make sure **Typer** creates a Click `Group`. That way we can add sub-commands to that Click `Group`.\n\nThen we generate a Click object from our `typer.Typer` app ( `typer_click_object`), and then we can include another Click object ( `hello`) in this Click `Group`.\n\nAnd that way, our **Typer** app will have a subcommand `top` built with Typer, and a subcommand `hello` built with Click.\n\nCheck it:\n\n```\n\nfast →python main.py --help\n💬 Notice we have both subcommands, top and helloUsage: main.py [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  --install-completion  Install completion for the current shell.\n  --show-completion     Show completion for the current shell, to copy it or customize the installation.\n  --help                Show this message and exit.\n\nCommands:\n  hello\n  top\n\n💬 Call the Typer partpython main.py top\nThe Typer app is at the top level\n\n💬 Call the Click partpython main.py hello --name Camila\nHello Camila!\n\nrestart ↻\n```\n\n### Including a **Typer** app in a Click app [¶](https://typer.tiangolo.com/tutorial/using-click/?q=\\#including-a-typer-app-in-a-click-app \"Permanent link\")\n\nThe same way, you can do the contrary and include a **Typer** sub app in a bigger Click app:\n\n[Python 3.8+](#__tabbed_4_1)\n\n```md-code__content\nimport click\nimport typer\n\n@click.group()\ndef cli():\n    pass\n\n@cli.command()\ndef initdb():\n    click.echo(\"Initialized the database\")\n\n@cli.command()\ndef dropdb():\n    click.echo(\"Dropped the database\")\n\napp = typer.Typer()\n\n@app.command()\ndef sub():\n    \"\"\"\n    A single-command Typer sub app\n    \"\"\"\n    print(\"Typer is now below Click, the Click app is the top level\")\n\ntyper_click_object = typer.main.get_command(app)\n\ncli.add_command(typer_click_object, \"sub\")\n\nif __name__ == \"__main__\":\n    cli()\n\n```\n\nNotice that we don't have to add a callback or more commands, we can just create a **Typer** app that generates a single Click `Command`, as we don't need to include anything under the Typer app.\n\nThen we generate a Click object from our `typer.Typer` app ( `typer_click_object`), and then we use **the Click `cli` to include** our Click object from our Typer app.\n\nIn this case, the original Click app includes the **Typer** app.\n\nAnd then we call the _original Click_ app, not the Typer app.\n\nCheck it:\n\n```\n\nfast →python main.py\n💬 We get our Typer app down there in the sub commandUsage: main.py [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  dropdb\n  initdb\n  sub     A single-command Typer sub app\n\n💬 Use the Click partpython main.py initdb\nInitialized the database\n\n💬 And use the Typer partpython main.py sub\nTyper is now below Click, the Click app is the top level\n\nrestart ↻\n```\n\n## About Click decorators [¶](https://typer.tiangolo.com/tutorial/using-click/?q=\\#about-click-decorators \"Permanent link\")\n\nTyper apps don't work with Click decorators directly.\n\nThis is because **Typer** doesn't modify functions to add metadata or to convert them to another object like Click does.\n\nSo, things like `@click.pass_context` won't work.\n\nMost of the functionality provided by decorators in Click has an alternative way of doing it in **Typer**.\n\nFor example, to access the context, you can just declare a function parameter of type `typer.Context`.\n\nTip\n\nYou can read more about using the context in the docs: [Commands: Using the Context](https://typer.tiangolo.com/tutorial/commands/context/)\n\nBut if you need to use something based on Click decorators, you can always generate a Click object using the methods described above, and use it as you would normally use Click.\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/using-click/?q=",
      "ogUrl": "https://typer.tiangolo.com/tutorial/using-click/",
      "title": "Using Click - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/using-click/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/using-click.png",
      "ogTitle": "Using Click - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/using-click.png",
      "og:title": "Using Click - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/using-click/?q=",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/using-click.png",
      "twitter:title": "Using Click - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  },
  {
    "markdown": "[Skip to content](https://typer.tiangolo.com/tutorial/launch/?q=#launching-applications)\n\n# Launching Applications [¶](https://typer.tiangolo.com/tutorial/launch/?q=\\#launching-applications \"Permanent link\")\n\nYou can launch applications from your CLI program with `typer.launch()`.\n\nIt will launch the appropriate application depending on the URL or file type you pass it:\n\n[Python 3.8+](#__tabbed_1_1)\n\n```md-code__content\nimport typer\n\ndef main():\n    print(\"Opening Typer's docs\")\n    typer.launch(\"https://typer.tiangolo.com\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nCheck it:\n\n```\n\nfast →python main.py\nOpening Typer docs\n\n💬 Opens browser with Typer's docs\nrestart ↻\n```\n\n## Locating a file [¶](https://typer.tiangolo.com/tutorial/launch/?q=\\#locating-a-file \"Permanent link\")\n\nYou can also make the operating system open the file browser indicating where a file is located with `locate=True`:\n\n[Python 3.8+](#__tabbed_2_1)\n\n```md-code__content\nfrom pathlib import Path\n\nimport typer\n\nAPP_NAME = \"my-super-cli-app\"\n\ndef main():\n    app_dir = typer.get_app_dir(APP_NAME)\n    app_dir_path = Path(app_dir)\n    app_dir_path.mkdir(parents=True, exist_ok=True)\n    config_path: Path = Path(app_dir) / \"config.json\"\n    if not config_path.is_file():\n        config_path.write_text('{\"version\": \"1.0.0\"}')\n    config_file_str = str(config_path)\n    print(\"Opening config directory\")\n    typer.launch(config_file_str, locate=True)\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\nTip\n\nThe rest of the code in this example is just making sure the app directory exists and creating the config file.\n\nBut the most important part is the `typer.launch(config_file_str, locate=True)` with the argument `locate=True`.\n\nCheck it:\n\n```\n\nfast →python main.py\nOpening config directory\n\n💬 Opens a file browser indicating where the config file is located\nrestart ↻\n```\n\nWas this page helpful?\n\n\n\n\n\n\nThanks for your feedback!\n\n\n\n\n\n\nThanks for your feedback!\n\n\nBack to top",
    "metadata": {
      "url": "https://typer.tiangolo.com/tutorial/launch/?q=",
      "ogUrl": "https://typer.tiangolo.com/tutorial/launch/",
      "title": "Launching Applications - Typer",
      "og:url": "https://typer.tiangolo.com/tutorial/launch/",
      "og:type": "website",
      "ogImage": "https://typer.tiangolo.com/assets/images/social/tutorial/launch.png",
      "ogTitle": "Launching Applications - Typer",
      "language": "en",
      "og:image": "https://typer.tiangolo.com/assets/images/social/tutorial/launch.png",
      "og:title": "Launching Applications - Typer",
      "viewport": "width=device-width,initial-scale=1",
      "generator": "mkdocs-1.6.1, mkdocs-material-9.5.30+insiders-4.53.11",
      "sourceURL": "https://typer.tiangolo.com/tutorial/launch/?q=",
      "statusCode": 200,
      "description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "theme-color": "#00000000",
      "color-scheme": "normal",
      "twitter:card": "summary_large_image",
      "og:image:type": "image/png",
      "ogDescription": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "twitter:image": "https://typer.tiangolo.com/assets/images/social/tutorial/launch.png",
      "twitter:title": "Launching Applications - Typer",
      "og:description": "Typer, build great CLIs. Easy to code. Based on Python type hints.",
      "og:image:width": "1200",
      "og:image:height": "630",
      "ogLocaleAlternate": [],
      "twitter:description": "Typer, build great CLIs. Easy to code. Based on Python type hints."
    }
  }
]